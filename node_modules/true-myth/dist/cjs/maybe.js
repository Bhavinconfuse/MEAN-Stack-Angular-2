"use strict";
/** [[include:doc/maybe.md]] */
Object.defineProperty(exports, "__esModule", { value: true });
/** (keep typedoc from getting confused by the imports) */
const result_1 = require("./result");
const utils_1 = require("./utils");
/**
  Discriminant for the `Just` and `Nothing` variants.

  You can use the discriminant via the `variant` property of `Maybe` instances
  if you need to match explicitly on it.
 */
var Variant;
(function (Variant) {
    Variant["Just"] = "Just";
    Variant["Nothing"] = "Nothing";
})(Variant = exports.Variant || (exports.Variant = {}));
/**
  A `Just` instance is the *present* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type wrapped in this `Just` variant of `Maybe`.
 */
class Just {
    /**
      Create an instance of `Maybe.Just` with `new`.
  
      @note While you *may* create the `Just` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.just`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.just`]: ../modules/_maybe_.html#just
  
      ```ts
      // Avoid:
      const aString = new Maybe.Just('characters');
  
      // Prefer:
      const aString = Maybe.just('characters);
      ```
  
      @param value
      The value to wrap in a `Maybe.Just`.
  
      `null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Maybe<undefined>`.
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(value) {
        /** `Just` is always [`Variant.Just`](../enums/_maybe_.variant#just). */
        this.variant = Variant.Just;
        if (utils_1.isVoid(value)) {
            throw new Error('Tried to construct `Just` with `null` or `undefined`');
        }
        this.value = value;
    }
    /**
      Unwrap the contained value. A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Maybe, { Just } from 'true-myth/maybe';
  
      function getLengths(maybeStrings: Array<Maybe<string>>): Array<number> {
        return maybeStrings
          .filter(Maybe.isJust)
          .map(Just.unwrap)
          .map(s => s.length);
      }
      ```
     */
    static unwrap(theJust) {
        return theJust.value;
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return true;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return false;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        return this.value;
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
}
exports.Just = Just;
/**
  A `Nothing` instance is the *absent* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type which would be wrapped in a `Just` variant of `Maybe`.
 */
class Nothing {
    /**
      Create an instance of `Maybe.Nothing` with `new`.
  
      @note While you *may* create the `Nothing` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.nothing`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.nothing`]: ../modules/_maybe_.html#nothing
  
      ```ts
      // Avoid:
      const aNothing = new Maybe.Err();
  
      // Prefer:
      const aNothing = Maybe.nothing();
      ```
  
      `null` and `undefined` are allowed so that you may explicitly construct the
      `Err` type with a known `null` or `undefined` value. (This maybe helpful
      primarily when transitioning a codebase to the use of `Maybe`.)
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(_) {
        /** `Nothing` is always [`Variant.Nothing`](../enums/_maybe_.variant#nothing). */
        this.variant = Variant.Nothing;
        /* nothing to do */
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return false;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return true;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        throw new Error('Tried to `unsafelyUnwrap(Nothing)`');
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
}
exports.Nothing = Nothing;
/**
  Is this result a `Just` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `Just`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Just<T>`.
 */
function isJust(maybe) {
    return maybe.variant === Variant.Just;
}
exports.isJust = isJust;
/**
  Is this result a `Nothing` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `nothing`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Nothing<T>`.
 */
function isNothing(maybe) {
    return maybe.variant === Variant.Nothing;
}
exports.isNothing = isNothing;
/**
  Create an instance of `Maybe.Just`.

  `null` and `undefined` are allowed by the type signature so that the
  function may `throw` on those rather than constructing a type like
  `Maybe<undefined>`.

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe.Just`.
  @returns     An instance of `Maybe.Just<T>`.
  @throws      If you pass `null` or `undefined`.
 */
function just(value) {
    return new Just(value);
}
exports.just = just;
/**
  Create an instance of `Maybe.Nothing`.

  If you want to create an instance with a specific type, e.g. for use in a
  function which expects a `Maybe<T>` where the `<T>` is known but you have no
  value to give it, you can use a type parameter:

  ```ts
  const notString = Maybe.nothing<string>();
  ```

  @typeparam T The type of the item contained in the `Maybe`.
  @returns     An instance of `Maybe.Nothing<T>`.
 */
function nothing(_) {
    return new Nothing(_);
}
exports.nothing = nothing;
/**
  Create a `Maybe` from any value.

  To specify that the result should be interpreted as a specific type, you may
  invoke `Maybe.of` with an explicit type parameter:

  ```ts
  const foo = Maybe.of<string>(null);
  ```

  This is usually only important in two cases:

  1.  If you are intentionally constructing a `Nothing` from a known `null` or
      undefined value *which is untyped*.
  2.  If you are specifying that the type is more general than the value passed
      (since TypeScript can define types as literals).

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe`. If it is `undefined` or `null`,
               the result will be `Nothing`; otherwise it will be the type of
               the value passed.
 */
function of(value) {
    return utils_1.isVoid(value) ? nothing() : just(value);
}
exports.of = of;
/** Alias for [`of`](#of), primarily for compatibility with Folktale. */
exports.fromNullable = of;
function map(mapFn, maybe) {
    const op = (m) => (m.isJust() ? just(mapFn(m.value)) : nothing());
    return utils_1.curry1(op, maybe);
}
exports.map = map;
function mapOr(orU, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orU;
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    return mapFn === undefined
        ? partialOp
        : maybe === undefined ? partialOp(mapFn) : partialOp(mapFn, maybe);
}
exports.mapOr = mapOr;
function mapOrElse(orElseFn, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orElseFn();
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    if (mapFn === undefined) {
        return partialOp;
    }
    else if (maybe === undefined) {
        return partialOp(mapFn);
    }
    else {
        return partialOp(mapFn, maybe);
    }
}
exports.mapOrElse = mapOrElse;
function and(andMaybe, maybe) {
    const op = (m) => (m.isJust() ? andMaybe : nothing());
    return utils_1.curry1(op, maybe);
}
exports.and = and;
function andThen(thenFn, maybe) {
    const op = (m) => (m.isJust() ? thenFn(m.value) : nothing());
    return maybe !== undefined ? op(maybe) : op;
}
exports.andThen = andThen;
/** Alias for [`andThen`](#andthen). */
exports.chain = andThen;
/** Alias for [`andThen`](#andthen). */
exports.flatMap = andThen;
function or(defaultMaybe, maybe) {
    const op = (m) => (m.isJust() ? m : defaultMaybe);
    return maybe !== undefined ? op(maybe) : op;
}
exports.or = or;
function orElse(elseFn, maybe) {
    const op = (m) => (m.isJust() ? m : elseFn());
    return utils_1.curry1(op, maybe);
}
exports.orElse = orElse;
/**
  Get the value out of the `Maybe`.

  Returns the content of a `Just`, but **throws if the `Maybe` is `Nothing`**.
  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).

  @typeparam T The type of the wrapped value.
  @param maybe The value to unwrap
  @returns     The unwrapped value if the `Maybe` instance is `Just`.
  @throws      If the `maybe` is `Nothing`.
 */
function unsafelyUnwrap(maybe) {
    return maybe.unsafelyUnwrap();
}
exports.unsafelyUnwrap = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafelyGet = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafeGet = unsafelyUnwrap;
function unwrapOr(defaultValue, maybe) {
    const op = (m) => (m.isJust() ? m.value : defaultValue);
    return utils_1.curry1(op, maybe);
}
exports.unwrapOr = unwrapOr;
/** Alias for [`unwrapOr`](#unwrapor) */
exports.getOr = unwrapOr;
function unwrapOrElse(orElseFn, maybe) {
    const op = (m) => (m.isJust() ? m.value : orElseFn());
    return utils_1.curry1(op, maybe);
}
exports.unwrapOrElse = unwrapOrElse;
/** Alias for [`unwrapOrElse`](#unwraporelse) */
exports.getOrElse = unwrapOrElse;
function toOkOrErr(error, maybe) {
    const op = (m) => (m.isJust() ? result_1.ok(m.value) : result_1.err(error));
    return maybe !== undefined ? op(maybe) : op;
}
exports.toOkOrErr = toOkOrErr;
function toOkOrElseErr(elseFn, maybe) {
    const op = (m) => (m.isJust() ? result_1.ok(m.value) : result_1.err(elseFn()));
    return utils_1.curry1(op, maybe);
}
exports.toOkOrElseErr = toOkOrElseErr;
/**
  Construct a `Maybe<T>` from a `Result<T, E>`.

  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an
  `Err`, throw away the wrapped `E` and transform to a `Nothing`.

  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @typeparam E  The type of the value wrapped in a `Result.Err`; thrown away in
                the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
 */
function fromResult(result) {
    return result.isOk() ? just(result.value) : nothing();
}
exports.fromResult = fromResult;
/**
  Create a `String` representation of a `Maybe` instance.

  A `Just` instance will be printed as `Just(<representation of the value>)`,
  where the representation of the value is simply the value's own `toString`
  representation. For example:

  | call                                   | output                  |
  |----------------------------------------|-------------------------|
  | `toString(Maybe.of(42))`               | `Just(42)`              |
  | `toString(Maybe.of([1, 2, 3]))`        | `Just(1,2,3)`           |
  | `toString(Maybe.of({ an: 'object' }))` | `Just([object Object])` |
  | `toString(Maybe.nothing())`            | `Nothing`               |

  @typeparam T The type of the wrapped value; its own `.toString` will be used
               to print the interior contents of the `Just` variant.
  @param maybe The value to convert to a string.
  @returns     The string representation of the `Maybe`.
 */
function toString(maybe) {
    const body = maybe.isJust() ? `(${maybe.value.toString()})` : '';
    return `${maybe.variant}${body}`;
}
exports.toString = toString;
function match(matcher, maybe) {
    return maybe !== undefined
        ? mapOrElse(matcher.Nothing, matcher.Just, maybe)
        : (curriedMaybe) => mapOrElse(matcher.Nothing, matcher.Just, curriedMaybe);
}
exports.match = match;
/** Alias for [`match`](#match) */
exports.cata = match;
function equals(mb, ma) {
    return ma !== undefined
        ? ma.match({
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
            Nothing: () => isNothing(mb),
        })
        : (maybeA) => maybeA.match({
            Nothing: () => isNothing(mb),
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
        });
}
exports.equals = equals;
function ap(maybeFn, maybe) {
    const op = (m) => m.match({
        Just: val => maybeFn.map(fn => fn(val)),
        Nothing: () => exports.Maybe.nothing(),
    });
    return utils_1.curry1(op, maybe);
}
exports.ap = ap;
/**
  Determine whether an item is an instance of `Just` or `Nothing`.

  @param item The item to check.
 */
function isInstance(item) {
    return item instanceof Just || item instanceof Nothing;
}
exports.isInstance = isInstance;
exports.Maybe = {
    Variant,
    Just,
    Nothing,
    isJust,
    isNothing,
    just,
    nothing,
    of,
    fromNullable: exports.fromNullable,
    map,
    mapOr,
    mapOrElse,
    and,
    andThen,
    chain: exports.chain,
    flatMap: exports.flatMap,
    or,
    orElse,
    unsafelyUnwrap,
    unsafelyGet: exports.unsafelyGet,
    unsafeGet: exports.unsafeGet,
    unwrapOr,
    getOr: exports.getOr,
    unwrapOrElse,
    getOrElse: exports.getOrElse,
    toOkOrErr,
    toOkOrElseErr,
    fromResult,
    toString,
    match,
    cata: exports.cata,
    equals,
    ap,
    isInstance,
};
exports.default = exports.Maybe;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF5YmUuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2NocmlzL2Rldi9vc3MvdHJ1ZS1teXRoLyIsInNvdXJjZXMiOlsibWF5YmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLCtCQUErQjs7QUFFL0IsMERBQTBEO0FBQzFELHFDQUEyQztBQUMzQyxtQ0FBeUM7QUFFekM7Ozs7O0dBS0c7QUFDSCxJQUFZLE9BR1g7QUFIRCxXQUFZLE9BQU87SUFDakIsd0JBQWEsQ0FBQTtJQUNiLDhCQUFtQixDQUFBO0FBQ3JCLENBQUMsRUFIVyxPQUFPLEdBQVAsZUFBTyxLQUFQLGVBQU8sUUFHbEI7QUFpRUQ7Ozs7Ozs7R0FPRztBQUNIO0lBNEJFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EyQkc7SUFDSCxZQUFZLEtBQWdCO1FBbEM1Qix3RUFBd0U7UUFDL0QsWUFBTyxHQUFpQixPQUFPLENBQUMsSUFBSSxDQUFDO1FBa0M1QyxJQUFJLGNBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7U0FDekU7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBN0REOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ0gsTUFBTSxDQUFDLE1BQU0sQ0FBSSxPQUFnQjtRQUMvQixPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDdkIsQ0FBQztJQTRDRCwwRUFBMEU7SUFDMUUsTUFBTTtRQUNKLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELGdGQUFnRjtJQUNoRixTQUFTO1FBQ1AsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsb0VBQW9FO0lBQ3BFLEdBQUcsQ0FBb0IsS0FBa0I7UUFDdkMsT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCx3RUFBd0U7SUFDeEUsS0FBSyxDQUFvQixHQUFNLEVBQUUs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Q04sRUFBRTtJQUNGLFVBQVU7Q0FDWCxDQUFDO0FBRUYsa0JBQWUsYUFBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIFtbaW5jbHVkZTpkb2MvbWF5YmUubWRdXSAqL1xuXG4vKiogKGtlZXAgdHlwZWRvYyBmcm9tIGdldHRpbmcgY29uZnVzZWQgYnkgdGhlIGltcG9ydHMpICovXG5pbXBvcnQgUmVzdWx0LCB7IGVyciwgb2sgfSBmcm9tICcuL3Jlc3VsdCc7XG5pbXBvcnQgeyBjdXJyeTEsIGlzVm9pZCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAgRGlzY3JpbWluYW50IGZvciB0aGUgYEp1c3RgIGFuZCBgTm90aGluZ2AgdmFyaWFudHMuXG5cbiAgWW91IGNhbiB1c2UgdGhlIGRpc2NyaW1pbmFudCB2aWEgdGhlIGB2YXJpYW50YCBwcm9wZXJ0eSBvZiBgTWF5YmVgIGluc3RhbmNlc1xuICBpZiB5b3UgbmVlZCB0byBtYXRjaCBleHBsaWNpdGx5IG9uIGl0LlxuICovXG5leHBvcnQgZW51bSBWYXJpYW50IHtcbiAgSnVzdCA9ICdKdXN0JyxcbiAgTm90aGluZyA9ICdOb3RoaW5nJyxcbn1cblxuLyoqIFNpbXBseSBkZWZpbmVzIHRoZSBjb21tb24gc2hhcGUgZm9yIGBKdXN0YCBhbmQgYE5vdGhpbmdgLiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYXliZVNoYXBlPFQ+IHtcbiAgLyoqIERpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIGBKdXN0YCBhbmQgYE5vdGhpbmdgIFt2YXJpYW50c10oLi4vZW51bXMvX21heWJlXy52YXJpYW50KS4gKi9cbiAgcmVhZG9ubHkgdmFyaWFudDogVmFyaWFudDtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuaXNKdXN0YF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjaXNqdXN0KSAqL1xuICBpc0p1c3QodGhpczogTWF5YmU8VD4pOiB0aGlzIGlzIEp1c3Q8VD47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzTm90aGluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzbm90aGluZykgKi9cbiAgaXNOb3RoaW5nKHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBOb3RoaW5nPFQ+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXApICovXG4gIG1hcDxVPih0aGlzOiBNYXliZTxUPiwgbWFwRm46ICh0OiBUKSA9PiBVKTogTWF5YmU8VT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcE9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3IpICovXG4gIG1hcE9yPFU+KHRoaXM6IE1heWJlPFQ+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFU7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcE9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yZWxzZSkgKi9cbiAgbWFwT3JFbHNlPFU+KHRoaXM6IE1heWJlPFQ+LCBvckVsc2VGbjogKCkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVTtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWF0Y2hgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXRjaCkgKi9cbiAgbWF0Y2g8VT4odGhpczogTWF5YmU8VD4sIG1hdGNoZXI6IE1hdGNoZXI8VCwgVT4pOiBVO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI29yKSAqL1xuICBvcih0aGlzOiBNYXliZTxUPiwgbU9yOiBNYXliZTxUPik6IE1heWJlPFQ+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcmVsc2UpICovXG4gIG9yRWxzZSh0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IE1heWJlPFQ+KTogTWF5YmU8VD47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZCkgKi9cbiAgYW5kPFU+KHRoaXM6IE1heWJlPFQ+LCBtQW5kOiBNYXliZTxVPik6IE1heWJlPFU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRUaGVuYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYW5kdGhlbikgKi9cbiAgYW5kVGhlbjxVPih0aGlzOiBNYXliZTxUPiwgYW5kVGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuY2hhaW5gXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNjaGFpbikgKi9cbiAgY2hhaW48VT4odGhpczogTWF5YmU8VD4sIGNoYWluRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5mbGF0TWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZmxhdG1hcCkgKi9cbiAgZmxhdE1hcDxVPih0aGlzOiBNYXliZTxUPiwgZmxhdE1hcEZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwKSAqL1xuICB1bnNhZmVseVVud3JhcCgpOiBUIHwgbmV2ZXI7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVud3JhcE9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcG9yZWxzZSkgKi9cbiAgdW53cmFwT3JFbHNlKHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IFQpOiBUO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlcnIpICovXG4gIHRvT2tPckVycjxFPih0aGlzOiBNYXliZTxUPiwgZXJyb3I6IEUpOiBSZXN1bHQ8VCwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVsc2VFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlbHNlZXJyKSAqL1xuICB0b09rT3JFbHNlRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IEUpOiBSZXN1bHQ8VCwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvU3RyaW5nYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9zdHJpbmcpICovXG4gIHRvU3RyaW5nKHRoaXM6IE1heWJlPFQ+KTogc3RyaW5nO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5lcXVhbHNgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNlcXVhbHMpICovXG4gIGVxdWFscyh0aGlzOiBNYXliZTxUPiwgY29tcGFyaXNvbjogTWF5YmU8VD4pOiBib29sZWFuO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FwKSAqL1xuICBhcDxVPih0aGlzOiBNYXliZTwodmFsOiBUKSA9PiBVPiwgdmFsOiBNYXliZTxUPik6IE1heWJlPFU+O1xufVxuXG4vKipcbiAgQSBgSnVzdGAgaW5zdGFuY2UgaXMgdGhlICpwcmVzZW50KiB2YXJpYW50IGluc3RhbmNlIG9mIHRoZVxuICBbYE1heWJlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWF5YmUpIHR5cGUsIHJlcHJlc2VudGluZyB0aGUgcHJlc2VuY2Ugb2YgYVxuICB2YWx1ZSB3aGljaCBtYXkgYmUgYWJzZW50LiBGb3IgYSBmdWxsIGRpc2N1c3Npb24sIHNlZSBbdGhlIG1vZHVsZVxuICBkb2NzXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCkuXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIHdyYXBwZWQgaW4gdGhpcyBgSnVzdGAgdmFyaWFudCBvZiBgTWF5YmVgLlxuICovXG5leHBvcnQgY2xhc3MgSnVzdDxUPiBpbXBsZW1lbnRzIE1heWJlU2hhcGU8VD4ge1xuICAvKipcbiAgICBVbndyYXAgdGhlIGNvbnRhaW5lZCB2YWx1ZS4gQSBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGZ1bmN0aW9uYWwgaWRpb21zLlxuXG4gICAgQSBjb21tb24gc2NlbmFyaW8gd2hlcmUgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIHRoaXMgaXMgaW4gYSBwaXBlbGluZSBvZlxuICAgIGZ1bmN0aW9uczpcblxuICAgIGBgYHRzXG4gICAgaW1wb3J0IE1heWJlLCB7IEp1c3QgfSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RocyhtYXliZVN0cmluZ3M6IEFycmF5PE1heWJlPHN0cmluZz4+KTogQXJyYXk8bnVtYmVyPiB7XG4gICAgICByZXR1cm4gbWF5YmVTdHJpbmdzXG4gICAgICAgIC5maWx0ZXIoTWF5YmUuaXNKdXN0KVxuICAgICAgICAubWFwKEp1c3QudW53cmFwKVxuICAgICAgICAubWFwKHMgPT4gcy5sZW5ndGgpO1xuICAgIH1cbiAgICBgYGBcbiAgICovXG4gIHN0YXRpYyB1bndyYXA8Sj4odGhlSnVzdDogSnVzdDxKPik6IEoge1xuICAgIHJldHVybiB0aGVKdXN0LnZhbHVlO1xuICB9XG5cbiAgLyoqIGBKdXN0YCBpcyBhbHdheXMgW2BWYXJpYW50Lkp1c3RgXSguLi9lbnVtcy9fbWF5YmVfLnZhcmlhbnQjanVzdCkuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQuSnVzdCA9IFZhcmlhbnQuSnVzdDtcblxuICAvKiogVGhlIHdyYXBwZWQgdmFsdWUuICovXG4gIHJlYWRvbmx5IHZhbHVlOiBUO1xuXG4gIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgTWF5YmUuSnVzdGAgd2l0aCBgbmV3YC5cblxuICAgIEBub3RlIFdoaWxlIHlvdSAqbWF5KiBjcmVhdGUgdGhlIGBKdXN0YCB0eXBlIHZpYSBub3JtYWwgSmF2YVNjcmlwdFxuICAgIGNsYXNzIGNvbnN0cnVjdGlvbiwgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB0aGUgZnVuY3Rpb25hbCBzdHlsZSBmb3JcbiAgICB3aGljaCB0aGUgbGlicmFyeSBpcyBpbnRlbmRlZC4gSW5zdGVhZCwgdXNlIFtgTWF5YmUub2ZgXSAoZm9yIHRoZSBnZW5lcmFsXG4gICAgY2FzZSkgb3IgW2BNYXliZS5qdXN0YF0gZm9yIHRoaXMgc3BlY2lmaWMgY2FzZS5cblxuICAgIFtgTWF5YmUub2ZgXTogLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb2ZcbiAgICBbYE1heWJlLmp1c3RgXTogLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjanVzdFxuXG4gICAgYGBgdHNcbiAgICAvLyBBdm9pZDpcbiAgICBjb25zdCBhU3RyaW5nID0gbmV3IE1heWJlLkp1c3QoJ2NoYXJhY3RlcnMnKTtcblxuICAgIC8vIFByZWZlcjpcbiAgICBjb25zdCBhU3RyaW5nID0gTWF5YmUuanVzdCgnY2hhcmFjdGVycyk7XG4gICAgYGBgXG5cbiAgICBAcGFyYW0gdmFsdWVcbiAgICBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBNYXliZS5KdXN0YC5cblxuICAgIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGFsbG93ZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIHNvIHRoYXQgdGhlXG4gICAgY29uc3RydWN0b3IgbWF5IGB0aHJvd2Agb24gdGhvc2UgcmF0aGVyIHRoYW4gY29uc3RydWN0aW5nIGEgdHlwZSBsaWtlXG4gICAgYE1heWJlPHVuZGVmaW5lZD5gLlxuXG4gICAgQHRocm93cyAgICAgIElmIHlvdSBwYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlPzogVCB8IG51bGwpIHtcbiAgICBpZiAoaXNWb2lkKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBjb25zdHJ1Y3QgYEp1c3RgIHdpdGggYG51bGxgIG9yIGB1bmRlZmluZWRgJyk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzSnVzdGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzanVzdCkgKi9cbiAgaXNKdXN0KHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBKdXN0PFQ+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc05vdGhpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc25vdGhpbmcpICovXG4gIGlzTm90aGluZyh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgTm90aGluZzxUPiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcCkgKi9cbiAgbWFwPFU+KHRoaXM6IE1heWJlPFQ+LCBtYXBGbjogKHQ6IFQpID0+IFUpOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIG1hcChtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwT3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcikgKi9cbiAgbWFwT3I8VT4odGhpczogTWF5YmU8VD4sIG9yVTogVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVSB7XG4gICAgcmV0dXJuIG1hcE9yKG9yVSwgbWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcE9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yZWxzZSkgKi9cbiAgbWFwT3JFbHNlPFU+KHRoaXM6IE1heWJlPFQ+LCBvckVsc2VGbjogKCkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVSB7XG4gICAgcmV0dXJuIG1hcE9yRWxzZShvckVsc2VGbiwgbWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hdGNoYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWF0Y2gpICovXG4gIG1hdGNoPFU+KHRoaXM6IE1heWJlPFQ+LCBtYXRjaGVyOiBNYXRjaGVyPFQsIFU+KTogVSB7XG4gICAgcmV0dXJuIG1hdGNoKG1hdGNoZXIsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3IpICovXG4gIG9yKHRoaXM6IE1heWJlPFQ+LCBtT3I6IE1heWJlPFQ+KTogTWF5YmU8VD4ge1xuICAgIHJldHVybiBvcihtT3IsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI29yZWxzZSkgKi9cbiAgb3JFbHNlKHRoaXM6IE1heWJlPFQ+LCBvckVsc2VGbjogKCkgPT4gTWF5YmU8VD4pOiBNYXliZTxUPiB7XG4gICAgcmV0dXJuIG9yRWxzZShvckVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYW5kYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYW5kKSAqL1xuICBhbmQ8VT4odGhpczogTWF5YmU8VD4sIG1BbmQ6IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiBhbmQobUFuZCwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYW5kVGhlbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZHRoZW4pICovXG4gIGFuZFRoZW48VT4odGhpczogTWF5YmU8VD4sIGFuZFRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiBhbmRUaGVuKGFuZFRoZW5GbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuY2hhaW5gXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNjaGFpbikgKi9cbiAgY2hhaW48VT4odGhpczogTWF5YmU8VD4sIGNoYWluRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gdGhpcy5hbmRUaGVuKGNoYWluRm4pO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmZsYXRNYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNmbGF0bWFwKSAqL1xuICBmbGF0TWFwPFU+KHRoaXM6IE1heWJlPFQ+LCBmbGF0TWFwRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gdGhpcy5hbmRUaGVuKGZsYXRNYXBGbik7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW5zYWZlbHlVbndyYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bnNhZmVseXVud3JhcCkgKi9cbiAgdW5zYWZlbHlVbndyYXAoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwT3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bndyYXBvcikgKi9cbiAgdW53cmFwT3IodGhpczogTWF5YmU8VD4sIGRlZmF1bHRWYWx1ZTogVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPcihkZWZhdWx0VmFsdWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVud3JhcE9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcG9yZWxzZSkgKi9cbiAgdW53cmFwT3JFbHNlKHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3JFbHNlKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9Pa09yRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZXJyKSAqL1xuICB0b09rT3JFcnI8RT4odGhpczogTWF5YmU8VD4sIGVycm9yOiBFKTogUmVzdWx0PFQsIEU+IHtcbiAgICByZXR1cm4gdG9Pa09yRXJyKGVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFbHNlRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZWxzZWVycikgKi9cbiAgdG9Pa09yRWxzZUVycjxFPih0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBFKTogUmVzdWx0PFQsIEU+IHtcbiAgICByZXR1cm4gdG9Pa09yRWxzZUVycihlbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvU3RyaW5nYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9zdHJpbmcpICovXG4gIHRvU3RyaW5nKHRoaXM6IE1heWJlPFQ+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZXF1YWxzYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZXF1YWxzKSAqL1xuICBlcXVhbHModGhpczogTWF5YmU8VD4sIGNvbXBhcmlzb246IE1heWJlPFQ+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVxdWFscyhjb21wYXJpc29uLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FwKSAqL1xuICBhcDxBLCBCPih0aGlzOiBNYXliZTwodmFsOiBBKSA9PiBCPiwgdmFsOiBNYXliZTxBPik6IE1heWJlPEI+IHtcbiAgICByZXR1cm4gYXAodGhpcywgdmFsKTtcbiAgfVxufVxuXG4vKipcbiAgQSBgTm90aGluZ2AgaW5zdGFuY2UgaXMgdGhlICphYnNlbnQqIHZhcmlhbnQgaW5zdGFuY2Ugb2YgdGhlXG4gIFtgTWF5YmVgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXliZSkgdHlwZSwgcmVwcmVzZW50aW5nIHRoZSBwcmVzZW5jZSBvZiBhXG4gIHZhbHVlIHdoaWNoIG1heSBiZSBhYnNlbnQuIEZvciBhIGZ1bGwgZGlzY3Vzc2lvbiwgc2VlIFt0aGUgbW9kdWxlXG4gIGRvY3NdKC4uL21vZHVsZXMvX21heWJlXy5odG1sKS5cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgd2hpY2ggd291bGQgYmUgd3JhcHBlZCBpbiBhIGBKdXN0YCB2YXJpYW50IG9mIGBNYXliZWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RoaW5nPFQ+IGltcGxlbWVudHMgTWF5YmVTaGFwZTxUPiB7XG4gIC8qKiBgTm90aGluZ2AgaXMgYWx3YXlzIFtgVmFyaWFudC5Ob3RoaW5nYF0oLi4vZW51bXMvX21heWJlXy52YXJpYW50I25vdGhpbmcpLiAqL1xuICByZWFkb25seSB2YXJpYW50OiBWYXJpYW50Lk5vdGhpbmcgPSBWYXJpYW50Lk5vdGhpbmc7XG5cbiAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBNYXliZS5Ob3RoaW5nYCB3aXRoIGBuZXdgLlxuXG4gICAgQG5vdGUgV2hpbGUgeW91ICptYXkqIGNyZWF0ZSB0aGUgYE5vdGhpbmdgIHR5cGUgdmlhIG5vcm1hbCBKYXZhU2NyaXB0XG4gICAgY2xhc3MgY29uc3RydWN0aW9uLCBpdCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHRoZSBmdW5jdGlvbmFsIHN0eWxlIGZvclxuICAgIHdoaWNoIHRoZSBsaWJyYXJ5IGlzIGludGVuZGVkLiBJbnN0ZWFkLCB1c2UgW2BNYXliZS5vZmBdIChmb3IgdGhlIGdlbmVyYWxcbiAgICBjYXNlKSBvciBbYE1heWJlLm5vdGhpbmdgXSBmb3IgdGhpcyBzcGVjaWZpYyBjYXNlLlxuXG4gICAgW2BNYXliZS5vZmBdOiAuLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvZlxuICAgIFtgTWF5YmUubm90aGluZ2BdOiAuLi9tb2R1bGVzL19tYXliZV8uaHRtbCNub3RoaW5nXG5cbiAgICBgYGB0c1xuICAgIC8vIEF2b2lkOlxuICAgIGNvbnN0IGFOb3RoaW5nID0gbmV3IE1heWJlLkVycigpO1xuXG4gICAgLy8gUHJlZmVyOlxuICAgIGNvbnN0IGFOb3RoaW5nID0gTWF5YmUubm90aGluZygpO1xuICAgIGBgYFxuXG4gICAgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgYWxsb3dlZCBzbyB0aGF0IHlvdSBtYXkgZXhwbGljaXRseSBjb25zdHJ1Y3QgdGhlXG4gICAgYEVycmAgdHlwZSB3aXRoIGEga25vd24gYG51bGxgIG9yIGB1bmRlZmluZWRgIHZhbHVlLiAoVGhpcyBtYXliZSBoZWxwZnVsXG4gICAgcHJpbWFyaWx5IHdoZW4gdHJhbnNpdGlvbmluZyBhIGNvZGViYXNlIHRvIHRoZSB1c2Ugb2YgYE1heWJlYC4pXG5cbiAgICBAdGhyb3dzICAgICAgSWYgeW91IHBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXz86IG51bGwpIHtcbiAgICAvKiBub3RoaW5nIHRvIGRvICovXG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuaXNKdXN0YF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjaXNqdXN0KSAqL1xuICBpc0p1c3QodGhpczogTWF5YmU8VD4pOiB0aGlzIGlzIEp1c3Q8VD4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc05vdGhpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc25vdGhpbmcpICovXG4gIGlzTm90aGluZyh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgTm90aGluZzxUPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogTWF5YmU8VD4sIG1hcEZuOiAodDogVCkgPT4gVSk6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gbWFwKG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yKSAqL1xuICBtYXBPcjxVPih0aGlzOiBNYXliZTxUPiwgb3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVIHtcbiAgICByZXR1cm4gbWFwT3Iob3JVLCBtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3JlbHNlKSAqL1xuICBtYXBPckVsc2U8VT4odGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVIHtcbiAgICByZXR1cm4gbWFwT3JFbHNlKG9yRWxzZUZuLCBtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWF0Y2hgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXRjaCkgKi9cbiAgbWF0Y2g8VT4odGhpczogTWF5YmU8VD4sIG1hdGNoZXI6IE1hdGNoZXI8VCwgVT4pOiBVIHtcbiAgICByZXR1cm4gbWF0Y2gobWF0Y2hlciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcikgKi9cbiAgb3IodGhpczogTWF5YmU8VD4sIG1PcjogTWF5YmU8VD4pOiBNYXliZTxUPiB7XG4gICAgcmV0dXJuIG9yKG1PciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3JlbHNlKSAqL1xuICBvckVsc2UodGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBNYXliZTxUPik6IE1heWJlPFQ+IHtcbiAgICByZXR1cm4gb3JFbHNlKG9yRWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmQpICovXG4gIGFuZDxVPih0aGlzOiBNYXliZTxUPiwgbUFuZDogTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIGFuZChtQW5kLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRUaGVuYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYW5kdGhlbikgKi9cbiAgYW5kVGhlbjxVPih0aGlzOiBNYXliZTxUPiwgYW5kVGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIGFuZFRoZW4oYW5kVGhlbkZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5jaGFpbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2NoYWluKSAqL1xuICBjaGFpbjxVPih0aGlzOiBNYXliZTxUPiwgY2hhaW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiB0aGlzLmFuZFRoZW4oY2hhaW5Gbik7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZmxhdE1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2ZsYXRtYXApICovXG4gIGZsYXRNYXA8VT4odGhpczogTWF5YmU8VD4sIGZsYXRNYXBGbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiB0aGlzLmFuZFRoZW4oZmxhdE1hcEZuKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bnNhZmVseVVud3JhcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vuc2FmZWx5dW53cmFwKSAqL1xuICB1bnNhZmVseVVud3JhcCgpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBgdW5zYWZlbHlVbndyYXAoTm90aGluZylgJyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwT3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bndyYXBvcikgKi9cbiAgdW53cmFwT3IodGhpczogTWF5YmU8VD4sIGRlZmF1bHRWYWx1ZTogVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPcihkZWZhdWx0VmFsdWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVud3JhcE9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcG9yZWxzZSkgKi9cbiAgdW53cmFwT3JFbHNlKHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3JFbHNlKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9Pa09yRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZXJyKSAqL1xuICB0b09rT3JFcnI8RT4odGhpczogTWF5YmU8VD4sIGVycm9yOiBFKTogUmVzdWx0PFQsIEU+IHtcbiAgICByZXR1cm4gdG9Pa09yRXJyKGVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFbHNlRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZWxzZWVycikgKi9cbiAgdG9Pa09yRWxzZUVycjxFPih0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBFKTogUmVzdWx0PFQsIEU+IHtcbiAgICByZXR1cm4gdG9Pa09yRWxzZUVycihlbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvU3RyaW5nYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9zdHJpbmcpICovXG4gIHRvU3RyaW5nKHRoaXM6IE1heWJlPFQ+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gdG9TdHJpbmcodGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZXF1YWxzYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZXF1YWxzKSAqL1xuICBlcXVhbHModGhpczogTWF5YmU8VD4sIGNvbXBhcmlzb246IE1heWJlPFQ+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVxdWFscyhjb21wYXJpc29uLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FwKSAqL1xuICBhcDxBLCBCPih0aGlzOiBNYXliZTwodmFsOiBBKSA9PiBCPiwgdmFsOiBNYXliZTxBPik6IE1heWJlPEI+IHtcbiAgICByZXR1cm4gYXAodGhpcywgdmFsKTtcbiAgfVxufVxuXG4vKipcbiAgSXMgdGhpcyByZXN1bHQgYSBgSnVzdGAgaW5zdGFuY2U/XG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gbWF5YmUgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gIEByZXR1cm5zICAgICBgdHJ1ZWAgaWYgYG1heWJlYCBpcyBgSnVzdGAsIGBmYWxzZWAgb3RoZXJ3aXNlLiBJbiBUeXBlU2NyaXB0LFxuICAgICAgICAgICAgICAgYWxzbyBuYXJyb3dzIHRoZSB0eXBlIGZyb20gYE1heWJlPFQ+YCB0byBgSnVzdDxUPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0p1c3Q8VD4obWF5YmU6IE1heWJlPFQ+KTogbWF5YmUgaXMgSnVzdDxUPiB7XG4gIHJldHVybiBtYXliZS52YXJpYW50ID09PSBWYXJpYW50Lkp1c3Q7XG59XG5cbi8qKlxuICBJcyB0aGlzIHJlc3VsdCBhIGBOb3RoaW5nYCBpbnN0YW5jZT9cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjaGVjay5cbiAgQHJldHVybnMgICAgIGB0cnVlYCBpZiBgbWF5YmVgIGlzIGBub3RoaW5nYCwgYGZhbHNlYCBvdGhlcndpc2UuIEluIFR5cGVTY3JpcHQsXG4gICAgICAgICAgICAgICBhbHNvIG5hcnJvd3MgdGhlIHR5cGUgZnJvbSBgTWF5YmU8VD5gIHRvIGBOb3RoaW5nPFQ+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm90aGluZzxUPihtYXliZTogTWF5YmU8VD4pOiBtYXliZSBpcyBOb3RoaW5nPFQ+IHtcbiAgcmV0dXJuIG1heWJlLnZhcmlhbnQgPT09IFZhcmlhbnQuTm90aGluZztcbn1cblxuLyoqXG4gIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgTWF5YmUuSnVzdGAuXG5cbiAgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgYWxsb3dlZCBieSB0aGUgdHlwZSBzaWduYXR1cmUgc28gdGhhdCB0aGVcbiAgZnVuY3Rpb24gbWF5IGB0aHJvd2Agb24gdGhvc2UgcmF0aGVyIHRoYW4gY29uc3RydWN0aW5nIGEgdHlwZSBsaWtlXG4gIGBNYXliZTx1bmRlZmluZWQ+YC5cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIGl0ZW0gY29udGFpbmVkIGluIHRoZSBgTWF5YmVgLlxuICBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgTWF5YmUuSnVzdGAuXG4gIEByZXR1cm5zICAgICBBbiBpbnN0YW5jZSBvZiBgTWF5YmUuSnVzdDxUPmAuXG4gIEB0aHJvd3MgICAgICBJZiB5b3UgcGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqdXN0PFQ+KHZhbHVlPzogVCB8IG51bGwpOiBNYXliZTxUPiB7XG4gIHJldHVybiBuZXcgSnVzdDxUPih2YWx1ZSk7XG59XG5cbi8qKlxuICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYE1heWJlLk5vdGhpbmdgLlxuXG4gIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWMgdHlwZSwgZS5nLiBmb3IgdXNlIGluIGFcbiAgZnVuY3Rpb24gd2hpY2ggZXhwZWN0cyBhIGBNYXliZTxUPmAgd2hlcmUgdGhlIGA8VD5gIGlzIGtub3duIGJ1dCB5b3UgaGF2ZSBub1xuICB2YWx1ZSB0byBnaXZlIGl0LCB5b3UgY2FuIHVzZSBhIHR5cGUgcGFyYW1ldGVyOlxuXG4gIGBgYHRzXG4gIGNvbnN0IG5vdFN0cmluZyA9IE1heWJlLm5vdGhpbmc8c3RyaW5nPigpO1xuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIGl0ZW0gY29udGFpbmVkIGluIHRoZSBgTWF5YmVgLlxuICBAcmV0dXJucyAgICAgQW4gaW5zdGFuY2Ugb2YgYE1heWJlLk5vdGhpbmc8VD5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm90aGluZzxUPihfPzogbnVsbCk6IE1heWJlPFQ+IHtcbiAgcmV0dXJuIG5ldyBOb3RoaW5nPFQ+KF8pO1xufVxuXG4vKipcbiAgQ3JlYXRlIGEgYE1heWJlYCBmcm9tIGFueSB2YWx1ZS5cblxuICBUbyBzcGVjaWZ5IHRoYXQgdGhlIHJlc3VsdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBzcGVjaWZpYyB0eXBlLCB5b3UgbWF5XG4gIGludm9rZSBgTWF5YmUub2ZgIHdpdGggYW4gZXhwbGljaXQgdHlwZSBwYXJhbWV0ZXI6XG5cbiAgYGBgdHNcbiAgY29uc3QgZm9vID0gTWF5YmUub2Y8c3RyaW5nPihudWxsKTtcbiAgYGBgXG5cbiAgVGhpcyBpcyB1c3VhbGx5IG9ubHkgaW1wb3J0YW50IGluIHR3byBjYXNlczpcblxuICAxLiAgSWYgeW91IGFyZSBpbnRlbnRpb25hbGx5IGNvbnN0cnVjdGluZyBhIGBOb3RoaW5nYCBmcm9tIGEga25vd24gYG51bGxgIG9yXG4gICAgICB1bmRlZmluZWQgdmFsdWUgKndoaWNoIGlzIHVudHlwZWQqLlxuICAyLiAgSWYgeW91IGFyZSBzcGVjaWZ5aW5nIHRoYXQgdGhlIHR5cGUgaXMgbW9yZSBnZW5lcmFsIHRoYW4gdGhlIHZhbHVlIHBhc3NlZFxuICAgICAgKHNpbmNlIFR5cGVTY3JpcHQgY2FuIGRlZmluZSB0eXBlcyBhcyBsaXRlcmFscykuXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSBpdGVtIGNvbnRhaW5lZCBpbiB0aGUgYE1heWJlYC5cbiAgQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYE1heWJlYC4gSWYgaXQgaXMgYHVuZGVmaW5lZGAgb3IgYG51bGxgLFxuICAgICAgICAgICAgICAgdGhlIHJlc3VsdCB3aWxsIGJlIGBOb3RoaW5nYDsgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgdGhlIHR5cGUgb2ZcbiAgICAgICAgICAgICAgIHRoZSB2YWx1ZSBwYXNzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZjxUPih2YWx1ZT86IFQgfCBudWxsKTogTWF5YmU8VD4ge1xuICByZXR1cm4gaXNWb2lkKHZhbHVlKSA/IG5vdGhpbmc8VD4oKSA6IGp1c3QodmFsdWUpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgb2ZgXSgjb2YpLCBwcmltYXJpbHkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBGb2xrdGFsZS4gKi9cbmV4cG9ydCBjb25zdCBmcm9tTnVsbGFibGUgPSBvZjtcblxuLyoqXG4gIE1hcCBvdmVyIGEgYE1heWJlYCBpbnN0YW5jZTogYXBwbHkgdGhlIGZ1bmN0aW9uIHRvIHRoZSB3cmFwcGVkIHZhbHVlIGlmIHRoZVxuICBpbnN0YW5jZSBpcyBgSnVzdGAsIGFuZCByZXR1cm4gYE5vdGhpbmdgIGlmIHRoZSBpbnN0YW5jZSBpcyBgTm90aGluZ2AuXG5cbiAgYE1heWJlLm1hcGAgd29ya3MgYSBsb3QgbGlrZSBgQXJyYXkucHJvdG90eXBlLm1hcGA6IGBNYXliZWAgYW5kIGBBcnJheWAgYXJlXG4gIGJvdGggKmNvbnRhaW5lcnMqIGZvciBvdGhlciB0aGluZ3MuIElmIHlvdSBoYXZlIG5vIGl0ZW1zIGluIGFuIGFycmF5IG9mXG4gIG51bWJlcnMgbmFtZWQgYGZvb2AgYW5kIGNhbGwgYGZvby5tYXAoeCA9PiB4ICsgMSlgLCB5b3UnbGwgc3RpbGwganVzdCBoYXZlIGFuXG4gIGFycmF5IHdpdGggbm90aGluZyBpbiBpdC4gQnV0IGlmIHlvdSBoYXZlIGFueSBpdGVtcyBpbiB0aGUgYXJyYXkgKGBbMiwgM11gKSxcbiAgYW5kIHlvdSBjYWxsIGBmb28ubWFwKHggPT4geCArIDEpYCBvbiBpdCwgeW91J2xsIGdldCBhIG5ldyBhcnJheSB3aXRoIGVhY2ggb2ZcbiAgdGhvc2UgaXRlbXMgaW5zaWRlIHRoZSBhcnJheSBcImNvbnRhaW5lclwiIHRyYW5zZm9ybWVkIChgWzMsIDRdYCkuXG5cbiAgVGhhdCdzIGV4YWN0bHkgd2hhdCdzIGhhcHBlbmluZyB3aXRoIGBNYXliZS5tYXBgLiBJZiB0aGUgY29udGFpbmVyIGlzICplbXB0eSpcbiAg4oCTwqB0aGUgYE5vdGhpbmdgIHZhcmlhbnQg4oCTIHlvdSBqdXN0IGdldCBiYWNrIGFuIGVtcHR5IGNvbnRhaW5lci4gSWYgdGhlXG4gIGNvbnRhaW5lciBoYXMgc29tZXRoaW5nIGluIGl0IOKAk8KgdGhlIGBKdXN0YCB2YXJpYW50IOKAk8KgeW91IGdldCBiYWNrIGEgY29udGFpbmVyXG4gIHdpdGggdGhlIGl0ZW0gaW5zaWRlIHRyYW5zZm9ybWVkLlxuXG4gIChTby4uLiB3aHkgbm90IGp1c3QgdXNlIGFuIGFycmF5PyBUaGUgYmlnZ2VzdCByZWFzb24gaXMgdGhhdCBhbiBhcnJheSBjYW4gYmVcbiAgYW55IGxlbmd0aC4gV2l0aCBhIGBNYXliZWAsIHdlJ3JlIGNhcHR1cmluZyB0aGUgaWRlYSBvZiBcInNvbWV0aGluZyBvclxuICBub3RoaW5nXCIgcmF0aGVyIHRoYW4gXCIwIHRvIG5cIiBpdGVtcy4gQW5kIHRoaXMgbGV0cyB1cyBpbXBsZW1lbnQgYSB3aG9sZSBzZXRcbiAgb2YgKm90aGVyKiBpbnRlcmZhY2VzLCBsaWtlIHRob3NlIGluIHRoaXMgbW9kdWxlLilcblxuICAjIyMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgY29uc3QgbGVuZ3RoID0gKHM6IHN0cmluZykgPT4gcy5sZW5ndGg7XG5cbiAgY29uc3QganVzdEFTdHJpbmcgPSBNYXliZS5qdXN0KCdzdHJpbmcnKTtcbiAgY29uc3QganVzdFRoZVN0cmluZ0xlbmd0aCA9IG1hcChsZW5ndGgsIGp1c3RBU3RyaW5nKTtcbiAgY29uc29sZS5sb2coanVzdFRoZVN0cmluZ0xlbmd0aC50b1N0cmluZygpKTsgLy8gSnVzdCg2KVxuXG4gIGNvbnN0IG5vdEFTdHJpbmcgPSBNYXliZS5ub3RoaW5nPHN0cmluZz4oKTtcbiAgY29uc3Qgbm90QVN0cmluZ0xlbmd0aCA9IG1hcChsZW5ndGgsIG5vdEFTdHJpbmcpO1xuICBjb25zb2xlLmxvZyhub3RBU3RyaW5nTGVuZ3RoLnRvU3RyaW5nKCkpOyAvLyBcIk5vdGhpbmdcIlxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIG1hcEZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0aGUgdmFsdWUgdG8gaWYgYE1heWJlYCBpcyBgSnVzdGAuXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBtYXAgb3Zlci5cbiAgQHJldHVybnMgICAgIEEgbmV3IGBNYXliZWAgd2l0aCB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBtYXBGbmAgdG8gdGhlIHZhbHVlXG4gICAgICAgICAgICAgICBpbiBhIGBKdXN0YCwgb3IgYE5vdGhpbmdgIGlmIGBtYXliZWAgaXMgYE5vdGhpbmdgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+KG1hcEZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+O1xuZXhwb3J0IGZ1bmN0aW9uIG1hcDxULCBVPihtYXBGbjogKHQ6IFQpID0+IFUsIG1heWJlOiBNYXliZTxUPik6IE1heWJlPFU+O1xuZXhwb3J0IGZ1bmN0aW9uIG1hcDxULCBVPihcbiAgbWFwRm46ICh0OiBUKSA9PiBVLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBNYXliZTxVPiB8ICgobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxVPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBqdXN0KG1hcEZuKG0udmFsdWUpKSA6IG5vdGhpbmc8VT4oKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqXG4gIE1hcCBvdmVyIGEgYE1heWJlYCBpbnN0YW5jZSBhbmQgZ2V0IG91dCB0aGUgdmFsdWUgaWYgYG1heWJlYCBpcyBhIGBKdXN0YCwgb3JcbiAgcmV0dXJuIGEgZGVmYXVsdCB2YWx1ZSBpZiBgbWF5YmVgIGlzIGEgYE5vdGhpbmdgLlxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBjb25zdCBsZW5ndGggPSAoczogc3RyaW5nKSA9PiBzLmxlbmd0aDtcblxuICBjb25zdCBqdXN0QVN0cmluZyA9IE1heWJlLmp1c3QoJ3N0cmluZycpO1xuICBjb25zdCB0aGVTdHJpbmdMZW5ndGggPSBtYXBPcigwLCBsZW5ndGgsIGp1c3RBU3RyaW5nKTtcbiAgY29uc29sZS5sb2codGhlU3RyaW5nTGVuZ3RoKTsgLy8gNlxuXG4gIGNvbnN0IG5vdEFTdHJpbmcgPSBNYXliZS5ub3RoaW5nPHN0cmluZz4oKTtcbiAgY29uc3Qgbm90QVN0cmluZ0xlbmd0aCA9IG1hcE9yKDAsIGxlbmd0aCwgbm90QVN0cmluZylcbiAgY29uc29sZS5sb2cobm90QVN0cmluZ0xlbmd0aCk7IC8vIDBcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAdHlwZXBhcmFtIFUgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUgb2YgdGhlIHJldHVybmVkIGBNYXliZWAuXG4gIEBwYXJhbSBvclUgICBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgYG1heWJlYCBpcyBgTm90aGluZ2BcbiAgQHBhcmFtIG1hcEZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0aGUgdmFsdWUgdG8gaWYgYE1heWJlYCBpcyBgSnVzdGBcbiAgQHBhcmFtIG1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIG1hcCBvdmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT3I8VCwgVT4ob3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUsIG1heWJlOiBNYXliZTxUPik6IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3I8VCwgVT4ob3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9yPFQsIFU+KG9yVTogVSk6IChtYXBGbjogKHQ6IFQpID0+IFUpID0+IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3I8VCwgVT4oXG4gIG9yVTogVSxcbiAgbWFwRm4/OiAodDogVCkgPT4gVSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogVSB8ICgobWF5YmU6IE1heWJlPFQ+KSA9PiBVKSB8ICgobWFwRm46ICh0OiBUKSA9PiBVKSA9PiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVKSB7XG4gIGZ1bmN0aW9uIGZ1bGxPcChmbjogKHQ6IFQpID0+IFUsIG06IE1heWJlPFQ+KSB7XG4gICAgcmV0dXJuIG0uaXNKdXN0KCkgPyBmbihtLnZhbHVlKSA6IG9yVTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVO1xuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVLCBjdXJyaWVkTWF5YmU6IE1heWJlPFQ+KTogVTtcbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSwgY3VycmllZE1heWJlPzogTWF5YmU8VD4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgICByZXR1cm4gY3VycmllZE1heWJlICE9PSB1bmRlZmluZWRcbiAgICAgID8gZnVsbE9wKGZuLCBjdXJyaWVkTWF5YmUpXG4gICAgICA6IChleHRyYUN1cnJpZWRNYXliZTogTWF5YmU8VD4pID0+IGZ1bGxPcChmbiwgZXh0cmFDdXJyaWVkTWF5YmUpO1xuICB9XG5cbiAgcmV0dXJuIG1hcEZuID09PSB1bmRlZmluZWRcbiAgICA/IHBhcnRpYWxPcFxuICAgIDogbWF5YmUgPT09IHVuZGVmaW5lZCA/IHBhcnRpYWxPcChtYXBGbikgOiBwYXJ0aWFsT3AobWFwRm4sIG1heWJlKTtcbn1cblxuLyoqXG4gIE1hcCBvdmVyIGEgYE1heWJlYCBpbnN0YW5jZSBhbmQgZ2V0IG91dCB0aGUgdmFsdWUgaWYgYG1heWJlYCBpcyBhIGBKdXN0YCxcbiAgb3IgdXNlIGEgZnVuY3Rpb24gdG8gY29uc3RydWN0IGEgZGVmYXVsdCB2YWx1ZSBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYC5cblxuICAjIyMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgY29uc3QgbGVuZ3RoID0gKHM6IHN0cmluZykgPT4gcy5sZW5ndGg7XG4gIGNvbnN0IGdldERlZmF1bHQgPSAoKSA9PiAwO1xuXG4gIGNvbnN0IGp1c3RBU3RyaW5nID0gTWF5YmUuanVzdCgnc3RyaW5nJyk7XG4gIGNvbnN0IHRoZVN0cmluZ0xlbmd0aCA9IG1hcE9yRWxzZShnZXREZWZhdWx0LCBsZW5ndGgsIGp1c3RBU3RyaW5nKTtcbiAgY29uc29sZS5sb2codGhlU3RyaW5nTGVuZ3RoKTsgLy8gNlxuXG4gIGNvbnN0IG5vdEFTdHJpbmcgPSBNYXliZS5ub3RoaW5nPHN0cmluZz4oKTtcbiAgY29uc3Qgbm90QVN0cmluZ0xlbmd0aCA9IG1hcE9yRWxzZShnZXREZWZhdWx0LCBsZW5ndGgsIG5vdEFTdHJpbmcpXG4gIGNvbnNvbGUubG9nKG5vdEFTdHJpbmdMZW5ndGgpOyAvLyAwXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBVICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlIG9mIHRoZSByZXR1cm5lZCBgTWF5YmVgLlxuICBAcGFyYW0gb3JFbHNlRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGlmIGBtYXliZWAgaXMgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWFwRm4gICAgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB3cmFwcGVkIHZhbHVlIGlmIGBtYXliZWAgaXMgYEp1c3RgXG4gIEBwYXJhbSBtYXliZSAgICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBtYXAgb3Zlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9yRWxzZTxULCBVPihvckVsc2VGbjogKCkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVLCBtYXliZTogTWF5YmU8VD4pOiBVO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9yRWxzZTxULCBVPihvckVsc2VGbjogKCkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4ob3JFbHNlRm46ICgpID0+IFUpOiAobWFwRm46ICh0OiBUKSA9PiBVKSA9PiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9yRWxzZTxULCBVPihcbiAgb3JFbHNlRm46ICgpID0+IFUsXG4gIG1hcEZuPzogKHQ6IFQpID0+IFUsXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IFUgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVSkgfCAoKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKG1heWJlOiBNYXliZTxUPikgPT4gVSkge1xuICBmdW5jdGlvbiBmdWxsT3AoZm46ICh0OiBUKSA9PiBVLCBtOiBNYXliZTxUPikge1xuICAgIHJldHVybiBtLmlzSnVzdCgpID8gZm4obS52YWx1ZSkgOiBvckVsc2VGbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUsIGN1cnJpZWRNYXliZTogTWF5YmU8VD4pOiBVO1xuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVLCBjdXJyaWVkTWF5YmU/OiBNYXliZTxUPik6IFUgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVSkge1xuICAgIHJldHVybiBjdXJyaWVkTWF5YmUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBmdWxsT3AoZm4sIGN1cnJpZWRNYXliZSlcbiAgICAgIDogKGV4dHJhQ3VycmllZE1heWJlOiBNYXliZTxUPikgPT4gZnVsbE9wKGZuLCBleHRyYUN1cnJpZWRNYXliZSk7XG4gIH1cblxuICBpZiAobWFwRm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwYXJ0aWFsT3A7XG4gIH0gZWxzZSBpZiAobWF5YmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwYXJ0aWFsT3AobWFwRm4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJ0aWFsT3AobWFwRm4sIG1heWJlKTtcbiAgfVxufVxuXG4vKipcbiAgWW91IGNhbiB0aGluayBvZiB0aGlzIGxpa2UgYSBzaG9ydC1jaXJjdWl0aW5nIGxvZ2ljYWwgXCJhbmRcIiBvcGVyYXRpb24gb24gYVxuICBgTWF5YmVgIHR5cGUuIElmIGBtYXliZWAgaXMgYEp1c3RgLCB0aGVuIHRoZSByZXN1bHQgaXMgdGhlIGBhbmRNYXliZWAuIElmXG4gIGBtYXliZWAgaXMgYE5vdGhpbmdgLCB0aGUgcmVzdWx0IGlzIGBOb3RoaW5nYC5cblxuICBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGFub3RoZXIgYE1heWJlYCB2YWx1ZSB5b3Ugd2FudCB0byBwcm92aWRlIGlmIGFuZFxuICAqb25seSBpZiogeW91IGhhdmUgYSBgSnVzdGAg4oCTIHRoYXQgaXMsIHdoZW4geW91IG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgaWYgeW91XG4gIGBOb3RoaW5nYCwgd2hhdGV2ZXIgZWxzZSB5b3UncmUgaGFuZGluZyBhIGBNYXliZWAgdG8gKmFsc28qIGdldHMgYSBgTm90aGluZ2AuXG5cbiAgTm90aWNlIHRoYXQsIHVubGlrZSBpbiBbYG1hcGBdKCNtYXApIG9yIGl0cyB2YXJpYW50cywgdGhlIG9yaWdpbmFsIGBtYXliZWAgaXNcbiAgbm90IGludm9sdmVkIGluIGNvbnN0cnVjdGluZyB0aGUgbmV3IGBNYXliZWAuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGNvbnN0IGp1c3RBID0gTWF5YmUuanVzdCgnQScpO1xuICBjb25zdCBqdXN0QiA9IE1heWJlLmp1c3QoJ0InKTtcbiAgY29uc3Qgbm90aGluZzogTWF5YmU8bnVtYmVyPiA9IG5vdGhpbmcoKTtcblxuICBjb25zb2xlLmxvZyhNYXliZS5hbmQoanVzdEIsIGp1c3RBKS50b1N0cmluZygpKTsgIC8vIEp1c3QoQilcbiAgY29uc29sZS5sb2coTWF5YmUuYW5kKGp1c3RCLCBub3RoaW5nKS50b1N0cmluZygpKTsgIC8vIE5vdGhpbmdcbiAgY29uc29sZS5sb2coTWF5YmUuYW5kKG5vdGhpbmcsIGp1c3RBKS50b1N0cmluZygpKTsgIC8vIE5vdGhpbmdcbiAgY29uc29sZS5sb2coTWF5YmUuYW5kKG5vdGhpbmcsIG5vdGhpbmcpLnRvU3RyaW5nKCkpOyAgLy8gTm90aGluZ1xuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgVGhlIHR5cGUgb2YgdGhlIGluaXRpYWwgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBVICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlIG9mIHRoZSByZXR1cm5lZCBgTWF5YmVgLlxuICBAcGFyYW0gYW5kTWF5YmUgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gcmV0dXJuIGlmIGBtYXliZWAgaXMgYEp1c3RgXG4gIEBwYXJhbSBtYXliZSAgICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjaGVjay5cbiAgQHJldHVybiAgICAgICAgIGBOb3RoaW5nYCBpZiB0aGUgb3JpZ2luYWwgYG1heWJlYCBpcyBgTm90aGluZ2AsIG9yIGBhbmRNYXliZWBcbiAgICAgICAgICAgICAgICAgIGlmIHRoZSBvcmlnaW5hbCBgbWF5YmVgIGlzIGBKdXN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuZDxULCBVPihhbmRNYXliZTogTWF5YmU8VT4sIG1heWJlOiBNYXliZTxUPik6IE1heWJlPFU+O1xuZXhwb3J0IGZ1bmN0aW9uIGFuZDxULCBVPihhbmRNYXliZTogTWF5YmU8VT4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmQ8VCwgVT4oXG4gIGFuZE1heWJlOiBNYXliZTxVPixcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogTWF5YmU8VT4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gYW5kTWF5YmUgOiBub3RoaW5nPFU+KCkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBtYXliZSk7XG59XG5cbi8qKlxuICBBcHBseSBhIGZ1bmN0aW9uIHRvIHRoZSB3cmFwcGVkIHZhbHVlIGlmIGBKdXN0YCBhbmQgcmV0dXJuIGEgbmV3IGBKdXN0YFxuICBjb250YWluaW5nIHRoZSByZXN1bHRpbmcgdmFsdWU7IG9yIHJldHVybiBgTm90aGluZ2AgaWYgYE5vdGhpbmdgLlxuXG4gIFRoaXMgZGlmZmVycyBmcm9tIGBtYXBgIGluIHRoYXQgYHRoZW5GbmAgcmV0dXJucyBhbm90aGVyIGBNYXliZWAuIFlvdSBjYW4gdXNlXG4gIGBhbmRUaGVuYCB0byBjb21iaW5lIHR3byBmdW5jdGlvbnMgd2hpY2ggKmJvdGgqIGNyZWF0ZSBhIGBNYXliZWAgZnJvbSBhblxuICB1bndyYXBwZWQgdHlwZS5cblxuICBZb3UgbWF5IGZpbmQgdGhlIGAudGhlbmAgbWV0aG9kIG9uIGFuIEVTNiBgUHJvbWlzZWAgaGVscGZ1bCBmb3IgYjpcbiAgaWYgeW91IGhhdmUgYSBgUHJvbWlzZWAsIHlvdSBjYW4gcGFzcyBpdHMgYHRoZW5gIG1ldGhvZCBhIGNhbGxiYWNrIHdoaWNoXG4gIHJldHVybnMgYW5vdGhlciBgUHJvbWlzZWAsIGFuZCB0aGUgcmVzdWx0IHdpbGwgbm90IGJlIGEgKm5lc3RlZCogcHJvbWlzZSwgYnV0XG4gIGEgc2luZ2xlIGBQcm9taXNlYC4gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCBgUHJvbWlzZSN0aGVuYCB1bndyYXBzICphbGwqXG4gIGxheWVycyB0byBvbmx5IGV2ZXIgcmV0dXJuIGEgc2luZ2xlIGBQcm9taXNlYCB2YWx1ZSwgd2hlcmVhcyBgTWF5YmUuYW5kVGhlbmBcbiAgd2lsbCBub3QgdW53cmFwIG5lc3RlZCBgTWF5YmVgcy5cblxuICBUaGlzIGlzIGFsc28gY29tbW9ubHkga25vd24gYXMgKGFuZCB0aGVyZWZvcmUgYWxpYXNlZCBhcykgW2BmbGF0TWFwYF0gb3JcbiAgW2BjaGFpbmBdLiBJdCBpcyBzb21ldGltZXMgYWxzbyBrbm93biBhcyBgYmluZGAsIGJ1dCAqbm90KiBhbGlhc2VkIGFzIHN1Y2hcbiAgYmVjYXVzZSBbYGJpbmRgIGFscmVhZHkgbWVhbnMgc29tZXRoaW5nIGluIEphdmFTY3JpcHRdW2JpbmRdLlxuXG4gIFtgZmxhdE1hcGBdOiAjZmxhdG1hcFxuICBbYGNoYWluYF06ICNjaGFpblxuICBbYmluZF06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmRcblxuICAjIyMjIEV4YW1wbGVcblxuICAoVGhpcyBpcyBhIHNvbWV3aGF0IGNvbnRyaXZlZCBleGFtcGxlLCBidXQgaXQgc2VydmVzIHRvIHNob3cgdGhlIHdheSB0aGVcbiAgZnVuY3Rpb24gYmVoYXZlcy4pXG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgLy8gc3RyaW5nIC0+IE1heWJlPG51bWJlcj5cbiAgY29uc3QgdG9NYXliZUxlbmd0aCA9IChzOiBzdHJpbmcpOiBNYXliZTxudW1iZXI+ID0+IE1heWJlLm9mKHMubGVuZ3RoKTtcblxuICAvLyBNYXliZTxzdHJpbmc+XG4gIGNvbnN0IGFNYXliZVN0cmluZyA9IE1heWJlLm9mKCdIZWxsbywgdGhlcmUhJyk7XG5cbiAgLy8gTWF5YmU8bnVtYmVyPlxuICBjb25zdCByZXN1bHRpbmdMZW5ndGggPSBNYXliZS5hbmRUaGVuKHRvTWF5YmVMZW5ndGgsIGFNYXliZVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKE1heWJlLnRvU3RyaW5nKHJlc3VsdGluZ0xlbmd0aCkpOyAvLyAxM1xuICBgYGBcblxuICBOb3RlIHRoYXQgdGhlIHJlc3VsdCBpcyBub3QgYChKdXN0KDEzKSlgLCBidXQgYDEzYCFcblxuICBAdHlwZXBhcmFtIFQgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAdHlwZXBhcmFtIFQgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlIGluIHRoZSByZXN1bHRpbmcgYE1heWJlYC5cbiAgQHBhcmFtIHRoZW5GbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHdyYXBwZWQgYFRgIGlmIGBtYXliZWAgaXMgYEp1c3RgLlxuICBAcGFyYW0gbWF5YmUgIFRoZSBgTWF5YmVgIHRvIGV2YWx1YXRlIGFuZCBwb3NzaWJseSBhcHBseSBhIGZ1bmN0aW9uIHRvIHRoZVxuICAgICAgICAgICAgICAgIGNvbnRlbnRzIG9mLlxuICBAcmV0dXJucyAgICAgIFRoZSByZXN1bHQgb2YgdGhlIGB0aGVuRm5gIChhIG5ldyBgTWF5YmVgKSBpZiBgbWF5YmVgIGlzIGFcbiAgICAgICAgICAgICAgICBgSnVzdGAsIG90aGVyd2lzZSBgTm90aGluZ2AgaWYgYG1heWJlYCBpcyBhIGBOb3RoaW5nYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuZFRoZW48VCwgVT4odGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4sIG1heWJlOiBNYXliZTxUPik6IE1heWJlPFU+O1xuZXhwb3J0IGZ1bmN0aW9uIGFuZFRoZW48VCwgVT4odGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmRUaGVuPFQsIFU+KFxuICB0aGVuRm46ICh0OiBUKSA9PiBNYXliZTxVPixcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogTWF5YmU8VT4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gdGhlbkZuKG0udmFsdWUpIDogbm90aGluZzxVPigpKTtcbiAgcmV0dXJuIG1heWJlICE9PSB1bmRlZmluZWQgPyBvcChtYXliZSkgOiBvcDtcbn1cblxuLyoqIEFsaWFzIGZvciBbYGFuZFRoZW5gXSgjYW5kdGhlbikuICovXG5leHBvcnQgY29uc3QgY2hhaW4gPSBhbmRUaGVuO1xuXG4vKiogQWxpYXMgZm9yIFtgYW5kVGhlbmBdKCNhbmR0aGVuKS4gKi9cbmV4cG9ydCBjb25zdCBmbGF0TWFwID0gYW5kVGhlbjtcblxuLyoqXG4gIFByb3ZpZGUgYSBmYWxsYmFjayBmb3IgYSBnaXZlbiBgTWF5YmVgLiBCZWhhdmVzIGxpa2UgYSBsb2dpY2FsIGBvcmA6IGlmIHRoZVxuICBgbWF5YmVgIHZhbHVlIGlzIGEgYEp1c3RgLCByZXR1cm5zIHRoYXQgYG1heWJlYDsgb3RoZXJ3aXNlLCByZXR1cm5zIHRoZVxuICBgZGVmYXVsdE1heWJlYCB2YWx1ZS5cblxuICBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHNvbWV0aGluZyB3aGljaCB0YWtlcyBhXG4gIGBNYXliZWAgYWx3YXlzIGVuZHMgdXAgZ2V0dGluZyBhIGBKdXN0YCB2YXJpYW50LCBieSBzdXBwbHlpbmcgYSBkZWZhdWx0IHZhbHVlXG4gIGZvciB0aGUgY2FzZSB0aGF0IHlvdSBjdXJyZW50bHkgaGF2ZSBhIG5vdGhpbmcuXG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtdXRpbHMvbWF5YmUnO1xuXG4gIGNvbnN0IGp1c3RBID0gTWF5YmUuanVzdChcImFcIik7XG4gIGNvbnN0IGp1c3RCID0gTWF5YmUuanVzdChcImJcIik7XG4gIGNvbnN0IGFOb3RoaW5nOiBNYXliZTxzdHJpbmc+ID0gbm90aGluZygpO1xuXG4gIGNvbnNvbGUubG9nKE1heWJlLm9yKGp1c3RCLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBKdXN0KEEpXG4gIGNvbnNvbGUubG9nKE1heWJlLm9yKGFOb3RoaW5nLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBKdXN0KEEpXG4gIGNvbnNvbGUubG9nKE1heWJlLm9yKGp1c3RCLCBhTm90aGluZykudG9TdHJpbmcoKSk7ICAvLyBKdXN0KEIpXG4gIGNvbnNvbGUubG9nKE1heWJlLm9yKGFOb3RoaW5nLCBhTm90aGluZykudG9TdHJpbmcoKSk7ICAvLyBOb3RoaW5nXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCAgICAgICAgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEBwYXJhbSBkZWZhdWx0TWF5YmUgVGhlIGBNYXliZWAgdG8gdXNlIGlmIGBtYXliZWAgaXMgYSBgTm90aGluZ2AuXG4gIEBwYXJhbSBtYXliZSAgICAgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gZXZhbHVhdGUuXG4gIEByZXR1cm5zICAgICAgICAgICAgYG1heWJlYCBpZiBpdCBpcyBhIGBKdXN0YCwgb3RoZXJ3aXNlIGBkZWZhdWx0TWF5YmVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3I8VD4oZGVmYXVsdE1heWJlOiBNYXliZTxUPiwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VD47XG5leHBvcnQgZnVuY3Rpb24gb3I8VD4oZGVmYXVsdE1heWJlOiBNYXliZTxUPik6IChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG9yPFQ+KFxuICBkZWZhdWx0TWF5YmU6IE1heWJlPFQ+LFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBNYXliZTxUPiB8ICgobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxUPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBtIDogZGVmYXVsdE1heWJlKTtcbiAgcmV0dXJuIG1heWJlICE9PSB1bmRlZmluZWQgPyBvcChtYXliZSkgOiBvcDtcbn1cblxuLyoqXG4gIExpa2UgYG9yYCwgYnV0IHVzaW5nIGEgZnVuY3Rpb24gdG8gY29uc3RydWN0IHRoZSBhbHRlcm5hdGl2ZSBgTWF5YmVgLlxuXG4gIFNvbWV0aW1lcyB5b3UgbmVlZCB0byBwZXJmb3JtIGFuIG9wZXJhdGlvbiB1c2luZyBvdGhlciBkYXRhIGluIHRoZVxuICBlbnZpcm9ubWVudCB0byBjb25zdHJ1Y3QgdGhlIGZhbGxiYWNrIHZhbHVlLiBJbiB0aGVzZSBzaXR1YXRpb25zLCB5b3UgY2FuXG4gIHBhc3MgYSBmdW5jdGlvbiAod2hpY2ggbWF5IGJlIGEgY2xvc3VyZSkgYXMgdGhlIGBlbHNlRm5gIHRvIGdlbmVyYXRlIHRoZVxuICBmYWxsYmFjayBgTWF5YmU8VD5gLlxuXG4gIFVzZWZ1bCBmb3IgdHJhbnNmb3JtaW5nIGVtcHR5IHNjZW5hcmlvcyBiYXNlZCBvbiB2YWx1ZXMgaW4gY29udGV4dC5cblxuICBAdHlwZXBhcmFtIFQgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gZWxzZUZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYFxuICBAcGFyYW0gbWF5YmUgIFRoZSBgbWF5YmVgIHRvIHVzZSBpZiBpdCBpcyBgSnVzdGAuXG4gIEByZXR1cm5zICAgICAgVGhlIGBtYXliZWAgaWYgaXQgaXMgYEp1c3RgLCBvciB0aGUgYE1heWJlYCByZXR1cm5lZCBieVxuICAgICAgICAgICAgICAgIGBlbHNlRm5gIGlmIHRoZSBgbWF5YmVgIGlzIGBOb3RoaW5nYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yRWxzZTxUPihlbHNlRm46ICgpID0+IE1heWJlPFQ+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VD4oZWxzZUZuOiAoKSA9PiBNYXliZTxUPik6IChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG9yRWxzZTxUPihcbiAgZWxzZUZuOiAoKSA9PiBNYXliZTxUPixcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogTWF5YmU8VD4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VD4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gbSA6IGVsc2VGbigpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgR2V0IHRoZSB2YWx1ZSBvdXQgb2YgdGhlIGBNYXliZWAuXG5cbiAgUmV0dXJucyB0aGUgY29udGVudCBvZiBhIGBKdXN0YCwgYnV0ICoqdGhyb3dzIGlmIHRoZSBgTWF5YmVgIGlzIGBOb3RoaW5nYCoqLlxuICBQcmVmZXIgdG8gdXNlIFtgdW53cmFwT3JgXSgjdW53cmFwb3IpIG9yIFtgdW53cmFwT3JFbHNlYF0oI3Vud3JhcG9yZWxzZSkuXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gbWF5YmUgVGhlIHZhbHVlIHRvIHVud3JhcFxuICBAcmV0dXJucyAgICAgVGhlIHVud3JhcHBlZCB2YWx1ZSBpZiB0aGUgYE1heWJlYCBpbnN0YW5jZSBpcyBgSnVzdGAuXG4gIEB0aHJvd3MgICAgICBJZiB0aGUgYG1heWJlYCBpcyBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVseVVud3JhcDxUPihtYXliZTogTWF5YmU8VD4pOiBUIHtcbiAgcmV0dXJuIG1heWJlLnVuc2FmZWx5VW53cmFwKCk7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2B1bnNhZmVseVVud3JhcGBdKCN1bnNhZmVseXVud3JhcCkgKi9cbmV4cG9ydCBjb25zdCB1bnNhZmVseUdldCA9IHVuc2FmZWx5VW53cmFwO1xuXG4vKiogQWxpYXMgZm9yIFtgdW5zYWZlbHlVbndyYXBgXSgjdW5zYWZlbHl1bndyYXApICovXG5leHBvcnQgY29uc3QgdW5zYWZlR2V0ID0gdW5zYWZlbHlVbndyYXA7XG5cbi8qKlxuICBTYWZlbHkgZ2V0IHRoZSB2YWx1ZSBvdXQgb2YgYSBgTWF5YmVgLlxuXG4gIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgYSBgSnVzdGAgb3IgYGRlZmF1bHRWYWx1ZWAgaWYgYE5vdGhpbmdgLiBUaGlzIGlzIHRoZVxuICByZWNvbW1lbmRlZCB3YXkgdG8gZ2V0IGEgdmFsdWUgb3V0IG9mIGEgYE1heWJlYCBtb3N0IG9mIHRoZSB0aW1lLlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGNvbnN0IG5vdEFTdHJpbmcgPSBNYXliZS5ub3RoaW5nPHN0cmluZz4oKTtcbiAgY29uc3QgaXNBU3RyaW5nID0gTWF5YmUuanVzdCgnbG9vayBtYSEgc29tZSBjaGFyYWN0ZXJzIScpO1xuXG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yKCc8ZW1wdHk+Jywgbm90QVN0cmluZykpOyAgLy8gXCI8ZW1wdHk+XCJcbiAgY29uc29sZS5sb2coTWF5YmUudW53cmFwT3IoJzxlbXB0eT4nLCBpc0FTdHJpbmcpKTsgIC8vIFwibG9vayBtYSEgc29tZSBjaGFyYWN0ZXJzIVwiXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCAgICAgICAgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgbWF5YmVgIGlzIGEgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWF5YmUgICAgICAgIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIHVud3JhcCBpZiBpdCBpcyBhIGBKdXN0YC5cbiAgQHJldHVybnMgICAgICAgICAgICBUaGUgY29udGVudCBvZiBgbWF5YmVgIGlmIGl0IGlzIGEgYEp1c3RgLCBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICAgICAgICBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yPFQ+KGRlZmF1bHRWYWx1ZTogVCwgbWF5YmU6IE1heWJlPFQ+KTogVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxUPihkZWZhdWx0VmFsdWU6IFQpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBUO1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yPFQ+KGRlZmF1bHRWYWx1ZTogVCwgbWF5YmU/OiBNYXliZTxUPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBtLnZhbHVlIDogZGVmYXVsdFZhbHVlKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgdW53cmFwT3JgXSgjdW53cmFwb3IpICovXG5leHBvcnQgY29uc3QgZ2V0T3IgPSB1bndyYXBPcjtcblxuLyoqXG4gIFNhZmVseSBnZXQgdGhlIHZhbHVlIG91dCBvZiBhIFtgTWF5YmVgXSgjbWF5YmUpIGJ5IHJldHVybmluZyB0aGUgd3JhcHBlZFxuICB2YWx1ZSBpZiBpdCBpcyBgSnVzdGAsIG9yIGJ5IGFwcGx5aW5nIGBvckVsc2VGbmAgaWYgaXQgaXMgYE5vdGhpbmdgLlxuXG4gIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gKmdlbmVyYXRlKiBhIHZhbHVlIChlLmcuIGJ5IHVzaW5nIGN1cnJlbnRcbiAgdmFsdWVzIGluIHRoZSBlbnZpcm9ubWVudCDigJMgd2hldGhlciBwcmVsb2FkZWQgb3IgYnkgbG9jYWwgY2xvc3VyZSkgaW5zdGVhZCBvZlxuICBoYXZpbmcgYSBzaW5nbGUgZGVmYXVsdCB2YWx1ZSBhdmFpbGFibGUgKGFzIGluIFtgdW53cmFwT3JgXSgjdW53cmFwb3IpKS5cblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICAvLyBZb3UgY2FuIGltYWdpbmUgdGhhdCBzb21lT3RoZXJWYWx1ZSBtaWdodCBiZSBkeW5hbWljLlxuICBjb25zdCBzb21lT3RoZXJWYWx1ZSA9IDk5O1xuICBjb25zdCBoYW5kbGVOb3RoaW5nID0gKCkgPT4gc29tZU90aGVyVmFsdWU7XG5cbiAgY29uc3QgYUp1c3QgPSBNYXliZS5qdXN0KDQyKTtcbiAgY29uc29sZS5sb2coTWF5YmUudW53cmFwT3JFbHNlKGhhbmRsZU5vdGhpbmcsIGFKdXN0KSk7ICAvLyA0MlxuXG4gIGNvbnN0IGFOb3RoaW5nID0gbm90aGluZzxudW1iZXI+KCk7XG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yRWxzZShoYW5kbGVOb3RoaW5nLCBhTm90aGluZykpOyAvLyA5OVxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgIFRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gb3JFbHNlRm4gQSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIGEgdmFsaWQgdmFsdWUgaWYgYG1heWJlYCBpcyBhXG4gICAgICAgICAgICAgICAgICBgTm90aGluZ2AuXG4gIEBwYXJhbSBtYXliZSAgICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byB1bndyYXAgaWYgaXQgaXMgYSBgSnVzdGBcbiAgQHJldHVybnMgICAgICAgIEVpdGhlciB0aGUgY29udGVudCBvZiBgbWF5YmVgIG9yIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tXG4gICAgICAgICAgICAgICAgICBgb3JFbHNlRm5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3JFbHNlPFQ+KG9yRWxzZUZuOiAoKSA9PiBULCBtYXliZTogTWF5YmU8VD4pOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxUPihvckVsc2VGbjogKCkgPT4gVCk6IChtYXliZTogTWF5YmU8VD4pID0+IFQ7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3JFbHNlPFQ+KG9yRWxzZUZuOiAoKSA9PiBULCBtYXliZT86IE1heWJlPFQ+KTogVCB8ICgobWF5YmU6IE1heWJlPFQ+KSA9PiBUKSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IG0udmFsdWUgOiBvckVsc2VGbigpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgdW53cmFwT3JFbHNlYF0oI3Vud3JhcG9yZWxzZSkgKi9cbmV4cG9ydCBjb25zdCBnZXRPckVsc2UgPSB1bndyYXBPckVsc2U7XG5cbi8qKlxuICBUcmFuc2Zvcm0gdGhlIFtgTWF5YmVgXSgjbWF5YmUpIGludG8gYVxuICBbYFJlc3VsdGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNyZXN1bHQpLCB1c2luZyB0aGUgd3JhcHBlZCB2YWx1ZSBhcyB0aGVcbiAgYE9rYCB2YWx1ZSBpZiBgSnVzdGA7IG90aGVyd2lzZSB1c2luZyB0aGUgc3VwcGxpZWQgYGVycm9yYCB2YWx1ZSBmb3IgYEVycmAuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBFICBUaGUgZXJyb3IgdHlwZSB0byBpbiB0aGUgYFJlc3VsdGAuXG4gIEBwYXJhbSBlcnJvciBUaGUgZXJyb3IgdmFsdWUgdG8gdXNlIGlmIHRoZSBgTWF5YmVgIGlzIGBOb3RoaW5nYC5cbiAgQHBhcmFtIG1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGNvbnZlcnQuXG4gIEByZXR1cm5zICAgICBBIGBSZXN1bHRgIGNvbnRhaW5pbmcgdGhlIHZhbHVlIHdyYXBwZWQgaW4gYG1heWJlYCBpbiBhbiBgT2tgLFxuICAgICAgICAgICAgICAgb3IgYGVycm9yYCBpbiBhbiBgRXJyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVycjxULCBFPihlcnJvcjogRSwgbWF5YmU6IE1heWJlPFQ+KTogUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVycjxULCBFPihlcnJvcjogRSk6IChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPjtcbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFcnI8VCwgRT4oXG4gIGVycm9yOiBFLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBSZXN1bHQ8VCwgRT4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gUmVzdWx0PFQsIEU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IG9rPFQsIEU+KG0udmFsdWUpIDogZXJyPFQsIEU+KGVycm9yKSk7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkID8gb3AobWF5YmUpIDogb3A7XG59XG5cbi8qKlxuICBUcmFuc2Zvcm0gdGhlIFtgTWF5YmVgXSgjbWF5YmUpIGludG8gYVxuICBbYFJlc3VsdGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNyZXN1bHQpLCB1c2luZyB0aGUgd3JhcHBlZCB2YWx1ZSBhcyB0aGVcbiAgYE9rYCB2YWx1ZSBpZiBgSnVzdGA7IG90aGVyd2lzZSB1c2luZyBgZWxzZUZuYCB0byBnZW5lcmF0ZSBgRXJyYC5cblxuICBAdHlwZXBhcmFtIFQgIFRoZSB3cmFwcGVkIHZhbHVlLlxuICBAdHlwZXBhcmFtIEUgIFRoZSBlcnJvciB0eXBlIHRvIGluIHRoZSBgUmVzdWx0YC5cbiAgQHBhcmFtIGVsc2VGbiBUaGUgZnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGVzIGFuIGVycm9yIG9mIHR5cGUgYEVgLlxuICBAcGFyYW0gbWF5YmUgIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGNvbnZlcnQuXG4gIEByZXR1cm5zICAgICBBIGBSZXN1bHRgIGNvbnRhaW5pbmcgdGhlIHZhbHVlIHdyYXBwZWQgaW4gYG1heWJlYCBpbiBhbiBgT2tgLFxuICAgICAgICAgICAgICAgb3IgdGhlIHZhbHVlIGdlbmVyYXRlZCBieSBgZWxzZUZuYCBpbiBhbiBgRXJyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVsc2VFcnI8VCwgRT4oZWxzZUZuOiAoKSA9PiBFLCBtYXliZTogTWF5YmU8VD4pOiBSZXN1bHQ8VCwgRT47XG5leHBvcnQgZnVuY3Rpb24gdG9Pa09yRWxzZUVycjxULCBFPihlbHNlRm46ICgpID0+IEUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBSZXN1bHQ8VCwgRT47XG5leHBvcnQgZnVuY3Rpb24gdG9Pa09yRWxzZUVycjxULCBFPihcbiAgZWxzZUZuOiAoKSA9PiBFLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBSZXN1bHQ8VCwgRT4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gUmVzdWx0PFQsIEU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IG9rPFQsIEU+KG0udmFsdWUpIDogZXJyPFQsIEU+KGVsc2VGbigpKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqXG4gIENvbnN0cnVjdCBhIGBNYXliZTxUPmAgZnJvbSBhIGBSZXN1bHQ8VCwgRT5gLlxuXG4gIElmIHRoZSBgUmVzdWx0YCBpcyBhbiBgT2tgLCB3cmFwIGl0cyB2YWx1ZSBpbiBgSnVzdGAuIElmIHRoZSBgUmVzdWx0YCBpcyBhblxuICBgRXJyYCwgdGhyb3cgYXdheSB0aGUgd3JhcHBlZCBgRWAgYW5kIHRyYW5zZm9ybSB0byBhIGBOb3RoaW5nYC5cblxuICBAdHlwZXBhcmFtIFQgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGEgYFJlc3VsdC5Pa2AgYW5kIGluIHRoZSBgSnVzdGBcbiAgICAgICAgICAgICAgICBvZiB0aGUgcmVzdWx0aW5nIGBNYXliZWAuXG4gIEB0eXBlcGFyYW0gRSAgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHdyYXBwZWQgaW4gYSBgUmVzdWx0LkVycmA7IHRocm93biBhd2F5IGluXG4gICAgICAgICAgICAgICAgdGhlIHJlc3VsdGluZyBgTWF5YmVgLlxuICBAcGFyYW0gcmVzdWx0IFRoZSBgUmVzdWx0YCB0byBjb25zdHJ1Y3QgYSBgTWF5YmVgIGZyb20uXG4gIEByZXR1cm5zICAgICAgYEp1c3RgIGlmIGByZXN1bHRgIHdhcyBgT2tgIG9yIGBOb3RoaW5nYCBpZiBpdCB3YXMgYEVycmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUmVzdWx0PFQ+KHJlc3VsdDogUmVzdWx0PFQsIGFueT4pOiBNYXliZTxUPiB7XG4gIHJldHVybiByZXN1bHQuaXNPaygpID8ganVzdChyZXN1bHQudmFsdWUpIDogbm90aGluZzxUPigpO1xufVxuXG4vKipcbiAgQ3JlYXRlIGEgYFN0cmluZ2AgcmVwcmVzZW50YXRpb24gb2YgYSBgTWF5YmVgIGluc3RhbmNlLlxuXG4gIEEgYEp1c3RgIGluc3RhbmNlIHdpbGwgYmUgcHJpbnRlZCBhcyBgSnVzdCg8cmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlPilgLFxuICB3aGVyZSB0aGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlIGlzIHNpbXBseSB0aGUgdmFsdWUncyBvd24gYHRvU3RyaW5nYFxuICByZXByZXNlbnRhdGlvbi4gRm9yIGV4YW1wbGU6XG5cbiAgfCBjYWxsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG91dHB1dCAgICAgICAgICAgICAgICAgIHxcbiAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgfCBgdG9TdHJpbmcoTWF5YmUub2YoNDIpKWAgICAgICAgICAgICAgICB8IGBKdXN0KDQyKWAgICAgICAgICAgICAgIHxcbiAgfCBgdG9TdHJpbmcoTWF5YmUub2YoWzEsIDIsIDNdKSlgICAgICAgICB8IGBKdXN0KDEsMiwzKWAgICAgICAgICAgIHxcbiAgfCBgdG9TdHJpbmcoTWF5YmUub2YoeyBhbjogJ29iamVjdCcgfSkpYCB8IGBKdXN0KFtvYmplY3QgT2JqZWN0XSlgIHxcbiAgfCBgdG9TdHJpbmcoTWF5YmUubm90aGluZygpKWAgICAgICAgICAgICB8IGBOb3RoaW5nYCAgICAgICAgICAgICAgIHxcblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWU7IGl0cyBvd24gYC50b1N0cmluZ2Agd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICB0byBwcmludCB0aGUgaW50ZXJpb3IgY29udGVudHMgb2YgdGhlIGBKdXN0YCB2YXJpYW50LlxuICBAcGFyYW0gbWF5YmUgVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gIEByZXR1cm5zICAgICBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgTWF5YmVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmc8VD4obWF5YmU6IE1heWJlPFQ+KTogc3RyaW5nIHtcbiAgY29uc3QgYm9keSA9IG1heWJlLmlzSnVzdCgpID8gYCgke21heWJlLnZhbHVlLnRvU3RyaW5nKCl9KWAgOiAnJztcbiAgcmV0dXJuIGAke21heWJlLnZhcmlhbnR9JHtib2R5fWA7XG59XG5cbi8qKiBBIGxpZ2h0d2VpZ2h0IG9iamVjdCBkZWZpbmluZyBob3cgdG8gaGFuZGxlIGVhY2ggdmFyaWFudCBvZiBhIE1heWJlLiAqL1xuZXhwb3J0IHR5cGUgTWF0Y2hlcjxULCBBPiA9IHtcbiAgSnVzdDogKHZhbHVlOiBUKSA9PiBBO1xuICBOb3RoaW5nOiAoKSA9PiBBO1xufTtcblxuLyoqXG4gIFBlcmZvcm1zIHRoZSBzYW1lIGJhc2ljIGZ1bmN0aW9uYWxpdHkgYXMgYGdldE9yRWxzZWAsIGJ1dCBpbnN0ZWFkIG9mIHNpbXBseVxuICB1bndyYXBwaW5nIHRoZSB2YWx1ZSBpZiBpdCBpcyBgSnVzdGAgYW5kIGFwcGx5aW5nIGEgdmFsdWUgdG8gZ2VuZXJhdGUgdGhlIHNhbWVcbiAgZGVmYXVsdCB0eXBlIGlmIGl0IGlzIGBOb3RoaW5nYCwgbGV0cyB5b3Ugc3VwcGx5IGZ1bmN0aW9ucyB3aGljaCBtYXkgdHJhbnNmb3JtXG4gIHRoZSB3cmFwcGVkIHR5cGUgaWYgaXQgaXMgYEp1c3RgIG9yIGdldCBhIGRlZmF1bHQgdmFsdWUgZm9yIGBOb3RoaW5nYC5cblxuICBUaGlzIGlzIGtpbmQgb2YgbGlrZSBhIHBvb3IgbWFuJ3MgdmVyc2lvbiBvZiBwYXR0ZXJuIG1hdGNoaW5nLCB3aGljaFxuICBKYXZhU2NyaXB0IGN1cnJlbnRseSBsYWNrcy5cblxuICBJbnN0ZWFkIG9mIGNvZGUgbGlrZSB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGNvbnN0IGxvZ1ZhbHVlID0gKG1pZ2h0QmVBTnVtYmVyOiBNYXliZTxudW1iZXI+KSA9PiB7XG4gICAgY29uc3QgdmFsdWVUb0xvZyA9IE1heWJlLm1pZ2h0QmVBTnVtYmVyLmlzSnVzdCgpXG4gICAgICA/IE1heWJlLnVuc2FmZWx5VW53cmFwKG1pZ2h0QmVBTnVtYmVyKS50b1N0cmluZygpXG4gICAgICA6ICdOb3RoaW5nIHRvIGxvZy4nO1xuXG4gICAgY29uc29sZS5sb2codmFsdWVUb0xvZyk7XG4gIH07XG4gIGBgYFxuXG4gIC4uLndlIGNhbiB3cml0ZSBjb2RlIGxpa2UgdGhpczpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBsb2dWYWx1ZSA9IChtaWdodEJlQU51bWJlcjogTWF5YmU8bnVtYmVyPikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gTWF5YmUubWF0Y2goXG4gICAgICB7XG4gICAgICAgIEp1c3Q6IG4gPT4gbi50b1N0cmluZygpLFxuICAgICAgICBOb3RoaW5nOiAoKSA9PiAnTm90aGluZyB0byBsb2cuJyxcbiAgICAgIH0sXG4gICAgICBtaWdodEJlQU51bWJlclxuICAgICk7XG5cbiAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gIH07XG4gIGBgYFxuXG4gIFRoaXMgaXMgc2xpZ2h0bHkgbG9uZ2VyIHRvIHdyaXRlLCBidXQgY2xlYXJlcjogdGhlIG1vcmUgY29tcGxleCB0aGUgcmVzdWx0aW5nXG4gIGV4cHJlc3Npb24sIHRoZSBoYWlyZXIgaXQgaXMgdG8gdW5kZXJzdGFuZCB0aGUgdGVybmFyeS4gVGh1cywgdGhpcyBpc1xuICBlc3BlY2lhbGx5IGNvbnZlbmllbnQgZm9yIHRpbWVzIHdoZW4gdGhlcmUgaXMgYSBjb21wbGV4IHJlc3VsdCwgZS5nLiB3aGVuXG4gIHJlbmRlcmluZyBwYXJ0IG9mIGEgUmVhY3QgY29tcG9uZW50IGlubGluZSBpbiBKU1gvVFNYLlxuXG4gIEBwYXJhbSBtYXRjaGVyIEEgbGlnaHR3ZWlnaHQgb2JqZWN0IGRlZmluaW5nIHdoYXQgdG8gZG8gaW4gdGhlIGNhc2Ugb2YgZWFjaFxuICAgICAgICAgICAgICAgICB2YXJpYW50LlxuICBAcGFyYW0gbWF5YmUgICBUaGUgYG1heWJlYCBpbnN0YW5jZSB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPFQsIEE+KG1hdGNoZXI6IE1hdGNoZXI8VCwgQT4sIG1heWJlOiBNYXliZTxUPik6IEE7XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2g8VCwgQT4obWF0Y2hlcjogTWF0Y2hlcjxULCBBPik6IChtOiBNYXliZTxUPikgPT4gQTtcbmV4cG9ydCBmdW5jdGlvbiBtYXRjaDxULCBBPihtYXRjaGVyOiBNYXRjaGVyPFQsIEE+LCBtYXliZT86IE1heWJlPFQ+KTogQSB8ICgobTogTWF5YmU8VD4pID0+IEEpIHtcbiAgcmV0dXJuIG1heWJlICE9PSB1bmRlZmluZWRcbiAgICA/IG1hcE9yRWxzZShtYXRjaGVyLk5vdGhpbmcsIG1hdGNoZXIuSnVzdCwgbWF5YmUpXG4gICAgOiAoY3VycmllZE1heWJlOiBNYXliZTxUPikgPT4gbWFwT3JFbHNlKG1hdGNoZXIuTm90aGluZywgbWF0Y2hlci5KdXN0LCBjdXJyaWVkTWF5YmUpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgbWF0Y2hgXSgjbWF0Y2gpICovXG5leHBvcnQgY29uc3QgY2F0YSA9IG1hdGNoO1xuXG4vKipcbiAgQWxsb3dzIHF1aWNrIHRyaXBsZS1lcXVhbCBlcXVhbGl0eSBjaGVjayBiZXR3ZWVuIHRoZSB2YWx1ZXMgaW5zaWRlIHR3byBgbWF5YmVgc1xuICB3aXRob3V0IGhhdmluZyB0byB1bndyYXAgdGhlbSBmaXJzdC5cblxuICBgYGB0c1xuICBjb25zdCBhID0gTWF5YmUub2YoMyk7XG4gIGNvbnN0IGIgPSBNYXliZS5vZigzKTtcbiAgY29uc3QgYyA9IE1heWJlLm9mKG51bGwpO1xuICBjb25zdCBkID0gTWF5YmUubm90aGluZygpO1xuXG4gIE1heWJlLmVxdWFscyhhLCBiKTsgLy8gdHJ1ZVxuICBNYXliZS5lcXVhbHMoYSwgYyk7IC8vIGZhbHNlXG4gIE1heWJlLmVxdWFscyhjLCBkKTsgLy8gdHJ1ZVxuICBgYGBcblxuICBAcGFyYW0gbWIgQSBgbWF5YmVgIHRvIGNvbXBhcmUgdG8uXG4gIEBwYXJhbSBtYSBBIGBtYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VD4obWI6IE1heWJlPFQ+LCBtYTogTWF5YmU8VD4pOiBib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsczxUPihtYjogTWF5YmU8VD4pOiAobWE6IE1heWJlPFQ+KSA9PiBib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsczxUPihtYjogTWF5YmU8VD4sIG1hPzogTWF5YmU8VD4pOiBib29sZWFuIHwgKChhOiBNYXliZTxUPikgPT4gYm9vbGVhbikge1xuICByZXR1cm4gbWEgIT09IHVuZGVmaW5lZFxuICAgID8gbWEubWF0Y2goe1xuICAgICAgICBKdXN0OiBhVmFsID0+IG1iLmlzSnVzdCgpICYmIG1iLnVuc2FmZWx5VW53cmFwKCkgPT09IGFWYWwsXG4gICAgICAgIE5vdGhpbmc6ICgpID0+IGlzTm90aGluZyhtYiksXG4gICAgICB9KVxuICAgIDogKG1heWJlQTogTWF5YmU8VD4pID0+XG4gICAgICAgIG1heWJlQS5tYXRjaCh7XG4gICAgICAgICAgTm90aGluZzogKCkgPT4gaXNOb3RoaW5nKG1iKSxcbiAgICAgICAgICBKdXN0OiBhVmFsID0+IG1iLmlzSnVzdCgpICYmIG1iLnVuc2FmZWx5VW53cmFwKCkgPT09IGFWYWwsXG4gICAgICAgIH0pO1xufVxuXG4vKipcbiAgQWxsb3dzIHlvdSB0byAqYXBwbHkqICh0aHVzIGBhcGApIGEgdmFsdWUgdG8gYSBmdW5jdGlvbiB3aXRob3V0IGhhdmluZyB0b1xuICB0YWtlIGVpdGhlciBvdXQgb2YgdGhlIGNvbnRleHQgb2YgdGhlaXIgYE1heWJlYHMuIFRoaXMgZG9lcyBtZWFuIHRoYXQgdGhlXG4gIHRyYW5zZm9ybWluZyBmdW5jdGlvbiBpcyBpdHNlbGYgd2l0aGluIGEgYE1heWJlYCwgd2hpY2ggY2FuIGJlIGhhcmQgdG8gZ3Jva1xuICBhdCBmaXJzdCBidXQgbGV0cyB5b3UgZG8gc29tZSB2ZXJ5IGVsZWdhbnQgdGhpbmdzLiBGb3IgZXhhbXBsZSwgYGFwYCBhbGxvd3NcbiAgeW91IHRvIHRoaXM6XG5cbiAgYGBgdHNcbiAgaW1wb3J0IHsganVzdCwgbm90aGluZyB9IGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgY29uc3Qgb25lID0ganVzdCgxKTtcbiAgY29uc3QgZml2ZSA9IGp1c3QoNSk7XG4gIGNvbnN0IG5vbmUgPSBub3RoaW5nKCk7XG5cbiAgY29uc3QgYWRkID0gKGE6IG51bWJlcikgPT4gKGI6IG51bWJlcikgPT4gYSArIGI7XG4gIGNvbnN0IG1heWJlQWRkID0ganVzdChhZGQpO1xuXG4gIG1heWJlQWRkLmFwKG9uZSkuYXAoZml2ZSk7IC8vIEp1c3QoNilcbiAgbWF5YmVBZGQuYXAob25lKS5hcChub25lKTsgLy8gTm90aGluZ1xuICBtYXliZUFkZC5hcChub25lKS5hcChmaXZlKSAvLyBOb3RoaW5nXG4gIGBgYFxuXG4gIFdpdGhvdXQgYE1heWJlLmFwYCwgeW91J2QgbmVlZCB0byBkbyBzb21ldGhpbmcgbGlrZSBhIG5lc3RlZCBgTWF5YmUubWF0Y2hgOlxuXG4gIGBgYHRzXG4gIGltcG9ydCB7IGp1c3QsIG5vdGhpbmcgfSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGNvbnN0IG9uZSA9IGp1c3QoMSk7XG4gIGNvbnN0IGZpdmUgPSBqdXN0KDUpO1xuICBjb25zdCBub25lID0gbm90aGluZygpO1xuXG4gIG9uZS5tYXRjaCh7XG4gICAgSnVzdDogbiA9PiBmaXZlLm1hdGNoKHtcbiAgICAgIEp1c3Q6IG8gPT4ganVzdChuICsgbyksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBub3RoaW5nKCksXG4gICAgfSksXG4gICAgTm90aGluZzogKCkgID0+IG5vdGhpbmcoKSxcbiAgfSk7IC8vIEp1c3QoNilcblxuICBvbmUubWF0Y2goe1xuICAgIEp1c3Q6IG4gPT4gbm9uZS5tYXRjaCh7XG4gICAgICBKdXN0OiBvID0+IGp1c3QobiArIG8pLFxuICAgICAgTm90aGluZzogKCkgPT4gbm90aGluZygpLFxuICAgIH0pLFxuICAgIE5vdGhpbmc6ICgpICA9PiBub3RoaW5nKCksXG4gIH0pOyAvLyBOb3RoaW5nXG5cbiAgbm9uZS5tYXRjaCh7XG4gICAgSnVzdDogbiA9PiBmaXZlLm1hdGNoKHtcbiAgICAgIEp1c3Q6IG8gPT4ganVzdChuICsgbyksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBub3RoaW5nKCksXG4gICAgfSksXG4gICAgTm90aGluZzogKCkgID0+IG5vdGhpbmcoKSxcbiAgfSk7IC8vIE5vdGhpbmdcbiAgYGBgXG5cbiAgQW5kIHRoaXMga2luZCBvZiB0aGluZyBjb21lcyB1cCBxdWl0ZSBvZnRlbiBvbmNlIHlvdSdyZSB1c2luZyBgTWF5YmVgIHRvXG4gIGhhbmRsZSBvcHRpb25hbGl0eSB0aHJvdWdob3V0IHlvdXIgYXBwbGljYXRpb24uXG5cbiAgRm9yIGFub3RoZXIgZXhhbXBsZSwgaW1hZ2luZSB5b3UgbmVlZCB0byBjb21wYXJlIHRoZSBlcXVhbGl0eSBvZiB0d29cbiAgSW1tdXRhYmxlSlMgZGF0YSBzdHJ1Y3R1cmVzLCB3aGVyZSBhIGA9PT1gIGNvbXBhcmlzb24gd29uJ3Qgd29yay4gV2l0aCBgYXBgLFxuICB0aGF0J3MgYXMgc2ltcGxlIGFzIHRoaXM6XG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG4gIGltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbiAgaW1wb3J0IHsgY3VycnkgfSBmcm9tICdsb2Rhc2gnXG5cbiAgY29uc3QgaXMgPSBjdXJyeShJbW11dGFibGUuaXMpO1xuXG4gIGNvbnN0IHggPSBNYXliZS5vZihJbW11dGFibGUuU2V0Lm9mKDEsIDIsIDMpKTtcbiAgY29uc3QgeSA9IE1heWJlLm9mKEltbXV0YWJsZS5TZXQub2YoMiwgMywgNCkpO1xuXG4gIE1heWJlLm9mKGlzKS5hcCh4KS5hcCh5KTsgLy8gSnVzdChmYWxzZSlcbiAgYGBgXG5cbiAgV2l0aG91dCBgYXBgLCB3ZSdyZSBiYWNrIHRvIHRoYXQgZ25hcmx5IG5lc3RlZCBgbWF0Y2hgOlxuXG4gIGBgYHRzXG4gICAqIGltcG9ydCBNYXliZSwgeyBqdXN0LCBub3RoaW5nIH0gZnJvbSAndHJ1ZS1teXRoL21heWJlJztcbiAgaW1wb3J0IEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnO1xuICBpbXBvcnQgeyBjdXJyeSB9IGZyb20gJ2xvZGFzaCdcblxuICBjb25zdCBpcyA9IGN1cnJ5KEltbXV0YWJsZS5pcyk7XG5cbiAgY29uc3QgeCA9IE1heWJlLm9mKEltbXV0YWJsZS5TZXQub2YoMSwgMiwgMykpO1xuICBjb25zdCB5ID0gTWF5YmUub2YoSW1tdXRhYmxlLlNldC5vZigyLCAzLCA0KSk7XG5cbiAgeC5tYXRjaCh7XG4gICAgSnVzdDogaVggPT4geS5tYXRjaCh7XG4gICAgICBKdXN0OiBpWSA9PiBNYXliZS5qdXN0KEltbXV0YWJsZS5pcyhpWCwgaVkpKSxcbiAgICAgIE5vdGhpbmc6ICgpID0+IE1heWJlLm5vdGhpbmcoKSxcbiAgICB9KVxuICAgIE5vdGhpbmc6ICgpID0+IE1heWJlLm5vdGhpbmcoKSxcbiAgfSk7IC8vIEp1c3QoZmFsc2UpXG4gIGBgYFxuXG4gIEluIHN1bW1hcnk6IGFueXdoZXJlIHlvdSBoYXZlIHR3byBgTWF5YmVgIGluc3RhbmNlcyBhbmQgbmVlZCB0byBwZXJmb3JtIGFuXG4gIG9wZXJhdGlvbiB0aGF0IHVzZXMgYm90aCBvZiB0aGVtLCBgYXBgIGlzIHlvdXIgZnJpZW5kLlxuXG4gIFR3byB0aGluZ3MgdG8gbm90ZSwgYm90aCByZWdhcmRpbmcgKmN1cnJ5aW5nKjpcblxuICAxLiAgQWxsIGZ1bmN0aW9ucyBwYXNzZWQgdG8gYGFwYCBtdXN0IGJlIGN1cnJpZWQuIFRoYXQgaXMsIHRoZXkgbXVzdCBiZSBvZiB0aGVcbiAgICAgIGZvcm0gKGZvciBhZGQpIGAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYmAsICpub3QqIHRoZSBtb3JlIHVzdWFsXG4gICAgICBgKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBhICsgYmAgeW91IHNlZSBpbiBKYXZhU2NyaXB0IG1vcmUgZ2VuZXJhbGx5LlxuXG4gICAgICBGb3IgY29udmVuaWVuY2UsIHlvdSBtYXkgd2FudCB0byBsb29rIGF0IExvZGFzaCdzIGBfLmN1cnJ5YCBvciBSYW1kYSdzXG4gICAgICBgUi5jdXJyeWAsIHdoaWNoIGFsbG93IHlvdSB0byBjcmVhdGUgY3VycmllZCB2ZXJzaW9ucyBvZiBmdW5jdGlvbnNcbiAgICAgIHdoZW5ldmVyIHlvdSB3YW50OlxuXG4gICAgICBgYGBcbiAgICAgIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuICAgICAgaW1wb3J0IHsgY3VycnkgfSBmcm9tICdsb2Rhc2gnO1xuXG4gICAgICBjb25zdCBub3JtYWxBZGQgPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IGEgKyBiO1xuICAgICAgY29uc3QgY3VycmllZEFkZCA9IGN1cnJ5KG5vcm1hbEFkZCk7IC8vIChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiO1xuXG4gICAgICBNYXliZS5vZihjdXJyaWVkQWRkKS5hcChNYXliZS5vZigxKSkuYXAoTWF5YmUub2YoNSkpOyAvLyBKdXN0KDYpXG4gICAgICBgYGBcblxuICAyLiAgWW91IHdpbGwgbmVlZCB0byBjYWxsIGBhcGAgYXMgbWFueSB0aW1lcyBhcyB0aGVyZSBhcmUgYXJndW1lbnRzIHRvIHRoZVxuICAgICAgZnVuY3Rpb24geW91J3JlIGRlYWxpbmcgd2l0aC4gU28gaW4gdGhlIGNhc2Ugb2YgYGFkZGAsIHdoaWNoIGhhcyB0aGVcbiAgICAgIFwiYXJpdHlcIiAoZnVuY3Rpb24gYXJndW1lbnQgY291bnQpIG9mIDIgKGBhYCBhbmQgYGJgKSwgeW91J2xsIG5lZWQgdG8gY2FsbFxuICAgICAgYGFwYCB0d2ljZTogb25jZSBmb3IgYGFgLCBhbmQgb25jZSBmb3IgYGJgLiBUbyBzZWUgd2h5LCBsZXQncyBsb29rIGF0IHdoYXRcbiAgICAgIHRoZSByZXN1bHQgaW4gZWFjaCBwaGFzZSBpczpcblxuICAgICAgYGBgdHNcbiAgICAgIGNvbnN0IGFkZCA9IChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiO1xuXG4gICAgICBjb25zdCBtYXliZUFkZCA9IE1heWJlLm9mKGFkZCk7IC8vIEp1c3QoKGE6IG51bWJlcikgPT4gKGI6IG51bWJlcikgPT4gYSArIGIpXG4gICAgICBjb25zdCBtYXliZUFkZDEgPSBtYXliZUFkZC5hcChNYXliZS5vZigxKSk7IC8vIEp1c3QoKGI6IG51bWJlcikgPT4gMSArIGIpXG4gICAgICBjb25zdCBmaW5hbCA9IG1heWJlQWRkMS5hcChNYXliZS5vZigzKSk7IC8vIEp1c3QoNClcbiAgICAgIGBgYFxuXG4gICAgICBTbyBmb3IgYHRvU3RyaW5nYCwgd2hpY2gganVzdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudCwgeW91IHdvdWxkIG9ubHkgbmVlZFxuICAgICAgdG8gY2FsbCBgYXBgIG9uY2UuXG5cbiAgICAgIGBgYHRzXG4gICAgICBjb25zdCB0b1N0ciA9ICh2OiB7IHRvU3RyaW5nKCk6IHN0cmluZyB9KSA9PiB2LnRvU3RyaW5nKCk7XG4gICAgICBNYXliZS5vZih0b1N0cikuYXAoMTIpOyAvLyBKdXN0KFwiMTJcIilcbiAgICAgIGBgYFxuXG4gIE9uZSBvdGhlciBzY2VuYXJpbyB3aGljaCBkb2Vzbid0IGNvbWUgdXAgKnF1aXRlKiBhcyBvZnRlbiBidXQgaXMgY29uY2VpdmFibGVcbiAgaXMgd2hlcmUgeW91IGhhdmUgc29tZXRoaW5nIHRoYXQgbWF5IG9yIG1heSBub3QgYWN0dWFsbHkgY29uc3RydWN0IGEgZnVuY3Rpb25cbiAgZm9yIGhhbmRsaW5nIGEgc3BlY2lmaWMgYE1heWJlYCBzY2VuYXJpby4gSW4gdGhhdCBjYXNlLCB5b3UgY2FuIHdyYXAgdGhlXG4gIHBvc3NpYmx5LXByZXNlbnQgaW4gYGFwYCBhbmQgdGhlbiB3cmFwIHRoZSB2YWx1ZXMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uIHRvXG4gIGluIGBNYXliZWAgdGhlbXNlbHZlcy5cblxuICAqKkFzaWRlOioqIGBhcGAgaXMgbm90IG5hbWVkIGBhcHBseWAgYmVjYXVzZSBvZiB0aGUgb3ZlcmxhcCB3aXRoIEphdmFTY3JpcHQnc1xuICBleGlzdGluZyBbYGFwcGx5YF0gZnVuY3Rpb24g4oCTIGFuZCBhbHRob3VnaCBzdHJpY3RseSBzcGVha2luZywgdGhlcmUgaXNuJ3QgYW55XG4gIGRpcmVjdCBvdmVybGFwIChgTWF5YmUuYXBwbHlgIGFuZCBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YCBkb24ndCBpbnRlcnNlY3RcbiAgYXQgYWxsKSBpdCdzIHVzZWZ1bCB0byBoYXZlIGEgZGlmZmVyZW50IG5hbWUgdG8gYXZvaWQgaW1wbHlpbmcgdGhhdCB0aGV5J3JlXG4gIHRoZSBzYW1lLlxuXG4gIFtgYXBwbHlgXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYXBwbHlcblxuICBAcGFyYW0gbWF5YmVGbiBtYXliZSBhIGZ1bmN0aW9uIGZyb20gVCB0byBVXG4gIEBwYXJhbSBtYXliZSBtYXliZSBhIFQgdG8gYXBwbHkgdG8gYGZuYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVT4obWF5YmVGbjogTWF5YmU8KHQ6IFQpID0+IFU+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhcDxULCBVPihtYXliZUZuOiBNYXliZTwodDogVCkgPT4gVT4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhcDxULCBVPihcbiAgbWF5YmVGbjogTWF5YmU8KHZhbDogVCkgPT4gVT4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKCh2YWw6IE1heWJlPFQ+KSA9PiBNYXliZTxVPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT5cbiAgICBtLm1hdGNoKHtcbiAgICAgIEp1c3Q6IHZhbCA9PiBtYXliZUZuLm1hcChmbiA9PiBmbih2YWwpKSxcbiAgICAgIE5vdGhpbmc6ICgpID0+IE1heWJlLm5vdGhpbmc8VT4oKSxcbiAgICB9KTtcblxuICByZXR1cm4gY3VycnkxKG9wLCBtYXliZSk7XG59XG5cbi8qKlxuICBEZXRlcm1pbmUgd2hldGhlciBhbiBpdGVtIGlzIGFuIGluc3RhbmNlIG9mIGBKdXN0YCBvciBgTm90aGluZ2AuXG5cbiAgQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0luc3RhbmNlPFQgPSBhbnk+KGl0ZW06IGFueSk6IGl0ZW0gaXMgTWF5YmU8VD4ge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEp1c3QgfHwgaXRlbSBpbnN0YW5jZW9mIE5vdGhpbmc7XG59XG5cbi8qKiBBIHZhbHVlIHdoaWNoIG1heSAoYEp1c3Q8VD5gKSBvciBtYXkgbm90IChgTm90aGluZ2ApIGJlIHByZXNlbnQuICovXG5leHBvcnQgdHlwZSBNYXliZTxUPiA9IEp1c3Q8VD4gfCBOb3RoaW5nPFQ+O1xuZXhwb3J0IGNvbnN0IE1heWJlID0ge1xuICBWYXJpYW50LFxuICBKdXN0LFxuICBOb3RoaW5nLFxuICBpc0p1c3QsXG4gIGlzTm90aGluZyxcbiAganVzdCxcbiAgbm90aGluZyxcbiAgb2YsXG4gIGZyb21OdWxsYWJsZSxcbiAgbWFwLFxuICBtYXBPcixcbiAgbWFwT3JFbHNlLFxuICBhbmQsXG4gIGFuZFRoZW4sXG4gIGNoYWluLFxuICBmbGF0TWFwLFxuICBvcixcbiAgb3JFbHNlLFxuICB1bnNhZmVseVVud3JhcCxcbiAgdW5zYWZlbHlHZXQsXG4gIHVuc2FmZUdldCxcbiAgdW53cmFwT3IsXG4gIGdldE9yLFxuICB1bndyYXBPckVsc2UsXG4gIGdldE9yRWxzZSxcbiAgdG9Pa09yRXJyLFxuICB0b09rT3JFbHNlRXJyLFxuICBmcm9tUmVzdWx0LFxuICB0b1N0cmluZyxcbiAgbWF0Y2gsXG4gIGNhdGEsXG4gIGVxdWFscyxcbiAgYXAsXG4gIGlzSW5zdGFuY2UsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXliZTtcbiJdfQ==