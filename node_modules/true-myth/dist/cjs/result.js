"use strict";
/** [[include:doc/result.md]] */
Object.defineProperty(exports, "__esModule", { value: true });
/** (keep typedoc from getting confused by the import) */
const maybe_1 = require("./maybe");
const unit_1 = require("./unit");
const utils_1 = require("./utils");
// So that it doesn't appear unused but can be exported.
utils_1._Brand; // tslint:disable-line:no-unused-expression
/**
  Discriminant for `Ok` and `Err` variants of `Result` type.

  You can use the discriminant via the `variant` property of `Result` instances
  if you need to match explicitly on it.
 */
var Variant;
(function (Variant) {
    Variant["Ok"] = "Ok";
    Variant["Err"] = "Err";
})(Variant = exports.Variant || (exports.Variant = {}));
/**
  An `Ok` instance is the *successful* variant instance of the
  [`Result`](../modules/_result_.html#result) type, representing a successful
  outcome from an operation which may fail. For a full discussion, see [the
  module docs](../modules/_result_.html).

  @typeparam T The type wrapped in this `Ok` variant of `Result`.
  @typeparam E The type which would be wrapped in an `Err` variant of `Result`.
 */
class Ok {
    /**
      Create an instance of `Result.Ok` with `new`.
  
      Note: While you *may* create the `Result` type via normal
      JavaScript class construction, it is not recommended for the functional
      style for which the library is intended. Instead, use [`Result.ok`].
  
      [`Result.ok`]: ../modules/_result_.html#ok
  
      ```ts
      // Avoid:
      const aString = new Result.Ok('characters');
  
      // Prefer:
      const aString = Result.ok('characters);
      ```
  
      Note that you may explicitly pass `Unit` to the `Ok` constructor to create
      a `Result<Unit, E>`. However, you may *not* call the `Ok` constructor with
      `null` or `undefined` to get that result (the type system won't allow you to
      construct it that way). Instead, for convenience, you can simply call
      `Result.ok()`, which will construct the type correctly.
  
      @param value
      The value to wrap in a `Result.Ok`.
  
      Note: `null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Result<undefined>`.
  
      @throws If you pass `null`.
     */
    constructor(value) {
        /** `Ok` is always [`Variant.Ok`](../enums/_result_.variant#ok). */
        this.variant = Variant.Ok;
        if (utils_1.isVoid(value)) {
            throw new Error('Tried to construct `Ok` with `null` or `undefined`. Maybe you want `Maybe.Nothing`?');
        }
        this.value = value;
    }
    /**
      Unwrap the contained value. A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Result, { Ok } from 'true-myth/result';
  
      function getLengths(results: Array<Result<string, string>>): Array<number> {
        return results
          .filter(Result.isOk)
          .map(Ok.unwrap)
          .map(s => s.length);
      }
      ```
     */
    static unwrap(theOk) {
        return theOk.value;
    }
    /** Method variant for [`Result.isOk`](../modules/_result_.html#isok) */
    isOk() {
        return true;
    }
    /** Method variant for [`Result.isErr`](../modules/_result_.html#iserr) */
    isErr() {
        return false;
    }
    /** Method variant for [`Result.map`](../modules/_result_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Result.match`](../modules/_result_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) */
    mapErr(mapErrFn) {
        return mapErr(mapErrFn, this);
    }
    /** Method variant for [`Result.or`](../modules/_result_.html#or) */
    or(orResult) {
        return or(orResult, this);
    }
    /** Method variant for [`Result.orElse`](../modules/_result_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Result.and`](../modules/_result_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Result.andThen`](../modules/_result_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Result.chain`](../modules/_result_.html#chain) */
    chain(chainFn) {
        return exports.chain(chainFn, this);
    }
    /** Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) */
    flatMap(flatMapFn) {
        return exports.flatMap(flatMapFn, this);
    }
    /** Method variant for [`Result.unwrap`](../modules/_result_.html#unwrap) */
    unsafelyUnwrap() {
        return this.value;
    }
    /** Method variant for [`Result.unwrapErr`](../modules/_result_.html#unwraperr) */
    unsafelyUnwrapErr() {
        throw new Error('Tried to `unsafelyUnwrapErr` an `Ok`');
    }
    /** Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwrapOrElse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) */
    toMaybe() {
        return toMaybe(this);
    }
    /** Method variant for [`Result.toString`](../modules/_result_.html#tostring) */
    toString() {
        return exports.toString(this);
    }
    /** Method variant for [`Result.equals`](../modules/_result_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Result.ap`](../modules/_result_.html#ap) */
    ap(r) {
        return ap(this, r);
    }
}
exports.Ok = Ok;
/**
  An `Err` instance is the *failure* variant instance of the
  [`Result`](../modules/_result_.html#result) type, representing a failure
  outcome from an operation which may fail. For a full discussion, see [the
  module docs](../modules/_result_.html).

  @typeparam T The type which would be wrapped in an `Ok` variant of `Result`.
  @typeparam E The type wrapped in this `Err` variant of `Result`.
  */
class Err {
    /**
      Create an instance of `Result.Err` with `new`.
  
      Note: While you *may* create the `Result` type via normal
      JavaScript class construction, it is not recommended for the functional
      style for which the library is intended. Instead, use [`Result.err`].
  
      [`Result.err`]: ../modules/_result_.html#err
  
      ```ts
      // Avoid:
      const anErr = new Result.Err('alas, failure');
  
      // Prefer:
      const anErr = Result.err('alas, failure');
      ```
  
      Note that you may explicitly pass `Unit` to the `Err` constructor to create
      a `Result<T, Unit>`. However, you may *not* call the `Err` constructor with
      `null` or `undefined` to get that result (the type system won't allow you to
      construct it that way). Instead, for convenience, you can simply call
      `Result.err()`, which will construct the type correctly.
  
      @param error
      The value to wrap in a `Result.Err`.
  
      `Note: null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Result<number, undefined>`.
  
      @throws If you pass `null` or `undefined`.
     */
    constructor(error) {
        /** `Err` is always [`Variant.Err`](../enums/_result_.variant#err). */
        this.variant = Variant.Err;
        if (utils_1.isVoid(error)) {
            throw new Error('Tried to construct `Err` with `null` or `undefined`. Maybe you want `Maybe.Nothing`?');
        }
        this.error = error;
    }
    /**
      Unwrap the contained error . A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Result, { Ok } from 'true-myth/result';
  
      function getMessages(results: Array<Result<string, Error>>): Array<number> {
        return maybeStrings
          .filter(Result.isErr)
          .map(Err.unwrapErr)
          .map(e => e.message);
      }
      ```
     */
    static unwrapErr(theErr) {
        return theErr.error;
    }
    /** Method variant for [`Result.isOk`](../modules/_result_.html#isok) */
    isOk() {
        return false;
    }
    /** Method variant for [`Result.isErr`](../modules/_result_.html#iserr) */
    isErr() {
        return true;
    }
    /** Method variant for [`Result.map`](../modules/_result_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Result.match`](../modules/_result_.html#match) */
    match(matchObj) {
        return match(matchObj, this);
    }
    /** Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) */
    mapErr(mapErrFn) {
        return mapErr(mapErrFn, this);
    }
    /** Method variant for [`Result.or`](../modules/_result_.html#or) */
    or(orResult) {
        return or(orResult, this);
    }
    /** Method variant for [`Result.orElse`](../modules/_result_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Result.and`](../modules/_result_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Result.andThen`](../modules/_result_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Result.chain`](../modules/_result_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Result.unsafelyUnwrap`](../modules/_result_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        throw new Error('Tried to `unsafelyUnwrap an Err`');
    }
    /** Method variant for [`Result.unsafelyUnwrapErr`](../modules/_result_.html#unsafelyunwraperr) */
    unsafelyUnwrapErr() {
        return this.error;
    }
    /** Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) */
    toMaybe() {
        return toMaybe(this);
    }
    /** Method variant for [`Result.toString`](../modules/_result_.html#tostring) */
    toString() {
        return exports.toString(this);
    }
    /** Method variant for [`Result.equals`](../modules/_result_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Result.ap`](../modules/_result_.html#ap) */
    ap(r) {
        return ap(this, r);
    }
}
exports.Err = Err;
/**
  Is this `Result` an `Ok` instance?

  In TypeScript, narrows the type from `Result<T, E>` to `Ok<T, E>`.
 */
function isOk(result) {
    return result.variant === Variant.Ok;
}
exports.isOk = isOk;
/**
  Is this `Result` an `Err` instance?

  In TypeScript, narrows the type from `Result<T, E>` to `Err<T, E>`.
 */
function isErr(result) {
    return result.variant === Variant.Err;
}
exports.isErr = isErr;
function ok(value) {
    return value === undefined ? new Ok(unit_1.default) : new Ok(value);
}
exports.ok = ok;
/** `Result.of` is an alias for `Result.ok`. */
exports.of = ok;
function err(error) {
    return utils_1.isVoid(error) ? new Err(unit_1.default) : new Err(error);
}
exports.err = err;
function map(mapFn, result) {
    const op = (r) => (isOk(r) ? ok(mapFn(r.value)) : r);
    return utils_1.curry1(op, result);
}
exports.map = map;
function mapOr(orU, mapFn, result) {
    function fullOp(fn, r) {
        return isOk(r) ? fn(r.value) : orU;
    }
    function partialOp(fn, curriedResult) {
        return curriedResult !== undefined
            ? fullOp(fn, curriedResult)
            : (extraCurriedResult) => fullOp(fn, extraCurriedResult);
    }
    return mapFn === undefined
        ? partialOp
        : result === undefined ? partialOp(mapFn) : partialOp(mapFn, result);
}
exports.mapOr = mapOr;
function mapOrElse(orElseFn, mapFn, result) {
    function fullOp(fn, r) {
        return isOk(r) ? fn(r.value) : orElseFn(r.error);
    }
    function partialOp(fn, curriedResult) {
        return curriedResult !== undefined
            ? fullOp(fn, curriedResult)
            : (extraCurriedResult) => fullOp(fn, extraCurriedResult);
    }
    return mapFn === undefined
        ? partialOp
        : result === undefined ? partialOp(mapFn) : partialOp(mapFn, result);
}
exports.mapOrElse = mapOrElse;
function mapErr(mapErrFn, result) {
    const op = (r) => (isOk(r) ? r : err(mapErrFn(r.error)));
    return utils_1.curry1(op, result);
}
exports.mapErr = mapErr;
function and(andResult, result) {
    const op = (r) => (isOk(r) ? andResult : r);
    return utils_1.curry1(op, result);
}
exports.and = and;
function andThen(thenFn, result) {
    const op = (r) => (isOk(r) ? thenFn(r.value) : r);
    return utils_1.curry1(op, result);
}
exports.andThen = andThen;
/** Alias for [`andThen`](#andthen). */
exports.chain = andThen;
/** Alias for [`andThen`](#andthen). */
exports.flatMap = andThen;
function or(defaultResult, result) {
    const op = (r) => (isOk(r) ? r : defaultResult);
    return utils_1.curry1(op, result);
}
exports.or = or;
function orElse(elseFn, result) {
    const op = (r) => (isOk(r) ? r : elseFn(r.unsafelyUnwrapErr()));
    return utils_1.curry1(op, result);
}
exports.orElse = orElse;
/**
  Get the value out of the `Result`.

  Returns the content of an `Ok`, but **throws if the `Result` is `Err`.**
  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).

  @throws If the `Result` instance is `Nothing`.
 */
function unsafelyUnwrap(result) {
    return result.unsafelyUnwrap();
}
exports.unsafelyUnwrap = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafelyGet = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafeGet = unsafelyUnwrap;
/**
  Get the error value out of the [`Result`](#result).

  Returns the content of an `Err`, but **throws if the `Result` is `Ok`**.
  Prefer to use [`unwrapOrElse`](#unwraporelse).

  @param result
  @throws Error If the `Result` instance is `Nothing`.
 */
function unsafelyUnwrapErr(result) {
    return result.unsafelyUnwrapErr();
}
exports.unsafelyUnwrapErr = unsafelyUnwrapErr;
/** Alias for [`unsafelyUnwrapErr`](#unsafelyunwraperr) */
exports.unsafelyGetErr = unsafelyUnwrapErr;
function unwrapOr(defaultValue, result) {
    const op = (r) => (isOk(r) ? r.value : defaultValue);
    return utils_1.curry1(op, result);
}
exports.unwrapOr = unwrapOr;
/** Alias for [`unwrapOr`](#unwrapor) */
exports.getOr = unwrapOr;
function unwrapOrElse(orElseFn, result) {
    const op = (r) => (isOk(r) ? r.value : orElseFn(r.error));
    return utils_1.curry1(op, result);
}
exports.unwrapOrElse = unwrapOrElse;
/** Alias for [`unwrapOrElse`](#unwraporelse) */
exports.getOrElse = unwrapOrElse;
/**
  Convert a [`Result`](#result) to a [`Maybe`](../modules/_maybe_.html#maybe).

  The converted type will be [`Just`] if the `Result` is [`Ok`] or [`Nothing`]
  if the `Result` is [`Err`]; the wrapped error value will be discarded.

  [`Just`]: ../classes/_maybe_.just.html
  [`Nothing`]: ../classes/_maybe_.nothing.html
  [`Ok`]: ../classes/_result_.ok.html
  [`Err`]: ../classes/_result_.err.html

  @param result The `Result` to convert to a `Maybe`
  @returns      `Just` the value in `result` if it is `Ok`; otherwise `Nothing`
 */
function toMaybe(result) {
    return isOk(result) ? maybe_1.just(result.value) : maybe_1.nothing();
}
exports.toMaybe = toMaybe;
function fromMaybe(errValue, maybe) {
    const op = (m) => (maybe_1.isJust(m) ? ok(maybe_1.default.unsafelyUnwrap(m)) : err(errValue));
    return utils_1.curry1(op, maybe);
}
exports.fromMaybe = fromMaybe;
/**
  Create a `String` representation of a `result` instance.

  An `Ok` instance will be printed as `Ok(<representation of the value>)`, and
  an `Err` instance will be printed as `Err(<representation of the error>)`,
  where the representation of the value or error is simply the value or error's
  own `toString` representation. For example:

                call                |         output
  --------------------------------- | ----------------------
  `toString(ok(42))`                | `Ok(42)`
  `toString(ok([1, 2, 3]))`         | `Ok(1,2,3)`
  `toString(ok({ an: 'object' }))`  | `Ok([object Object])`n
  `toString(err(42))`               | `Err(42)`
  `toString(err([1, 2, 3]))`        | `Err(1,2,3)`
  `toString(err({ an: 'object' }))` | `Err([object Object])`

  @typeparam T The type of the wrapped value; its own `.toString` will be used
               to print the interior contents of the `Just` variant.
  @param maybe The value to convert to a string.
  @returns     The string representation of the `Maybe`.
 */
exports.toString = (result) => {
    const body = (isOk(result) ? result.value : result.error).toString();
    return `${result.variant.toString()}(${body})`;
};
function match(matcher, result) {
    const op = (r) => mapOrElse(matcher.Err, matcher.Ok, r);
    return utils_1.curry1(op, result);
}
exports.match = match;
/** Alias for [`match`](#match) */
exports.cata = match;
function equals(resultB, resultA) {
    return resultA !== undefined
        ? resultA.match({
            Err: () => isErr(resultB),
            Ok: a => isOk(resultB) && resultB.unsafelyUnwrap() === a,
        })
        : (curriedResultA) => curriedResultA.match({
            Err: () => isErr(resultB),
            Ok: a => isOk(resultB) && resultB.unsafelyUnwrap() === a,
        });
}
exports.equals = equals;
function ap(resultFn, result) {
    const op = (r) => r.match({
        Ok: val => resultFn.map(fn => fn(val)),
        Err: e => exports.Result.err(e),
    });
    return utils_1.curry1(op, result);
}
exports.ap = ap;
/**
  Determine whether an item is an instance of `Just` or `Nothing`.

  @param item The item to check.
 */
function isInstance(item) {
    return item instanceof Ok || item instanceof Err;
}
exports.isInstance = isInstance;
exports.Result = {
    Variant,
    Ok,
    Err,
    isOk,
    isErr,
    ok,
    err,
    map,
    mapOr,
    mapOrElse,
    mapErr,
    and,
    andThen,
    chain: exports.chain,
    flatMap: exports.flatMap,
    or,
    orElse,
    unsafelyUnwrap,
    unsafelyGet: exports.unsafelyGet,
    unsafeGet: exports.unsafeGet,
    unsafelyUnwrapErr,
    unsafelyGetErr: exports.unsafelyGetErr,
    unwrapOr,
    getOr: exports.getOr,
    unwrapOrElse,
    getOrElse: exports.getOrElse,
    toMaybe,
    fromMaybe,
    toString: exports.toString,
    match,
    cata: exports.cata,
    equals,
    ap,
    isInstance,
};
exports.default = exports.Result;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdWx0LmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9jaHJpcy9kZXYvb3NzL3RydWUtbXl0aC8iLCJzb3VyY2VzIjpbInJlc3VsdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsZ0NBQWdDOztBQUVoQyx5REFBeUQ7QUFDekQsbUNBQXVEO0FBQ3ZELGlDQUEwQjtBQUMxQixtQ0FBaUQ7QUFFakQsd0RBQXdEO0FBQ3hELGNBQU0sQ0FBQyxDQUFDLDJDQUEyQztBQUVuRDs7Ozs7R0FLRztBQUNILElBQVksT0FHWDtBQUhELFdBQVksT0FBTztJQUNqQixvQkFBUyxDQUFBO0lBQ1Qsc0JBQVcsQ0FBQTtBQUNiLENBQUMsRUFIVyxPQUFPLEdBQVAsZUFBTyxLQUFQLGVBQU8sUUFHbEI7QUF1RUQ7Ozs7Ozs7O0dBUUc7QUFDSDtJQTRCRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQStCRztJQUNILFlBQVksS0FBZ0I7UUF0QzVCLG1FQUFtRTtRQUMxRCxZQUFPLEdBQWUsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQXNDeEMsSUFBSSxjQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDakIsTUFBTSxJQUFJLEtBQUssQ0FDYixxRkFBcUYsQ0FDdEYsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQW5FRDs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNILE1BQU0sQ0FBQyxNQUFNLENBQUksS0FBaUI7UUFDaEMsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUFrREQsd0VBQXdFO0lBQ3hFLElBQUk7UUFDRixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCwwRUFBMEU7SUFDMUUsS0FBSztRQUNILE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELHNFQUFzRTtJQUN0RSxHQUFHLENBQXdCLEtBQWtCO1FBQzNDLE9BQU8sR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENB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LEVBQUU7SUFDRixHQUFHO0lBQ0gsSUFBSTtJQUNKLEtBQUs7SUFDTCxFQUFFO0lBQ0YsR0FBRztJQUNILEdBQUc7SUFDSCxLQUFLO0lBQ0wsU0FBUztJQUNULE1BQU07SUFDTixHQUFHO0lBQ0gsT0FBTztJQUNQLEtBQUssRUFBTCxhQUFLO0lBQ0wsT0FBTyxFQUFQLGVBQU87SUFDUCxFQUFFO0lBQ0YsTUFBTTtJQUNOLGNBQWM7SUFDZCxXQUFXLEVBQVgsbUJBQVc7SUFDWCxTQUFTLEVBQVQsaUJBQVM7SUFDVCxpQkFBaUI7SUFDakIsY0FBYyxFQUFkLHNCQUFjO0lBQ2QsUUFBUTtJQUNSLEtBQUssRUFBTCxhQUFLO0lBQ0wsWUFBWTtJQUNaLFNBQVMsRUFBVCxpQkFBUztJQUNULE9BQU87SUFDUCxTQUFTO0lBQ1QsUUFBUSxFQUFSLGdCQUFRO0lBQ1IsS0FBSztJQUNMLElBQUksRUFBSixZQUFJO0lBQ0osTUFBTTtJQUNOLEVBQUU7SUFDRixVQUFVO0NBQ1gsQ0FBQztBQUVGLGtCQUFlLGNBQU0sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBbW2luY2x1ZGU6ZG9jL3Jlc3VsdC5tZF1dICovXG5cbi8qKiAoa2VlcCB0eXBlZG9jIGZyb20gZ2V0dGluZyBjb25mdXNlZCBieSB0aGUgaW1wb3J0KSAqL1xuaW1wb3J0IE1heWJlLCB7IGlzSnVzdCwganVzdCwgbm90aGluZyB9IGZyb20gJy4vbWF5YmUnO1xuaW1wb3J0IFVuaXQgZnJvbSAnLi91bml0JztcbmltcG9ydCB7IF9CcmFuZCwgY3VycnkxLCBpc1ZvaWQgfSBmcm9tICcuL3V0aWxzJztcblxuLy8gU28gdGhhdCBpdCBkb2Vzbid0IGFwcGVhciB1bnVzZWQgYnV0IGNhbiBiZSBleHBvcnRlZC5cbl9CcmFuZDsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuXG4vKipcbiAgRGlzY3JpbWluYW50IGZvciBgT2tgIGFuZCBgRXJyYCB2YXJpYW50cyBvZiBgUmVzdWx0YCB0eXBlLlxuXG4gIFlvdSBjYW4gdXNlIHRoZSBkaXNjcmltaW5hbnQgdmlhIHRoZSBgdmFyaWFudGAgcHJvcGVydHkgb2YgYFJlc3VsdGAgaW5zdGFuY2VzXG4gIGlmIHlvdSBuZWVkIHRvIG1hdGNoIGV4cGxpY2l0bHkgb24gaXQuXG4gKi9cbmV4cG9ydCBlbnVtIFZhcmlhbnQge1xuICBPayA9ICdPaycsXG4gIEVyciA9ICdFcnInLFxufVxuXG4vKiogU2ltcGx5IGRlZmluZXMgdGhlIGNvbW1vbiBzaGFwZSBmb3IgYE9rYCBhbmQgYEVycmAuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3VsdFNoYXBlPFQsIEU+IHtcbiAgLyoqIERpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIGBPa2AgYW5kIGBFcnJgIHZhcmlhbnRzLiAqL1xuICByZWFkb25seSB2YXJpYW50OiBWYXJpYW50O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuaXNPa2BdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNpc29rKSAqL1xuICBpc09rKHRoaXM6IFJlc3VsdDxULCBFPik6IHRoaXMgaXMgT2s8VCwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5pc0VycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNpc2VycikgKi9cbiAgaXNFcnIodGhpczogUmVzdWx0PFQsIEU+KTogdGhpcyBpcyBFcnI8VCwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtYXBGbjogKHQ6IFQpID0+IFUpOiBSZXN1bHQ8VSwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBPcmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNtYXBvcikgKi9cbiAgbWFwT3I8VT4odGhpczogUmVzdWx0PFQsIEU+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFU7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWFwb3JlbHNlKSAqL1xuICBtYXBPckVsc2U8VT4odGhpczogUmVzdWx0PFQsIEU+LCBvckVsc2VGbjogKGVycjogRSkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVTtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm1hdGNoYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hdGNoKSAqL1xuICBtYXRjaDxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG1hdGNoZXI6IE1hdGNoZXI8VCwgRSwgVT4pOiBVO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWFwRXJyYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hcGVycikgKi9cbiAgbWFwRXJyPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgbWFwRXJyRm46IChlOiBFKSA9PiBGKTogUmVzdWx0PFQsIEY+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQub3JgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjb3IpICovXG4gIG9yPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JSZXN1bHQ6IFJlc3VsdDxULCBGPik6IFJlc3VsdDxULCBGPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm9yRWxzZWBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNvcmVsc2UpICovXG4gIG9yRWxzZTxGPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG9yRWxzZUZuOiAoZXJyOiBFKSA9PiBSZXN1bHQ8VCwgRj4pOiBSZXN1bHQ8VCwgRj47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5hbmRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjYW5kKSAqL1xuICBhbmQ8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtQW5kOiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5hbmRUaGVuYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2FuZHRoZW4pICovXG4gIGFuZFRoZW48VT4odGhpczogUmVzdWx0PFQsIEU+LCBhbmRUaGVuRm46ICh0OiBUKSA9PiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5jaGFpbmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNjaGFpbikgKi9cbiAgY2hhaW48VT4odGhpczogUmVzdWx0PFQsIEU+LCBjaGFpbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuZmxhdE1hcGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNmbGF0bWFwKSAqL1xuICBmbGF0TWFwPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgY2hhaW5GbjogKHQ6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXApICovXG4gIHVuc2FmZWx5VW53cmFwKCk6IFQgfCBuZXZlcjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcEVycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXBlcnIpICovXG4gIHVuc2FmZWx5VW53cmFwRXJyKCk6IEUgfCBuZXZlcjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcE9yYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vud3JhcG9yKSAqL1xuICB1bndyYXBPcih0aGlzOiBSZXN1bHQ8VCwgRT4sIGRlZmF1bHRWYWx1ZTogVCk6IFQ7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC51bndyYXBPckVsc2VgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjdW53cmFwT3JFbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogUmVzdWx0PFQsIEU+LCBlbHNlRm46IChlcnJvcjogRSkgPT4gVCk6IFQ7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC50b01heWJlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3RvbWF5YmUpICovXG4gIHRvTWF5YmUodGhpczogUmVzdWx0PFQsIEU+KTogTWF5YmU8VD47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC50b1N0cmluZ2BdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN0b3N0cmluZykgKi9cbiAgdG9TdHJpbmcodGhpczogUmVzdWx0PFQsIEU+KTogc3RyaW5nO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuZXF1YWxzYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2VxdWFscykgKi9cbiAgZXF1YWxzKHRoaXM6IFJlc3VsdDxULCBFPiwgY29tcGFyaXNvbjogUmVzdWx0PFQsIEU+KTogYm9vbGVhbjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmFwYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2FwKSAqL1xuICBhcDxBLCBCPih0aGlzOiBSZXN1bHQ8KGE6IEEpID0+IEIsIEU+LCByOiBSZXN1bHQ8QSwgRT4pOiBSZXN1bHQ8QiwgRT47XG59XG5cbi8qKlxuICBBbiBgT2tgIGluc3RhbmNlIGlzIHRoZSAqc3VjY2Vzc2Z1bCogdmFyaWFudCBpbnN0YW5jZSBvZiB0aGVcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSB0eXBlLCByZXByZXNlbnRpbmcgYSBzdWNjZXNzZnVsXG4gIG91dGNvbWUgZnJvbSBhbiBvcGVyYXRpb24gd2hpY2ggbWF5IGZhaWwuIEZvciBhIGZ1bGwgZGlzY3Vzc2lvbiwgc2VlIFt0aGVcbiAgbW9kdWxlIGRvY3NdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCkuXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIHdyYXBwZWQgaW4gdGhpcyBgT2tgIHZhcmlhbnQgb2YgYFJlc3VsdGAuXG4gIEB0eXBlcGFyYW0gRSBUaGUgdHlwZSB3aGljaCB3b3VsZCBiZSB3cmFwcGVkIGluIGFuIGBFcnJgIHZhcmlhbnQgb2YgYFJlc3VsdGAuXG4gKi9cbmV4cG9ydCBjbGFzcyBPazxULCBFPiBpbXBsZW1lbnRzIFJlc3VsdFNoYXBlPFQsIEU+IHtcbiAgLyoqXG4gICAgVW53cmFwIHRoZSBjb250YWluZWQgdmFsdWUuIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBmdW5jdGlvbmFsIGlkaW9tcy5cblxuICAgIEEgY29tbW9uIHNjZW5hcmlvIHdoZXJlIHlvdSBtaWdodCB3YW50IHRvIHVzZSB0aGlzIGlzIGluIGEgcGlwZWxpbmUgb2ZcbiAgICBmdW5jdGlvbnM6XG5cbiAgICBgYGB0c1xuICAgIGltcG9ydCBSZXN1bHQsIHsgT2sgfSBmcm9tICd0cnVlLW15dGgvcmVzdWx0JztcblxuICAgIGZ1bmN0aW9uIGdldExlbmd0aHMocmVzdWx0czogQXJyYXk8UmVzdWx0PHN0cmluZywgc3RyaW5nPj4pOiBBcnJheTxudW1iZXI+IHtcbiAgICAgIHJldHVybiByZXN1bHRzXG4gICAgICAgIC5maWx0ZXIoUmVzdWx0LmlzT2spXG4gICAgICAgIC5tYXAoT2sudW53cmFwKVxuICAgICAgICAubWFwKHMgPT4gcy5sZW5ndGgpO1xuICAgIH1cbiAgICBgYGBcbiAgICovXG4gIHN0YXRpYyB1bndyYXA8Tz4odGhlT2s6IE9rPE8sIGFueT4pOiBPIHtcbiAgICByZXR1cm4gdGhlT2sudmFsdWU7XG4gIH1cblxuICAvKiogYE9rYCBpcyBhbHdheXMgW2BWYXJpYW50Lk9rYF0oLi4vZW51bXMvX3Jlc3VsdF8udmFyaWFudCNvaykuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQuT2sgPSBWYXJpYW50Lk9rO1xuXG4gIC8qKiBUaGUgd3JhcHBlZCB2YWx1ZS4gKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFQ7XG5cbiAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBSZXN1bHQuT2tgIHdpdGggYG5ld2AuXG5cbiAgICBOb3RlOiBXaGlsZSB5b3UgKm1heSogY3JlYXRlIHRoZSBgUmVzdWx0YCB0eXBlIHZpYSBub3JtYWxcbiAgICBKYXZhU2NyaXB0IGNsYXNzIGNvbnN0cnVjdGlvbiwgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB0aGUgZnVuY3Rpb25hbFxuICAgIHN0eWxlIGZvciB3aGljaCB0aGUgbGlicmFyeSBpcyBpbnRlbmRlZC4gSW5zdGVhZCwgdXNlIFtgUmVzdWx0Lm9rYF0uXG5cbiAgICBbYFJlc3VsdC5va2BdOiAuLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjb2tcblxuICAgIGBgYHRzXG4gICAgLy8gQXZvaWQ6XG4gICAgY29uc3QgYVN0cmluZyA9IG5ldyBSZXN1bHQuT2soJ2NoYXJhY3RlcnMnKTtcblxuICAgIC8vIFByZWZlcjpcbiAgICBjb25zdCBhU3RyaW5nID0gUmVzdWx0Lm9rKCdjaGFyYWN0ZXJzKTtcbiAgICBgYGBcblxuICAgIE5vdGUgdGhhdCB5b3UgbWF5IGV4cGxpY2l0bHkgcGFzcyBgVW5pdGAgdG8gdGhlIGBPa2AgY29uc3RydWN0b3IgdG8gY3JlYXRlXG4gICAgYSBgUmVzdWx0PFVuaXQsIEU+YC4gSG93ZXZlciwgeW91IG1heSAqbm90KiBjYWxsIHRoZSBgT2tgIGNvbnN0cnVjdG9yIHdpdGhcbiAgICBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdG8gZ2V0IHRoYXQgcmVzdWx0ICh0aGUgdHlwZSBzeXN0ZW0gd29uJ3QgYWxsb3cgeW91IHRvXG4gICAgY29uc3RydWN0IGl0IHRoYXQgd2F5KS4gSW5zdGVhZCwgZm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIHNpbXBseSBjYWxsXG4gICAgYFJlc3VsdC5vaygpYCwgd2hpY2ggd2lsbCBjb25zdHJ1Y3QgdGhlIHR5cGUgY29ycmVjdGx5LlxuXG4gICAgQHBhcmFtIHZhbHVlXG4gICAgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgUmVzdWx0Lk9rYC5cblxuICAgIE5vdGU6IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGFsbG93ZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIHNvIHRoYXQgdGhlXG4gICAgY29uc3RydWN0b3IgbWF5IGB0aHJvd2Agb24gdGhvc2UgcmF0aGVyIHRoYW4gY29uc3RydWN0aW5nIGEgdHlwZSBsaWtlXG4gICAgYFJlc3VsdDx1bmRlZmluZWQ+YC5cblxuICAgIEB0aHJvd3MgSWYgeW91IHBhc3MgYG51bGxgLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWU/OiBUIHwgbnVsbCkge1xuICAgIGlmIChpc1ZvaWQodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUcmllZCB0byBjb25zdHJ1Y3QgYE9rYCB3aXRoIGBudWxsYCBvciBgdW5kZWZpbmVkYC4gTWF5YmUgeW91IHdhbnQgYE1heWJlLk5vdGhpbmdgPydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5pc09rYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2lzb2spICovXG4gIGlzT2sodGhpczogUmVzdWx0PFQsIEU+KTogdGhpcyBpcyBPazxULCBFPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmlzRXJyYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2lzZXJyKSAqL1xuICBpc0Vycih0aGlzOiBSZXN1bHQ8VCwgRT4pOiB0aGlzIGlzIEVycjxULCBFPiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtYXBGbjogKHQ6IFQpID0+IFUpOiBSZXN1bHQ8VSwgRT4ge1xuICAgIHJldHVybiBtYXAobWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBPcmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNtYXBvcikgKi9cbiAgbWFwT3I8VT4odGhpczogUmVzdWx0PFQsIEU+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPcihvclUsIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hcG9yZWxzZSkgKi9cbiAgbWFwT3JFbHNlPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JFbHNlRm46IChlcnI6IEUpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPckVsc2Uob3JFbHNlRm4sIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWF0Y2hgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWF0Y2gpICovXG4gIG1hdGNoPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgbWF0Y2hlcjogTWF0Y2hlcjxULCBFLCBVPik6IFUge1xuICAgIHJldHVybiBtYXRjaChtYXRjaGVyLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWFwRXJyYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hcGVycikgKi9cbiAgbWFwRXJyPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgbWFwRXJyRm46IChlOiBFKSA9PiBGKTogUmVzdWx0PFQsIEY+IHtcbiAgICByZXR1cm4gbWFwRXJyKG1hcEVyckZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQub3JgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjb3IpICovXG4gIG9yPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JSZXN1bHQ6IFJlc3VsdDxULCBGPik6IFJlc3VsdDxULCBGPiB7XG4gICAgcmV0dXJuIG9yKG9yUmVzdWx0LCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQub3JFbHNlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI29yZWxzZSkgKi9cbiAgb3JFbHNlPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JFbHNlRm46IChlcnI6IEUpID0+IFJlc3VsdDxULCBGPik6IFJlc3VsdDxULCBGPiB7XG4gICAgcmV0dXJuIG9yRWxzZShvckVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmFuZGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNhbmQpICovXG4gIGFuZDxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG1BbmQ6IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgcmV0dXJuIGFuZChtQW5kLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuYW5kVGhlbmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNhbmR0aGVuKSAqL1xuICBhbmRUaGVuPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgYW5kVGhlbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICByZXR1cm4gYW5kVGhlbihhbmRUaGVuRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5jaGFpbmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNjaGFpbikgKi9cbiAgY2hhaW48VT4odGhpczogUmVzdWx0PFQsIEU+LCBjaGFpbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICByZXR1cm4gY2hhaW4oY2hhaW5GbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmZsYXRNYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjZmxhdG1hcCkgKi9cbiAgZmxhdE1hcDxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIGZsYXRNYXBGbjogKHQ6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgcmV0dXJuIGZsYXRNYXAoZmxhdE1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQudW53cmFwYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vud3JhcCkgKi9cbiAgdW5zYWZlbHlVbndyYXAoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcEVycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXBlcnIpICovXG4gIHVuc2FmZWx5VW53cmFwRXJyKCk6IG5ldmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGB1bnNhZmVseVVud3JhcEVycmAgYW4gYE9rYCcpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC51bndyYXBPcmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXBvcikgKi9cbiAgdW53cmFwT3IodGhpczogUmVzdWx0PFQsIEU+LCBkZWZhdWx0VmFsdWU6IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3IoZGVmYXVsdFZhbHVlLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQudW53cmFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vud3JhcE9yRWxzZSkgKi9cbiAgdW53cmFwT3JFbHNlKHRoaXM6IFJlc3VsdDxULCBFPiwgZWxzZUZuOiAoZXJyb3I6IEUpID0+IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3JFbHNlKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnRvTWF5YmVgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjdG9tYXliZSkgKi9cbiAgdG9NYXliZSh0aGlzOiBSZXN1bHQ8VCwgRT4pOiBNYXliZTxUPiB7XG4gICAgcmV0dXJuIHRvTWF5YmUodGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnRvU3RyaW5nYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Rvc3RyaW5nKSAqL1xuICB0b1N0cmluZyh0aGlzOiBSZXN1bHQ8VCwgRT4pOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuZXF1YWxzYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2VxdWFscykgKi9cbiAgZXF1YWxzKHRoaXM6IFJlc3VsdDxULCBFPiwgY29tcGFyaXNvbjogUmVzdWx0PFQsIEU+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVxdWFscyhjb21wYXJpc29uLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjYXApICovXG4gIGFwPEEsIEI+KHRoaXM6IFJlc3VsdDwoYTogQSkgPT4gQiwgRT4sIHI6IFJlc3VsdDxBLCBFPik6IFJlc3VsdDxCLCBFPiB7XG4gICAgcmV0dXJuIGFwKHRoaXMsIHIpO1xuICB9XG59XG5cbi8qKlxuICBBbiBgRXJyYCBpbnN0YW5jZSBpcyB0aGUgKmZhaWx1cmUqIHZhcmlhbnQgaW5zdGFuY2Ugb2YgdGhlXG4gIFtgUmVzdWx0YF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Jlc3VsdCkgdHlwZSwgcmVwcmVzZW50aW5nIGEgZmFpbHVyZVxuICBvdXRjb21lIGZyb20gYW4gb3BlcmF0aW9uIHdoaWNoIG1heSBmYWlsLiBGb3IgYSBmdWxsIGRpc2N1c3Npb24sIHNlZSBbdGhlXG4gIG1vZHVsZSBkb2NzXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSB3aGljaCB3b3VsZCBiZSB3cmFwcGVkIGluIGFuIGBPa2AgdmFyaWFudCBvZiBgUmVzdWx0YC5cbiAgQHR5cGVwYXJhbSBFIFRoZSB0eXBlIHdyYXBwZWQgaW4gdGhpcyBgRXJyYCB2YXJpYW50IG9mIGBSZXN1bHRgLlxuICAqL1xuZXhwb3J0IGNsYXNzIEVycjxULCBFPiBpbXBsZW1lbnRzIFJlc3VsdFNoYXBlPFQsIEU+IHtcbiAgLyoqXG4gICAgVW53cmFwIHRoZSBjb250YWluZWQgZXJyb3IgLiBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZnVuY3Rpb25hbCBpZGlvbXMuXG5cbiAgICBBIGNvbW1vbiBzY2VuYXJpbyB3aGVyZSB5b3UgbWlnaHQgd2FudCB0byB1c2UgdGhpcyBpcyBpbiBhIHBpcGVsaW5lIG9mXG4gICAgZnVuY3Rpb25zOlxuXG4gICAgYGBgdHNcbiAgICBpbXBvcnQgUmVzdWx0LCB7IE9rIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG5cbiAgICBmdW5jdGlvbiBnZXRNZXNzYWdlcyhyZXN1bHRzOiBBcnJheTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+KTogQXJyYXk8bnVtYmVyPiB7XG4gICAgICByZXR1cm4gbWF5YmVTdHJpbmdzXG4gICAgICAgIC5maWx0ZXIoUmVzdWx0LmlzRXJyKVxuICAgICAgICAubWFwKEVyci51bndyYXBFcnIpXG4gICAgICAgIC5tYXAoZSA9PiBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBgYGBcbiAgICovXG4gIHN0YXRpYyB1bndyYXBFcnI8Rj4odGhlRXJyOiBFcnI8RiwgYW55Pik6IEYge1xuICAgIHJldHVybiB0aGVFcnIuZXJyb3I7XG4gIH1cblxuICAvKiogYEVycmAgaXMgYWx3YXlzIFtgVmFyaWFudC5FcnJgXSguLi9lbnVtcy9fcmVzdWx0Xy52YXJpYW50I2VycikuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQuRXJyID0gVmFyaWFudC5FcnI7XG5cbiAgLyoqIFRoZSB3cmFwcGVkIGVycm9yIHZhbHVlLiAqL1xuICByZWFkb25seSBlcnJvcjogRTtcblxuICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYFJlc3VsdC5FcnJgIHdpdGggYG5ld2AuXG5cbiAgICBOb3RlOiBXaGlsZSB5b3UgKm1heSogY3JlYXRlIHRoZSBgUmVzdWx0YCB0eXBlIHZpYSBub3JtYWxcbiAgICBKYXZhU2NyaXB0IGNsYXNzIGNvbnN0cnVjdGlvbiwgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB0aGUgZnVuY3Rpb25hbFxuICAgIHN0eWxlIGZvciB3aGljaCB0aGUgbGlicmFyeSBpcyBpbnRlbmRlZC4gSW5zdGVhZCwgdXNlIFtgUmVzdWx0LmVycmBdLlxuXG4gICAgW2BSZXN1bHQuZXJyYF06IC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNlcnJcblxuICAgIGBgYHRzXG4gICAgLy8gQXZvaWQ6XG4gICAgY29uc3QgYW5FcnIgPSBuZXcgUmVzdWx0LkVycignYWxhcywgZmFpbHVyZScpO1xuXG4gICAgLy8gUHJlZmVyOlxuICAgIGNvbnN0IGFuRXJyID0gUmVzdWx0LmVycignYWxhcywgZmFpbHVyZScpO1xuICAgIGBgYFxuXG4gICAgTm90ZSB0aGF0IHlvdSBtYXkgZXhwbGljaXRseSBwYXNzIGBVbml0YCB0byB0aGUgYEVycmAgY29uc3RydWN0b3IgdG8gY3JlYXRlXG4gICAgYSBgUmVzdWx0PFQsIFVuaXQ+YC4gSG93ZXZlciwgeW91IG1heSAqbm90KiBjYWxsIHRoZSBgRXJyYCBjb25zdHJ1Y3RvciB3aXRoXG4gICAgYG51bGxgIG9yIGB1bmRlZmluZWRgIHRvIGdldCB0aGF0IHJlc3VsdCAodGhlIHR5cGUgc3lzdGVtIHdvbid0IGFsbG93IHlvdSB0b1xuICAgIGNvbnN0cnVjdCBpdCB0aGF0IHdheSkuIEluc3RlYWQsIGZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBzaW1wbHkgY2FsbFxuICAgIGBSZXN1bHQuZXJyKClgLCB3aGljaCB3aWxsIGNvbnN0cnVjdCB0aGUgdHlwZSBjb3JyZWN0bHkuXG5cbiAgICBAcGFyYW0gZXJyb3JcbiAgICBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBSZXN1bHQuRXJyYC5cblxuICAgIGBOb3RlOiBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGFsbG93ZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIHNvIHRoYXQgdGhlXG4gICAgY29uc3RydWN0b3IgbWF5IGB0aHJvd2Agb24gdGhvc2UgcmF0aGVyIHRoYW4gY29uc3RydWN0aW5nIGEgdHlwZSBsaWtlXG4gICAgYFJlc3VsdDxudW1iZXIsIHVuZGVmaW5lZD5gLlxuXG4gICAgQHRocm93cyBJZiB5b3UgcGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlcnJvcjogRSB8IG51bGwpIHtcbiAgICBpZiAoaXNWb2lkKGVycm9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVHJpZWQgdG8gY29uc3RydWN0IGBFcnJgIHdpdGggYG51bGxgIG9yIGB1bmRlZmluZWRgLiBNYXliZSB5b3Ugd2FudCBgTWF5YmUuTm90aGluZ2A/J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmlzT2tgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjaXNvaykgKi9cbiAgaXNPayh0aGlzOiBSZXN1bHQ8VCwgRT4pOiB0aGlzIGlzIE9rPFQsIEU+IHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmlzRXJyYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2lzZXJyKSAqL1xuICBpc0Vycih0aGlzOiBSZXN1bHQ8VCwgRT4pOiB0aGlzIGlzIEVycjxULCBFPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm1hcGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNtYXApICovXG4gIG1hcDxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG1hcEZuOiAodDogVCkgPT4gVSk6IFJlc3VsdDxVLCBFPiB7XG4gICAgcmV0dXJuIG1hcChtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm1hcE9yYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hcG9yKSAqL1xuICBtYXBPcjxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG9yVTogVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVSB7XG4gICAgcmV0dXJuIG1hcE9yKG9yVSwgbWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWFwb3JlbHNlKSAqL1xuICBtYXBPckVsc2U8VT4odGhpczogUmVzdWx0PFQsIEU+LCBvckVsc2VGbjogKGVycjogRSkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVSB7XG4gICAgcmV0dXJuIG1hcE9yRWxzZShvckVsc2VGbiwgbWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXRjaGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNtYXRjaCkgKi9cbiAgbWF0Y2g8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtYXRjaE9iajogTWF0Y2hlcjxULCBFLCBVPik6IFUge1xuICAgIHJldHVybiBtYXRjaChtYXRjaE9iaiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm1hcEVycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNtYXBlcnIpICovXG4gIG1hcEVycjxGPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG1hcEVyckZuOiAoZTogRSkgPT4gRik6IFJlc3VsdDxULCBGPiB7XG4gICAgcmV0dXJuIG1hcEVycihtYXBFcnJGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm9yYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI29yKSAqL1xuICBvcjxGPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG9yUmVzdWx0OiBSZXN1bHQ8VCwgRj4pOiBSZXN1bHQ8VCwgRj4ge1xuICAgIHJldHVybiBvcihvclJlc3VsdCwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm9yRWxzZWBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNvcmVsc2UpICovXG4gIG9yRWxzZTxGPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG9yRWxzZUZuOiAoZXJyOiBFKSA9PiBSZXN1bHQ8VCwgRj4pOiBSZXN1bHQ8VCwgRj4ge1xuICAgIHJldHVybiBvckVsc2Uob3JFbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5hbmRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjYW5kKSAqL1xuICBhbmQ8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtQW5kOiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT4ge1xuICAgIHJldHVybiBhbmQobUFuZCwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmFuZFRoZW5gXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjYW5kdGhlbikgKi9cbiAgYW5kVGhlbjxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIGFuZFRoZW5GbjogKHQ6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgcmV0dXJuIGFuZFRoZW4oYW5kVGhlbkZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuY2hhaW5gXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjY2hhaW4pICovXG4gIGNoYWluPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgY2hhaW5GbjogKHQ6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgcmV0dXJuIHRoaXMuYW5kVGhlbihjaGFpbkZuKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuZmxhdE1hcGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNmbGF0bWFwKSAqL1xuICBmbGF0TWFwPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgZmxhdE1hcEZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICByZXR1cm4gdGhpcy5hbmRUaGVuKGZsYXRNYXBGbik7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVuc2FmZWx5VW53cmFwYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vuc2FmZWx5dW53cmFwKSAqL1xuICB1bnNhZmVseVVud3JhcCgpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBgdW5zYWZlbHlVbndyYXAgYW4gRXJyYCcpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC51bnNhZmVseVVud3JhcEVycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bnNhZmVseXVud3JhcGVycikgKi9cbiAgdW5zYWZlbHlVbndyYXBFcnIoKTogRSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3I7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcE9yYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vud3JhcG9yKSAqL1xuICB1bndyYXBPcih0aGlzOiBSZXN1bHQ8VCwgRT4sIGRlZmF1bHRWYWx1ZTogVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPcihkZWZhdWx0VmFsdWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC51bndyYXBPckVsc2VgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjdW53cmFwb3JlbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogUmVzdWx0PFQsIEU+LCBlbHNlRm46IChlcnJvcjogRSkgPT4gVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPckVsc2UoZWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQudG9NYXliZWBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN0b21heWJlKSAqL1xuICB0b01heWJlKHRoaXM6IFJlc3VsdDxULCBFPik6IE1heWJlPFQ+IHtcbiAgICByZXR1cm4gdG9NYXliZSh0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQudG9TdHJpbmdgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjdG9zdHJpbmcpICovXG4gIHRvU3RyaW5nKHRoaXM6IFJlc3VsdDxULCBFPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5lcXVhbHNgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjZXF1YWxzKSAqL1xuICBlcXVhbHModGhpczogUmVzdWx0PFQsIEU+LCBjb21wYXJpc29uOiBSZXN1bHQ8VCwgRT4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXF1YWxzKGNvbXBhcmlzb24sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5hcGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNhcCkgKi9cbiAgYXA8QSwgQj4odGhpczogUmVzdWx0PChhOiBBKSA9PiBCLCBFPiwgcjogUmVzdWx0PEEsIEU+KTogUmVzdWx0PEIsIEU+IHtcbiAgICByZXR1cm4gYXAodGhpcywgcik7XG4gIH1cbn1cblxuLyoqXG4gIElzIHRoaXMgYFJlc3VsdGAgYW4gYE9rYCBpbnN0YW5jZT9cblxuICBJbiBUeXBlU2NyaXB0LCBuYXJyb3dzIHRoZSB0eXBlIGZyb20gYFJlc3VsdDxULCBFPmAgdG8gYE9rPFQsIEU+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2s8VCwgRT4ocmVzdWx0OiBSZXN1bHQ8VCwgRT4pOiByZXN1bHQgaXMgT2s8VCwgRT4ge1xuICByZXR1cm4gcmVzdWx0LnZhcmlhbnQgPT09IFZhcmlhbnQuT2s7XG59XG5cbi8qKlxuICBJcyB0aGlzIGBSZXN1bHRgIGFuIGBFcnJgIGluc3RhbmNlP1xuXG4gIEluIFR5cGVTY3JpcHQsIG5hcnJvd3MgdGhlIHR5cGUgZnJvbSBgUmVzdWx0PFQsIEU+YCB0byBgRXJyPFQsIEU+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXJyPFQsIEU+KHJlc3VsdDogUmVzdWx0PFQsIEU+KTogcmVzdWx0IGlzIEVycjxULCBFPiB7XG4gIHJldHVybiByZXN1bHQudmFyaWFudCA9PT0gVmFyaWFudC5FcnI7XG59XG5cbi8qKlxuICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYFJlc3VsdC5Pa2AuXG5cbiAgSWYgeW91IG5lZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpYyB0eXBlIChhcyB5b3UgZG8gd2hlbmV2ZXIgeW91XG4gIGFyZSBub3QgY29uc3RydWN0aW5nIGltbWVkaWF0ZWx5IGZvciBhIGZ1bmN0aW9uIHJldHVybiBvciBhcyBhbiBhcmd1bWVudCB0byBhXG4gIGZ1bmN0aW9uKSwgeW91IGNhbiB1c2UgYSB0eXBlIHBhcmFtZXRlcjpcblxuICBgYGB0c1xuICBjb25zdCB5YXlOdW1iZXIgPSBSZXN1bHQub2s8bnVtYmVyLCBzdHJpbmc+KDEyKTtcbiAgYGBgXG5cbiAgTm90ZTogYG51bGxgIGlzIGFsbG93ZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIHNvIHRoYXQgc28gdGhhdCB0aGUgZnVuY3Rpb25cbiAgbWF5IGJlIHVzZWQgdG8gIGB0aHJvd2Agb24gcGFzc2luZyBgbnVsbGAgcmF0aGVyIHRoYW4gY29uc3RydWN0aW5nIGEgdHlwZSBsaWtlXG4gIGBSZXN1bHQ8bnVsbCwgc3RyaW5nPmAuIGB1bmRlZmluZWRgIGlzIGFsbG93ZWQgYXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yXG4gIGNvbnN0cnVjdGluZyBhIGBSZXN1bHQ8VW5pdCwgRT5gLlxuXG4gIGBgYHRzXG4gIGNvbnN0IG5vcm1hbFJlc3VsdCA9IFJlc3VsdC5vazxudW1iZXIsIHN0cmluZz4oNDIpO1xuICBjb25zdCBleHBsaWNpdFVuaXQgPSBSZXN1bHQub2s8VW5pdCwgc3RyaW5nPihVbml0KTtcbiAgY29uc3QgaW1wbGljaXRVbml0ID0gUmVzdWx0Lm9rPFVuaXQsIHN0cmluZz4oKTtcbiAgYGBgXG5cbiAgSW4gdGhlIGNvbnRleHQgb2YgYW4gaW1tZWRpYXRlIGZ1bmN0aW9uIHJldHVybiwgb3IgYW4gYXJyb3cgZnVuY3Rpb24gd2l0aCBhXG4gIHNpbmdsZSBleHByZXNzaW9uIHZhbHVlLCB5b3UgZG8gbm90IGhhdmUgdG8gc3BlY2lmeSB0aGUgdHlwZXMsIHNvIHRoaXMgY2FuIGJlXG4gIHF1aXRlIGNvbnZlbmllbnQuXG5cbiAgYGBgdHNcbiAgdHlwZSBTb21lRGF0YSA9IHtcbiAgICAvLy4uLlxuICB9O1xuXG4gIGNvbnN0IGlzVmFsaWQgPSAoZGF0YTogU29tZURhdGEpOiBib29sZWFuID0+IHtcbiAgICAvLyB0cnVlIG9yIGZhbHNlLi4uXG4gIH1cblxuICBjb25zdCBhcnJvd1ZhbGlkYXRlID0gKGRhdGE6IFNvbWVEYXRhKTogUmVzdWx0PFVuaXQsIHN0cmluZz4gPT5cbiAgICBpc1ZhbGlkKGRhdGEpID8gUmVzdWx0Lm9rKCkgOiBSZXN1bHQuZXJyKCdzb21ldGhpbmcgd2FzIHdyb25nIScpO1xuXG4gIGZ1bmN0aW9uIGZuVmFsaWRhdGUoZGF0YTogc29tZURhdGEpOiBSZXN1bHQ8VW5pdCwgc3RyaW5nPiB7XG4gICAgcmV0dXJuIGlzVmFsaWQoZGF0YSkgPyBSZXN1bHQub2soKSA6IFJlc3VsdC5lcnIoJ3NvbWV0aGluZyB3YXMgd3JvbmcnKTtcbiAgfVxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIGl0ZW0gY29udGFpbmVkIGluIHRoZSBgUmVzdWx0YC5cbiAgQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYFJlc3VsdC5Pa2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvazxULCBFPigpOiBSZXN1bHQ8VW5pdCwgRT47XG5leHBvcnQgZnVuY3Rpb24gb2s8VCwgRT4odmFsdWU6IFQpOiBSZXN1bHQ8VCwgRT47XG5leHBvcnQgZnVuY3Rpb24gb2s8VCwgRT4odmFsdWU/OiBUKTogUmVzdWx0PFVuaXQsIEU+IHwgUmVzdWx0PFQsIEU+IHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBuZXcgT2soVW5pdCkgOiBuZXcgT2sodmFsdWUpO1xufVxuXG4vKiogYFJlc3VsdC5vZmAgaXMgYW4gYWxpYXMgZm9yIGBSZXN1bHQub2tgLiAqL1xuZXhwb3J0IGNvbnN0IG9mID0gb2s7XG5cbi8qKlxuICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYFJlc3VsdC5FcnJvcmAuXG5cbiAgSWYgeW91IG5lZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpYyB0eXBlIChhcyB5b3UgZG8gd2hlbmV2ZXIgeW91XG4gIGFyZSBub3QgY29uc3RydWN0aW5nIGltbWVkaWF0ZWx5IGZvciBhIGZ1bmN0aW9uIHJldHVybiBvciBhcyBhbiBhcmd1bWVudCB0byBhXG4gIGZ1bmN0aW9uKSwgeW91IGNhbiB1c2UgYSB0eXBlIHBhcmFtZXRlcjpcblxuICBgYGB0c1xuICBjb25zdCBub3RTdHJpbmcgPSBSZXN1bHQuZXJyPG51bWJlciwgc3RyaW5nPignc29tZXRoaW5nIHdlbnQgd3JvbmcnKTtcbiAgYGBgXG5cbiAgTm90ZTogYG51bGxgIGlzIGFsbG93ZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIHNvIHRoYXQgc28gdGhhdCB0aGUgZnVuY3Rpb25cbiAgbWF5IGJlIHVzZWQgdG8gIGB0aHJvd2Agb24gcGFzc2luZyBgbnVsbGAgcmF0aGVyIHRoYW4gY29uc3RydWN0aW5nIGEgdHlwZSBsaWtlXG4gIGBSZXN1bHQ8bnVsbCwgc3RyaW5nPmAuIGB1bmRlZmluZWRgIGlzIGFsbG93ZWQgYXMgYSBjb252ZW5pZW5jZSBtZXRob2QgZm9yXG4gIGNvbnN0cnVjdGluZyBhIGBSZXN1bHQ8VW5pdCwgRT5gLlxuXG4gIGBgYHRzXG4gIGNvbnN0IG5vcm1hbFJlc3VsdCA9IFJlc3VsdC5lcnI8bnVtYmVyLCBzdHJpbmc+KCdvaCBubycpO1xuICBjb25zdCBleHBsaWNpdFVuaXQgPSBSZXN1bHQuZXJyPG51bWJlciwgVW5pdD4oVW5pdCk7XG4gIGNvbnN0IGltcGxpY2l0VW5pdCA9IFJlc3VsdC5lcnI8bnVtYmVyLCBVbml0PigpO1xuICBgYGBcblxuICBJbiB0aGUgY29udGV4dCBvZiBhbiBpbW1lZGlhdGUgZnVuY3Rpb24gcmV0dXJuLCBvciBhbiBhcnJvdyBmdW5jdGlvbiB3aXRoIGFcbiAgc2luZ2xlIGV4cHJlc3Npb24gdmFsdWUsIHlvdSBkbyBub3QgaGF2ZSB0byBzcGVjaWZ5IHRoZSB0eXBlcywgc28gdGhpcyBjYW4gYmVcbiAgcXVpdGUgY29udmVuaWVudC5cblxuICBgYGB0c1xuICB0eXBlIFNvbWVEYXRhID0ge1xuICAgIC8vLi4uXG4gIH07XG5cbiAgY29uc3QgaXNWYWxpZCA9IChkYXRhOiBTb21lRGF0YSk6IGJvb2xlYW4gPT4ge1xuICAgIC8vIHRydWUgb3IgZmFsc2UuLi5cbiAgfVxuXG4gIGNvbnN0IGFycm93VmFsaWRhdGUgPSAoZGF0YTogU29tZURhdGEpOiBSZXN1bHQ8bnVtYmVyLCBVbml0PiA9PlxuICAgIGlzVmFsaWQoZGF0YSkgPyBSZXN1bHQub2soNDIpIDogUmVzdWx0LmVycigpO1xuXG4gIGZ1bmN0aW9uIGZuVmFsaWRhdGUoZGF0YTogc29tZURhdGEpOiBSZXN1bHQ8bnVtYmVyLCBVbml0PiB7XG4gICAgcmV0dXJuIGlzVmFsaWQoZGF0YSkgPyBSZXN1bHQub2soNDIpIDogUmVzdWx0LmVycigpO1xuICB9XG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgaXRlbSBjb250YWluZWQgaW4gdGhlIGBSZXN1bHRgLlxuICBAcGFyYW0gRSBUaGUgZXJyb3IgdmFsdWUgdG8gd3JhcCBpbiBhIGBSZXN1bHQuRXJyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycjxULCBFPigpOiBSZXN1bHQ8VCwgVW5pdD47XG5leHBvcnQgZnVuY3Rpb24gZXJyPFQsIEU+KGVycm9yOiBFKTogUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIGVycjxULCBFPihlcnJvcj86IEUpOiBSZXN1bHQ8VCwgVW5pdD4gfCBSZXN1bHQ8VCwgRT4ge1xuICByZXR1cm4gaXNWb2lkKGVycm9yKSA/IG5ldyBFcnIoVW5pdCkgOiBuZXcgRXJyKGVycm9yKTtcbn1cblxuLyoqXG4gIE1hcCBvdmVyIGEgYFJlc3VsdGAgaW5zdGFuY2U6IGFwcGx5IHRoZSBmdW5jdGlvbiB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiB0aGVcbiAgaW5zdGFuY2UgaXMgYE9rYCwgYW5kIHJldHVybiB0aGUgd3JhcHBlZCBlcnJvciB2YWx1ZSB3cmFwcGVkIGFzIGEgbmV3IGBFcnJgIG9mXG4gIHRoZSBjb3JyZWN0IHR5cGUgKGBSZXN1bHQ8VSwgRT5gKSBpZiB0aGUgaW5zdGFuY2UgaXMgYEVycmAuXG5cbiAgYFJlc3VsdC5tYXBgIHdvcmtzIGEgbG90IGxpa2UgYEFycmF5LnByb3RvdHlwZS5tYXBgLCBidXQgd2l0aCBvbmUgaW1wb3J0YW50XG4gIGRpZmZlcmVuY2UuIEJvdGggYFJlc3VsdGAgYW5kIGBBcnJheWAgYXJlIGNvbnRhaW5lcnMgZm9yIG90aGVyIGtpbmRzIG9mIGl0ZW1zLFxuICBidXQgd2hlcmUgYEFycmF5LnByb3RvdHlwZS5tYXBgIGhhcyAwIHRvIF9uXyBpdGVtcywgYSBgUmVzdWx0YCBhbHdheXMgaGFzXG4gIGV4YWN0bHkgb25lIGl0ZW0sIHdoaWNoIGlzICplaXRoZXIqIGEgc3VjY2VzcyBvciBhbiBlcnJvciBpbnN0YW5jZS5cblxuICBXaGVyZSBgQXJyYXkucHJvdG90eXBlLm1hcGAgd2lsbCBhcHBseSB0aGUgbWFwcGluZyBmdW5jdGlvbiB0byBldmVyeSBpdGVtIGluXG4gIHRoZSBhcnJheSAoaWYgdGhlcmUgYXJlIGFueSksIGBSZXN1bHQubWFwYCB3aWxsIG9ubHkgYXBwbHkgdGhlIG1hcHBpbmdcbiAgZnVuY3Rpb24gdG8gdGhlIChzaW5nbGUpIGVsZW1lbnQgaWYgYW4gYE9rYCBpbnN0YW5jZSwgaWYgdGhlcmUgaXMgb25lLlxuXG4gIElmIHlvdSBoYXZlIG5vIGl0ZW1zIGluIGFuIGFycmF5IG9mXG4gIG51bWJlcnMgbmFtZWQgYGZvb2AgYW5kIGNhbGwgYGZvby5tYXAoeCA9PiB4ICsgMSlgLCB5b3UnbGwgc3RpbGwgc29tZSBoYXZlIGFuXG4gIGFycmF5IHdpdGggbm90aGluZyBpbiBpdC4gQnV0IGlmIHlvdSBoYXZlIGFueSBpdGVtcyBpbiB0aGUgYXJyYXkgKGBbMiwgM11gKSxcbiAgYW5kIHlvdSBjYWxsIGBmb28ubWFwKHggPT4geCArIDEpYCBvbiBpdCwgeW91J2xsIGdldCBhIG5ldyBhcnJheSB3aXRoIGVhY2ggb2ZcbiAgdGhvc2UgaXRlbXMgaW5zaWRlIHRoZSBhcnJheSBcImNvbnRhaW5lclwiIHRyYW5zZm9ybWVkIChgWzMsIDRdYCkuXG5cbiAgV2l0aCBgUmVzdWx0Lm1hcGAsIHRoZSBgRXJyYCB2YXJpYW50IGlzIHRyZWF0ZWQgKmJ5IHRoZSBgbWFwYCBmdW5jdGlvbioga2luZFxuICBvZiB0aGUgc2FtZSB3YXkgYXMgdGhlIGVtcHR5IGFycmF5IGNhc2U6IGl0J3MganVzdCBpZ25vcmVkLCBhbmQgeW91IGdldCBiYWNrIGFcbiAgbmV3IGBSZXN1bHRgIHRoYXQgaXMgc3RpbGwganVzdCB0aGUgc2FtZSBgRXJyYCBpbnN0YW5jZS4gQnV0IGlmIHlvdSBoYXZlIGFuXG4gIGBPa2AgdmFyaWFudCwgdGhlIG1hcCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIGl0LCBhbmQgeW91IGdldCBiYWNrIGEgbmV3XG4gIGBSZXN1bHRgIHdpdGggdGhlIHZhbHVlIHRyYW5zZm9ybWVkLCBhbmQgc3RpbGwgd3JhcHBlZCBpbiBhbiBgT2tgLlxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBpbXBvcnQgeyBvaywgZXJyLCBtYXAsIHRvU3RyaW5nIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG4gIGNvbnN0IGRvdWJsZSA9IG4gPT4gbiAqIDI7XG5cbiAgY29uc3QgYW5PayA9IG9rKDEyKTtcbiAgY29uc3QgbWFwcGVkT2sgPSBtYXAoZG91YmxlLCBhbk9rKTtcbiAgY29uc29sZS5sb2codG9TdHJpbmcobWFwcGVkT2spKTsgLy8gT2soMjQpXG5cbiAgY29uc3QgYW5FcnIgPSBlcnIoXCJub3RoaW5nIGhlcmUhXCIpO1xuICBjb25zdCBtYXBwZWRFcnIgPSBtYXAoZG91YmxlLCBhbkVycik7XG4gIGNvbnNvbGUubG9nKHRvU3RyaW5nKG1hcHBlZE9rKSk7IC8vIEVycihub3RoaW5nIGhlcmUhKVxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGFuIGBPa2AgaW5zdGFuY2UsIGFuZCB0YWtlbiBhc1xuICAgICAgICAgICAgICAgIHRoZSBhcmd1bWVudCB0byB0aGUgYG1hcEZuYC5cbiAgQHR5cGVwYXJhbSBVICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgbmV3IGBPa2AgaW5zdGFuY2UgYWZ0ZXJcbiAgICAgICAgICAgICAgICBhcHBseWluZyBgbWFwRm5gLCB0aGF0IGlzLCB0aGUgdHlwZSByZXR1cm5lZCBieSBgbWFwRm5gLlxuICBAdHlwZXBhcmFtIEUgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGFuIGBFcnJgIGluc3RhbmNlLlxuICBAcGFyYW0gbWFwRm4gIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0aGUgdmFsdWUgdG8gaWYgYHJlc3VsdGAgaXMgYE9rYC5cbiAgQHBhcmFtIHJlc3VsdCBUaGUgYFJlc3VsdGAgaW5zdGFuY2UgdG8gbWFwIG92ZXIuXG4gIEByZXR1cm5zICAgICAgQSBuZXcgYFJlc3VsdGAgd2l0aCB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBtYXBGbmAgdG8gdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgaW4gYW4gYE9rYCwgb3IgZWxzZSB0aGUgb3JpZ2luYWwgYEVycmAgdmFsdWUgd3JhcHBlZCBpbiB0aGUgbmV3XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVSwgRT4obWFwRm46ICh0OiBUKSA9PiBVLCByZXN1bHQ6IFJlc3VsdDxULCBFPik6IFJlc3VsdDxVLCBFPjtcbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVSwgRT4obWFwRm46ICh0OiBUKSA9PiBVKTogKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBSZXN1bHQ8VSwgRT47XG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFUsIEU+KFxuICBtYXBGbjogKHQ6IFQpID0+IFUsXG4gIHJlc3VsdD86IFJlc3VsdDxULCBFPlxuKTogUmVzdWx0PFUsIEU+IHwgKChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gUmVzdWx0PFUsIEU+KSB7XG4gIGNvbnN0IG9wID0gKHI6IFJlc3VsdDxULCBFPikgPT4gKGlzT2socikgPyBvayhtYXBGbihyLnZhbHVlKSkgOiByKSBhcyBSZXN1bHQ8VSwgRT47XG4gIHJldHVybiBjdXJyeTEob3AsIHJlc3VsdCk7XG59XG5cbi8qKlxuICBNYXAgb3ZlciBhIGBSZXN1bHRgIGluc3RhbmNlIGFzIGluIFtgbWFwYF0oI21hcCkgYW5kIGdldCBvdXQgdGhlIHZhbHVlXG4gIGlmIGByZXN1bHRgIGlzIGFuIGBPa2AsIG9yIHJldHVybiBhIGRlZmF1bHQgdmFsdWUgaWYgYHJlc3VsdGAgaXMgYW4gYEVycmAuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGltcG9ydCB7IG9rLCBlcnIsIG1hcE9yIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG5cbiAgY29uc3QgbGVuZ3RoID0gKHM6IHN0cmluZykgPT4gcy5sZW5ndGg7XG5cbiAgY29uc3QgYW5Pa1N0cmluZyA9IG9rKCdhIHN0cmluZycpO1xuICBjb25zdCB0aGVTdHJpbmdMZW5ndGggPSBtYXBPcigwLCBhbk9rU3RyaW5nKTtcbiAgY29uc29sZS5sb2codGhlU3RyaW5nTGVuZ3RoKTsgIC8vIDhcblxuICBjb25zdCBhbkVyciA9IGVycigndWggb2gnKTtcbiAgY29uc3QgYW5FcnJNYXBwZWQgPSBtYXBPcigwLCBhbkVycik7XG4gIGNvbnNvbGUubG9nKGFuRXJyTWFwcGVkKTsgIC8vIDBcbiAgYGBgXG5cbiAgQHBhcmFtIG9yVSBUaGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgYHJlc3VsdGAgaXMgYW4gYEVycmAuXG4gIEBwYXJhbSBtYXBGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdGhlIHZhbHVlIHRvIGlmIGByZXN1bHRgIGlzIGFuIGBPa2AuXG4gIEBwYXJhbSByZXN1bHQgVGhlIGBSZXN1bHRgIGluc3RhbmNlIHRvIG1hcCBvdmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT3I8VCwgVSwgRT4ob3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUsIHJlc3VsdDogUmVzdWx0PFQsIEU+KTogVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVLCBFPihvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVLCBFPihvclU6IFUpOiAobWFwRm46ICh0OiBUKSA9PiBVKSA9PiAocmVzdWx0OiBSZXN1bHQ8VCwgRT4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3I8VCwgVSwgRT4oXG4gIG9yVTogVSxcbiAgbWFwRm4/OiAodDogVCkgPT4gVSxcbiAgcmVzdWx0PzogUmVzdWx0PFQsIEU+XG4pOiBVIHwgKChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gVSkgfCAoKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBVKSB7XG4gIGZ1bmN0aW9uIGZ1bGxPcChmbjogKHQ6IFQpID0+IFUsIHI6IFJlc3VsdDxULCBFPik6IFUge1xuICAgIHJldHVybiBpc09rKHIpID8gZm4oci52YWx1ZSkgOiBvclU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVKTogKG1heWJlOiBSZXN1bHQ8VCwgRT4pID0+IFU7XG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUsIGN1cnJpZWRSZXN1bHQ6IFJlc3VsdDxULCBFPik6IFU7XG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChcbiAgICBmbjogKHQ6IFQpID0+IFUsXG4gICAgY3VycmllZFJlc3VsdD86IFJlc3VsdDxULCBFPlxuICApOiBVIHwgKChtYXliZTogUmVzdWx0PFQsIEU+KSA9PiBVKSB7XG4gICAgcmV0dXJuIGN1cnJpZWRSZXN1bHQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBmdWxsT3AoZm4sIGN1cnJpZWRSZXN1bHQpXG4gICAgICA6IChleHRyYUN1cnJpZWRSZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gZnVsbE9wKGZuLCBleHRyYUN1cnJpZWRSZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIG1hcEZuID09PSB1bmRlZmluZWRcbiAgICA/IHBhcnRpYWxPcFxuICAgIDogcmVzdWx0ID09PSB1bmRlZmluZWQgPyBwYXJ0aWFsT3AobWFwRm4pIDogcGFydGlhbE9wKG1hcEZuLCByZXN1bHQpO1xufVxuXG4vKipcbiAgTWFwIG92ZXIgYSBgUmVzdWx0YCBpbnN0YW5jZSBhcyBpbiBbYG1hcGBdKCNtYXApIGFuZCBnZXQgb3V0IHRoZSB2YWx1ZSBpZlxuICBgcmVzdWx0YCBpcyBgT2tgLCBvciBhcHBseSBhIGZ1bmN0aW9uIChgb3JFbHNlRm5gKSB0byB0aGUgdmFsdWUgd3JhcHBlZCBpblxuICB0aGUgYEVycmAgdG8gZ2V0IGEgZGVmYXVsdCB2YWx1ZS5cblxuICBMaWtlIFtgbWFwT3JgXSgjbWFwb3IpIGJ1dCB1c2luZyBhIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgZXJyb3IgaW50byBhXG4gIHVzYWJsZSB2YWx1ZSBpbnN0ZWFkIG9mIHNpbXBseSB1c2luZyBhIGRlZmF1bHQgdmFsdWUuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGltcG9ydCB7IG9rLCBlcnIsIG1hcE9yRWxzZSB9IGZyb20gJ3RydWUtbXl0aC9yZXN1bHQnO1xuXG4gIGNvbnN0IHN1bW1hcml6ZSA9IChzOiBzdHJpbmcpID0+IGBUaGUgcmVzcG9uc2Ugd2FzOiAnJHtzfSdgO1xuICBjb25zdCBnZXRSZWFzb24gPSAoZXJyOiB7IGNvZGU6IG51bWJlciwgcmVhc29uOiBzdHJpbmcgfSkgPT4gZXJyLnJlYXNvbjtcblxuICBjb25zdCBva1Jlc3BvbnNlID0gb2soXCJUaGluZ3MgYXJlIGdyYW5kIGhlcmUuXCIpO1xuICBjb25zdCBtYXBwZWRPa0FuZFVud3JhcHBlZCA9IG1hcE9yRWxzZShnZXRSZWFzb24sIHN1bW1hcml6ZSwgb2tSZXNwb25zZSk7XG4gIGNvbnNvbGUubG9nKG1hcHBlZE9rQW5kVW53cmFwcGVkKTsgIC8vIFRoZSByZXNwb25zZSB3YXM6ICdUaGluZ3MgYXJlIGdyYW5kIGhlcmUuJ1xuXG4gIGNvbnN0IGVyclJlc3BvbnNlID0gZXJyKHsgY29kZTogNTAwLCByZWFzb246ICdOb3RoaW5nIGF0IHRoaXMgZW5kcG9pbnQhJyB9KTtcbiAgY29uc3QgbWFwcGVkRXJyQW5kVW53cmFwcGVkID0gbWFwT3JFbHNlKGdldFJlYXNvbiwgc3VtbWFyaXplLCBlcnJSZXNwb25zZSk7XG4gIGNvbnNvbGUubG9nKG1hcHBlZEVyckFuZFVud3JhcHBlZCk7ICAvLyBOb3RoaW5nIGF0IHRoaXMgZW5kcG9pbnQhXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCBgT2tgIHZhbHVlLlxuICBAdHlwZXBhcmFtIFUgICAgVGhlIHR5cGUgb2YgdGhlIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGFwcGx5aW5nIGBtYXBGbmAgdG8gdGhlXG4gICAgICAgICAgICAgICAgICBgT2tgIHZhbHVlIG9yIGBvckVsc2VGbmAgdG8gdGhlIGBFcnJgIHZhbHVlLlxuICBAdHlwZXBhcmFtIEUgICAgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgYEVycmAgdmFsdWUuXG4gIEBwYXJhbSBvckVsc2VGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHdyYXBwZWQgYEVycmAgdmFsdWUgdG8gZ2V0IGFcbiAgICAgICAgICAgICAgICAgIHVzYWJsZSB2YWx1ZSBpZiBgcmVzdWx0YCBpcyBhbiBgRXJyYC5cbiAgQHBhcmFtIG1hcEZuICAgIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgd3JhcHBlZCBgT2tgIHZhbHVlIGlmIGByZXN1bHRgIGlzXG4gICAgICAgICAgICAgICAgICBhbiBgT2tgLlxuICBAcGFyYW0gcmVzdWx0ICAgVGhlIGBSZXN1bHRgIGluc3RhbmNlIHRvIG1hcCBvdmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwT3JFbHNlPFQsIFUsIEU+KFxuICBvckVsc2VGbjogKGVycjogRSkgPT4gVSxcbiAgbWFwRm46ICh0OiBUKSA9PiBVLFxuICByZXN1bHQ6IFJlc3VsdDxULCBFPlxuKTogVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVSwgRT4oXG4gIG9yRWxzZUZuOiAoZXJyOiBFKSA9PiBVLFxuICBtYXBGbjogKHQ6IFQpID0+IFVcbik6IChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVSwgRT4oXG4gIG9yRWxzZUZuOiAoZXJyOiBFKSA9PiBVXG4pOiAobWFwRm46ICh0OiBUKSA9PiBVKSA9PiAocmVzdWx0OiBSZXN1bHQ8VCwgRT4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3JFbHNlPFQsIFUsIEU+KFxuICBvckVsc2VGbjogKGVycjogRSkgPT4gVSxcbiAgbWFwRm4/OiAodDogVCkgPT4gVSxcbiAgcmVzdWx0PzogUmVzdWx0PFQsIEU+XG4pOiBVIHwgKChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gVSkgfCAoKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBVKSB7XG4gIGZ1bmN0aW9uIGZ1bGxPcChmbjogKHQ6IFQpID0+IFUsIHI6IFJlc3VsdDxULCBFPikge1xuICAgIHJldHVybiBpc09rKHIpID8gZm4oci52YWx1ZSkgOiBvckVsc2VGbihyLmVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUpOiAobWF5YmU6IFJlc3VsdDxULCBFPikgPT4gVTtcbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSwgY3VycmllZFJlc3VsdDogUmVzdWx0PFQsIEU+KTogVTtcbiAgZnVuY3Rpb24gcGFydGlhbE9wKFxuICAgIGZuOiAodDogVCkgPT4gVSxcbiAgICBjdXJyaWVkUmVzdWx0PzogUmVzdWx0PFQsIEU+XG4gICk6IFUgfCAoKG1heWJlOiBSZXN1bHQ8VCwgRT4pID0+IFUpIHtcbiAgICByZXR1cm4gY3VycmllZFJlc3VsdCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZ1bGxPcChmbiwgY3VycmllZFJlc3VsdClcbiAgICAgIDogKGV4dHJhQ3VycmllZFJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBmdWxsT3AoZm4sIGV4dHJhQ3VycmllZFJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gbWFwRm4gPT09IHVuZGVmaW5lZFxuICAgID8gcGFydGlhbE9wXG4gICAgOiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHBhcnRpYWxPcChtYXBGbikgOiBwYXJ0aWFsT3AobWFwRm4sIHJlc3VsdCk7XG59XG5cbi8qKlxuICBNYXAgb3ZlciBhIGBSZXN1bHRgLCBleGFjdGx5IGFzIGluIFtgbWFwYF0oI21hcCksIGJ1dCBvcGVyYXRpbmcgb24gdGhlIHZhbHVlXG4gIHdyYXBwZWQgaW4gYW4gYEVycmAgaW5zdGVhZCBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYE9rYC4gVGhpcyBpcyBoYW5keVxuICBmb3Igd2hlbiB5b3UgbmVlZCB0byBsaW5lIHVwIGEgYnVuY2ggb2YgZGlmZmVyZW50IHR5cGVzIG9mIGVycm9ycywgb3IgaWYgeW91XG4gIG5lZWQgYW4gZXJyb3Igb2Ygb25lIHNoYXBlIHRvIGJlIGluIGEgZGlmZmVyZW50IHNoYXBlIHRvIHVzZSBzb21ld2hlcmUgZWxzZSBpblxuICB5b3VyIGNvZGViYXNlLlxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBpbXBvcnQgeyBvaywgZXJyLCBtYXBFcnIsIHRvU3RyaW5nIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG5cbiAgY29uc3QgcmVhc29uID0gKGVycjogeyBjb2RlOiBudW1iZXIsIHJlYXNvbjogc3RyaW5nIH0pID0+IGVyci5yZWFzb247XG5cbiAgY29uc3QgYW5PayA9IG9rKDEyKTtcbiAgY29uc3QgbWFwcGVkT2sgPSBtYXBFcnIocmVhc29uLCBhbk9rKTtcbiAgY29uc29sZS5sb2codG9TdHJpbmcobWFwcGVkT2spKTsgIC8vIE9rKDEyKVxuXG4gIGNvbnN0IGFuRXJyID0gZXJyKHsgY29kZTogMTAxLCByZWFzb246ICdiYWQgZmlsZScgfSk7XG4gIGNvbnN0IG1hcHBlZEVyciA9IG1hcEVycihyZWFzb24sIGFuRXJyKTtcbiAgY29uc29sZS5sb2codG9TdHJpbmcobWFwcGVkRXJyKSk7ICAvLyBFcnIoYmFkIGZpbGUpXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCAgICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYE9rYCBvZiB0aGUgYFJlc3VsdGAuXG4gIEB0eXBlcGFyYW0gRSAgICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYEVycmAgb2YgdGhlIGBSZXN1bHRgLlxuICBAdHlwZXBhcmFtIEYgICAgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHdyYXBwZWQgaW4gdGhlIGBFcnJgIG9mIGEgbmV3IGBSZXN1bHRgLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuZWQgYnkgdGhlIGBtYXBFcnJGbmAuXG4gIEBwYXJhbSBtYXBFcnJGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIHZhbHVlIHdyYXBwZWQgaW4gYEVycmAgaWYgYHJlc3VsdGAgaXMgYW4gYEVycmAuXG4gIEBwYXJhbSByZXN1bHQgICBUaGUgYFJlc3VsdGAgaW5zdGFuY2UgdG8gbWFwIG92ZXIgYW4gZXJyb3IgY2FzZSBmb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBFcnI8VCwgRSwgRj4obWFwRXJyRm46IChlOiBFKSA9PiBGLCByZXN1bHQ6IFJlc3VsdDxULCBFPik6IFJlc3VsdDxULCBGPjtcbmV4cG9ydCBmdW5jdGlvbiBtYXBFcnI8VCwgRSwgRj4obWFwRXJyRm46IChlOiBFKSA9PiBGKTogKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBSZXN1bHQ8VCwgRj47XG5leHBvcnQgZnVuY3Rpb24gbWFwRXJyPFQsIEUsIEY+KFxuICBtYXBFcnJGbjogKGU6IEUpID0+IEYsXG4gIHJlc3VsdD86IFJlc3VsdDxULCBFPlxuKTogUmVzdWx0PFQsIEY+IHwgKChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gUmVzdWx0PFQsIEY+KSB7XG4gIGNvbnN0IG9wID0gKHI6IFJlc3VsdDxULCBFPikgPT4gKGlzT2socikgPyByIDogZXJyKG1hcEVyckZuKHIuZXJyb3IpKSkgYXMgUmVzdWx0PFQsIEY+O1xuICByZXR1cm4gY3VycnkxKG9wLCByZXN1bHQpO1xufVxuXG4vKipcbiAgWW91IGNhbiB0aGluayBvZiB0aGlzIGxpa2UgYSBzaG9ydC1jaXJjdWl0aW5nIGxvZ2ljYWwgXCJhbmRcIiBvcGVyYXRpb24gb24gYVxuICBgUmVzdWx0YCB0eXBlLiBJZiBgcmVzdWx0YCBpcyBgT2tgLCB0aGVuIHRoZSByZXN1bHQgaXMgdGhlIGBhbmRSZXN1bHRgLiBJZlxuICBgcmVzdWx0YCBpcyBgRXJyYCwgdGhlIHJlc3VsdCBpcyB0aGUgYEVycmAuXG5cbiAgVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhbm90aGVyIGBSZXN1bHRgIHZhbHVlIHlvdSB3YW50IHRvIHByb3ZpZGUgaWZcbiAgYW5kICpvbmx5IGlmKiB5b3UgaGF2ZSBhbiBgT2tgIOKAkyB0aGF0IGlzLCB3aGVuIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHlvdVxuICBgRXJyYCwgd2hhdGV2ZXIgZWxzZSB5b3UncmUgaGFuZGluZyBhIGBSZXN1bHRgIHRvICphbHNvKiBnZXRzIHRoYXQgYEVycmAuXG5cbiAgTm90aWNlIHRoYXQsIHVubGlrZSBpbiBbYG1hcGBdKCNtYXApIG9yIGl0cyB2YXJpYW50cywgdGhlIG9yaWdpbmFsIGByZXN1bHRgIGlzXG4gIG5vdCBpbnZvbHZlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIG5ldyBgUmVzdWx0YC5cblxuICAjIyMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgaW1wb3J0IHsgYW5kLCBvaywgZXJyLCB0b1N0cmluZyB9IGZyb20gJ3RydWUtbXl0aC9yZXN1bHQnO1xuXG4gIGNvbnN0IG9rQSA9IG9rKCdBJyk7XG4gIGNvbnN0IG9rQiA9IG9rKCdCJyk7XG4gIGNvbnN0IGFuRXJyID0gZXJyKHsgc286ICdiYWQnIH0pO1xuXG4gIGNvbnNvbGUubG9nKHRvU3RyaW5nKGFuZChva0IsIG9rQSkpKTsgIC8vIE9rKEIpXG4gIGNvbnNvbGUubG9nKHRvU3RyaW5nKGFuZChva0IsIGFuRXJyKSkpOyAgLy8gRXJyKFtvYmplY3QgT2JqZWN0XSlcbiAgY29uc29sZS5sb2codG9TdHJpbmcoYW5kKGFuRXJyLCBva0EpKSk7ICAvLyBFcnIoW29iamVjdCBPYmplY3RdKVxuICBjb25zb2xlLmxvZyh0b1N0cmluZyhhbmQoYW5FcnIsIGFuRXJyKSkpOyAgLy8gRXJyKFtvYmplY3QgT2JqZWN0XSlcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICAgICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYE9rYCBvZiB0aGUgYFJlc3VsdGAuXG4gIEB0eXBlcGFyYW0gVSAgICAgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHdyYXBwZWQgaW4gdGhlIGBPa2Agb2YgdGhlIGBhbmRSZXN1bHRgLFxuICAgICAgICAgICAgICAgICAgIGkuZS4gdGhlIHN1Y2Nlc3MgdHlwZSBvZiB0aGUgYFJlc3VsdGAgcHJlc2VudCBpZiB0aGUgY2hlY2tlZFxuICAgICAgICAgICAgICAgICAgIGBSZXN1bHRgIGlzIGBPa2AuXG4gIEB0eXBlcGFyYW0gRSAgICAgVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHdyYXBwZWQgaW4gdGhlIGBFcnJgIG9mIHRoZSBgUmVzdWx0YC5cbiAgQHBhcmFtIGFuZFJlc3VsdCBUaGUgYFJlc3VsdGAgaW5zdGFuY2UgdG8gcmV0dXJuIGlmIGByZXN1bHRgIGlzIGBFcnJgLlxuICBAcGFyYW0gcmVzdWx0ICAgIFRoZSBgUmVzdWx0YCBpbnN0YW5jZSB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuZDxULCBVLCBFPihhbmRSZXN1bHQ6IFJlc3VsdDxVLCBFPiwgcmVzdWx0OiBSZXN1bHQ8VCwgRT4pOiBSZXN1bHQ8VSwgRT47XG5leHBvcnQgZnVuY3Rpb24gYW5kPFQsIFUsIEU+KGFuZFJlc3VsdDogUmVzdWx0PFUsIEU+KTogKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBSZXN1bHQ8VSwgRT47XG5leHBvcnQgZnVuY3Rpb24gYW5kPFQsIFUsIEU+KFxuICBhbmRSZXN1bHQ6IFJlc3VsdDxVLCBFPixcbiAgcmVzdWx0PzogUmVzdWx0PFQsIEU+XG4pOiBSZXN1bHQ8VSwgRT4gfCAoKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBSZXN1bHQ8VSwgRT4pIHtcbiAgY29uc3Qgb3AgPSAocjogUmVzdWx0PFQsIEU+KSA9PiAoaXNPayhyKSA/IGFuZFJlc3VsdCA6IChyIGFzIEVycjxhbnksIEU+KSk7XG4gIHJldHVybiBjdXJyeTEob3AsIHJlc3VsdCk7XG59XG5cbi8qKlxuICBBcHBseSBhIGZ1bmN0aW9uIHRvIHRoZSB3cmFwcGVkIHZhbHVlIGlmIGBPa2AgYW5kIHJldHVybiBhIG5ldyBgT2tgXG4gIGNvbnRhaW5pbmcgdGhlIHJlc3VsdGluZyB2YWx1ZTsgb3IgaWYgaXQgaXMgYEVycmAgcmV0dXJuIGl0IHVubW9kaWZpZWQuXG5cbiAgVGhpcyBkaWZmZXJzIGZyb20gYG1hcGAgaW4gdGhhdCBgdGhlbkZuYCByZXR1cm5zIGFub3RoZXIgYFJlc3VsdGAuIFlvdSBjYW4gdXNlXG4gIGBhbmRUaGVuYCB0byBjb21iaW5lIHR3byBmdW5jdGlvbnMgd2hpY2ggKmJvdGgqIGNyZWF0ZSBhIGBSZXN1bHRgIGZyb20gYW5cbiAgdW53cmFwcGVkIHR5cGUuXG5cbiAgWW91IG1heSBmaW5kIHRoZSBgLnRoZW5gIG1ldGhvZCBvbiBhbiBFUzYgYFByb21pc2VgIGhlbHBmdWwgZm9yIGNvbXBhcmlzb246IGlmXG4gIHlvdSBoYXZlIGEgYFByb21pc2VgLCB5b3UgY2FuIHBhc3MgaXRzIGB0aGVuYCBtZXRob2QgYSBjYWxsYmFjayB3aGljaFxuICByZXR1cm5zIGFub3RoZXIgYFByb21pc2VgLCBhbmQgdGhlIHJlc3VsdCB3aWxsIG5vdCBiZSBhICpuZXN0ZWQqIHByb21pc2UsIGJ1dFxuICBhIHNpbmdsZSBgUHJvbWlzZWAuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgYFByb21pc2UjdGhlbmAgdW53cmFwcyAqYWxsKlxuICBsYXllcnMgdG8gb25seSBldmVyIHJldHVybiBhIHNpbmdsZSBgUHJvbWlzZWAgdmFsdWUsIHdoZXJlYXMgYFJlc3VsdC5hbmRUaGVuYFxuICB3aWxsIG5vdCB1bndyYXAgbmVzdGVkIGBSZXN1bHRgcy5cblxuICBUaGlzIGlzIGFsc28gY29tbW9ubHkga25vd24gYXMgKGFuZCB0aGVyZWZvcmUgYWxpYXNlZCBhcykgW2BmbGF0TWFwYF0gb3JcbiAgW2BjaGFpbmBdLiBJdCBpcyBzb21ldGltZXMgYWxzbyBrbm93biBhcyBgYmluZGAsIGJ1dCAqbm90KiBhbGlhc2VkIGFzIHN1Y2hcbiAgYmVjYXVzZSBbYGJpbmRgIGFscmVhZHkgbWVhbnMgc29tZXRoaW5nIGluIEphdmFTY3JpcHRdW2JpbmRdLlxuXG4gIFtgZmxhdE1hcGBdOiAjZmxhdG1hcFxuICBbYGNoYWluYF06ICNjaGFpblxuICBbYmluZF06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmRcblxuICAjIyMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgaW1wb3J0IHsgb2ssIGVyciwgYW5kVGhlbiwgdG9TdHJpbmcgfSBmcm9tICd0cnVlLW15dGgvcmVzdWx0JztcblxuICBjb25zdCB0b0xlbmd0aEFzUmVzdWx0ID0gKHM6IHN0cmluZykgPT4gb2socy5sZW5ndGgpO1xuXG4gIGNvbnN0IGFuT2sgPSBvaygnanVzdCBhIHN0cmluZycpO1xuICBjb25zdCBsZW5ndGhBc1Jlc3VsdCA9IGFuZFRoZW4odG9MZW5ndGhBc1Jlc3VsdCwgYW5Payk7XG4gIGNvbnNvbGUubG9nKHRvU3RyaW5nKGxlbmd0aEFzUmVzdWx0KSk7ICAvLyBPaygxMylcblxuICBjb25zdCBhbkVyciA9IGVycihbJ3Nyc2x5JywgJ3doYXRldmVyJ10pO1xuICBjb25zdCBub3RMZW5ndGhBc1Jlc3VsdCA9IGFuZFRoZW4odG9MZW5ndGhBc1Jlc3VsdCwgYW5FcnIpO1xuICBjb25zb2xlLmxvZyh0b1N0cmluZyhub3RMZW5ndGhBc1Jlc3VsdCkpOyAgLy8gRXJyKHNyc2x5LHdoYXRldmVyKVxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYE9rYCBvZiB0aGUgYFJlc3VsdGAuXG4gIEB0eXBlcGFyYW0gVSAgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIHRoZSBgT2tgIG9mIHRoZSBgUmVzdWx0YFxuICAgICAgICAgICAgICAgICByZXR1cm5lZCBieSB0aGUgYHRoZW5GbmAuXG4gIEB0eXBlcGFyYW0gRSAgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIHRoZSBgRXJyYCBvZiB0aGUgYFJlc3VsdGAuXG4gIEBwYXJhbSB0aGVuRm4gIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgd3JhcHBlZCBgVGAgaWYgYG1heWJlYCBpcyBgSnVzdGAuXG4gIEBwYXJhbSByZXN1bHQgIFRoZSBgTWF5YmVgIHRvIGV2YWx1YXRlIGFuZCBwb3NzaWJseSBhcHBseSBhIGZ1bmN0aW9uIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYW5kVGhlbjxULCBVLCBFPihcbiAgdGhlbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+LFxuICByZXN1bHQ6IFJlc3VsdDxULCBFPlxuKTogUmVzdWx0PFUsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIGFuZFRoZW48VCwgVSwgRT4oXG4gIHRoZW5GbjogKHQ6IFQpID0+IFJlc3VsdDxVLCBFPlxuKTogKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBSZXN1bHQ8VSwgRT47XG5leHBvcnQgZnVuY3Rpb24gYW5kVGhlbjxULCBVLCBFPihcbiAgdGhlbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+LFxuICByZXN1bHQ/OiBSZXN1bHQ8VCwgRT5cbik6IFJlc3VsdDxVLCBFPiB8ICgocmVzdWx0OiBSZXN1bHQ8VCwgRT4pID0+IFJlc3VsdDxVLCBFPikge1xuICBjb25zdCBvcCA9IChyOiBSZXN1bHQ8VCwgRT4pID0+IChpc09rKHIpID8gdGhlbkZuKHIudmFsdWUpIDogKHIgYXMgRXJyPGFueSwgRT4pKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgcmVzdWx0KTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYGFuZFRoZW5gXSgjYW5kdGhlbikuICovXG5leHBvcnQgY29uc3QgY2hhaW4gPSBhbmRUaGVuO1xuXG4vKiogQWxpYXMgZm9yIFtgYW5kVGhlbmBdKCNhbmR0aGVuKS4gKi9cbmV4cG9ydCBjb25zdCBmbGF0TWFwID0gYW5kVGhlbjtcblxuLyoqXG4gIFByb3ZpZGUgYSBmYWxsYmFjayBmb3IgYSBnaXZlbiBgUmVzdWx0YC4gQmVoYXZlcyBsaWtlIGEgbG9naWNhbCBgb3JgOiBpZiB0aGVcbiAgYHJlc3VsdGAgdmFsdWUgaXMgYW4gYE9rYCwgcmV0dXJucyB0aGF0IGByZXN1bHRgOyBvdGhlcndpc2UsIHJldHVybnMgdGhlXG4gIGBkZWZhdWx0UmVzdWx0YCB2YWx1ZS5cblxuICBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHNvbWV0aGluZyB3aGljaCB0YWtlcyBhXG4gIGBSZXN1bHRgIGFsd2F5cyBlbmRzIHVwIGdldHRpbmcgYW4gYE9rYCB2YXJpYW50LCBieSBzdXBwbHlpbmcgYSBkZWZhdWx0IHZhbHVlXG4gIGZvciB0aGUgY2FzZSB0aGF0IHlvdSBjdXJyZW50bHkgaGF2ZSBhbiBgRXJyYC5cblxuICBgYGB0c1xuICBpbXBvcnQgeyBvaywgZXJyLCBSZXN1bHQsIG9yIH0gZnJvbSAndHJ1ZS11dGlscy9yZXN1bHQnO1xuXG4gIGNvbnN0IG9rQSA9IG9rPHN0cmluZywgc3RyaW5nPignYScpO1xuICBjb25zdCBva0IgPSBvazxzdHJpbmcsIHN0cmluZz4oJ2InKTtcbiAgY29uc3QgYW5FcnIgPSBlcnI8c3RyaW5nLCBzdHJpbmc+KCc6d2F0OicpO1xuICBjb25zdCBhbm90aGVyRXJyID0gZXJyPHN0cmluZywgc3RyaW5nPignOmhlYWRkZXNrOicpO1xuXG4gIGNvbnNvbGUubG9nKG9yKG9rQiwgb2tBKS50b1N0cmluZygpKTsgIC8vIE9rKEEpXG4gIGNvbnNvbGUubG9nKG9yKGFuRXJyLCBva0EpLnRvU3RyaW5nKCkpOyAgLy8gT2soQSlcbiAgY29uc29sZS5sb2cob3Iob2tCLCBhbkVycikudG9TdHJpbmcoKSk7ICAvLyBPayhCKVxuICBjb25zb2xlLmxvZyhvcihhbm90aGVyRXJyLCBhbkVycikudG9TdHJpbmcoKSk7ICAvLyBFcnIoOmhlYWRkZXNrOilcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICAgICAgICAgIFRoZSB0eXBlIHdyYXBwZWQgaW4gdGhlIGBPa2AgY2FzZSBvZiBgcmVzdWx0YC5cbiAgQHR5cGVwYXJhbSBFICAgICAgICAgIFRoZSB0eXBlIHdyYXBwZWQgaW4gdGhlIGBFcnJgIGNhc2Ugb2YgYHJlc3VsdGAuXG4gIEB0eXBlcGFyYW0gRiAgICAgICAgICBUaGUgdHlwZSB3cmFwcGVkIGluIHRoZSBgRXJyYCBjYXNlIG9mIGBkZWZhdWx0UmVzdWx0YC5cbiAgQHBhcmFtIGRlZmF1bHRSZXN1bHQgIFRoZSBgUmVzdWx0YCB0byB1c2UgaWYgYHJlc3VsdGAgaXMgYW4gYEVycmAuXG4gIEBwYXJhbSByZXN1bHQgICAgICAgICBUaGUgYFJlc3VsdGAgaW5zdGFuY2UgdG8gY2hlY2suXG4gIEByZXR1cm5zICAgICAgICAgICAgICBgcmVzdWx0YCBpZiBpdCBpcyBhbiBgT2tgLCBvdGhlcndpc2UgYGRlZmF1bHRSZXN1bHRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3I8VCwgRSwgRj4oZGVmYXVsdFJlc3VsdDogUmVzdWx0PFQsIEY+LCByZXN1bHQ6IFJlc3VsdDxULCBFPik6IFJlc3VsdDxULCBGPjtcbmV4cG9ydCBmdW5jdGlvbiBvcjxULCBFLCBGPihkZWZhdWx0UmVzdWx0OiBSZXN1bHQ8VCwgRj4pOiAocmVzdWx0OiBSZXN1bHQ8VCwgRT4pID0+IFJlc3VsdDxULCBGPjtcbmV4cG9ydCBmdW5jdGlvbiBvcjxULCBFLCBGPihcbiAgZGVmYXVsdFJlc3VsdDogUmVzdWx0PFQsIEY+LFxuICByZXN1bHQ/OiBSZXN1bHQ8VCwgRT5cbik6IFJlc3VsdDxULCBGPiB8ICgocmVzdWx0OiBSZXN1bHQ8VCwgRT4pID0+IFJlc3VsdDxULCBGPikge1xuICBjb25zdCBvcCA9IChyOiBSZXN1bHQ8VCwgRT4pID0+IChpc09rKHIpID8gKHIgYXMgT2s8VCwgYW55PikgOiBkZWZhdWx0UmVzdWx0KTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgcmVzdWx0KTtcbn1cblxuLyoqXG4gIExpa2UgYG9yYCwgYnV0IHVzaW5nIGEgZnVuY3Rpb24gdG8gY29uc3RydWN0IHRoZSBhbHRlcm5hdGl2ZSBgUmVzdWx0YC5cblxuICBTb21ldGltZXMgeW91IG5lZWQgdG8gcGVyZm9ybSBhbiBvcGVyYXRpb24gdXNpbmcgb3RoZXIgZGF0YSBpbiB0aGUgZW52aXJvbm1lbnRcbiAgdG8gY29uc3RydWN0IHRoZSBmYWxsYmFjayB2YWx1ZS4gSW4gdGhlc2Ugc2l0dWF0aW9ucywgeW91IGNhbiBwYXNzIGEgZnVuY3Rpb25cbiAgKHdoaWNoIG1heSBiZSBhIGNsb3N1cmUpIGFzIHRoZSBgZWxzZUZuYCB0byBnZW5lcmF0ZSB0aGUgZmFsbGJhY2sgYFJlc3VsdDxUPmAuXG4gIEl0IGNhbiB0aGVuIHRyYW5zZm9ybSB0aGUgZGF0YSBpbiB0aGUgYEVycmAgdG8gc29tZXRoaW5nIHVzYWJsZSBhcyBhbiBgT2tgLCBvclxuICBnZW5lcmF0ZSBhIG5ldyBgRXJyYCBpbnN0YW5jZSBhcyBhcHByb3ByaWF0ZS5cblxuICBVc2VmdWwgZm9yIHRyYW5zZm9ybWluZyBmYWlsdXJlcyB0byB1c2FibGUgZGF0YS5cblxuICBAcGFyYW0gZWxzZUZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgY29udGVudHMgb2YgdGhlIGBFcnJgIGlmIGByZXN1bHRgXG4gICAgICAgICAgICAgICAgaXMgYW4gYEVycmAsIHRvIGNyZWF0ZSBhIG5ldyBgUmVzdWx0YC5cbiAgQHBhcmFtIHJlc3VsdCBUaGUgYFJlc3VsdGAgdG8gdXNlIGlmIGl0IGlzIGFuIGBPa2AuXG4gIEByZXR1cm5zICAgICAgVGhlIGByZXN1bHRgIGlmIGl0IGlzIGBPa2AsIG9yIHRoZSBgUmVzdWx0YCByZXR1cm5lZCBieSBgZWxzZUZuYFxuICAgICAgICAgICAgICAgIGlmIGByZXN1bHRgIGlzIGFuIGBFcnIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VCwgRSwgRj4oXG4gIGVsc2VGbjogKGVycjogRSkgPT4gUmVzdWx0PFQsIEY+LFxuICByZXN1bHQ6IFJlc3VsdDxULCBFPlxuKTogUmVzdWx0PFQsIEY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9yRWxzZTxULCBFLCBGPihcbiAgZWxzZUZuOiAoZXJyOiBFKSA9PiBSZXN1bHQ8VCwgRj5cbik6IChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gUmVzdWx0PFQsIEY+O1xuZXhwb3J0IGZ1bmN0aW9uIG9yRWxzZTxULCBFLCBGPihcbiAgZWxzZUZuOiAoZXJyOiBFKSA9PiBSZXN1bHQ8VCwgRj4sXG4gIHJlc3VsdD86IFJlc3VsdDxULCBFPlxuKTogUmVzdWx0PFQsIEY+IHwgKChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gUmVzdWx0PFQsIEY+KSB7XG4gIGNvbnN0IG9wID0gKHI6IFJlc3VsdDxULCBFPikgPT4gKGlzT2socikgPyAociBhcyBPazxULCBhbnk+KSA6IGVsc2VGbihyLnVuc2FmZWx5VW53cmFwRXJyKCkpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgcmVzdWx0KTtcbn1cblxuLyoqXG4gIEdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSBgUmVzdWx0YC5cblxuICBSZXR1cm5zIHRoZSBjb250ZW50IG9mIGFuIGBPa2AsIGJ1dCAqKnRocm93cyBpZiB0aGUgYFJlc3VsdGAgaXMgYEVycmAuKipcbiAgUHJlZmVyIHRvIHVzZSBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSBvciBbYHVud3JhcE9yRWxzZWBdKCN1bndyYXBvcmVsc2UpLlxuXG4gIEB0aHJvd3MgSWYgdGhlIGBSZXN1bHRgIGluc3RhbmNlIGlzIGBOb3RoaW5nYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZWx5VW53cmFwPFQsIEU+KHJlc3VsdDogUmVzdWx0PFQsIEU+KTogVCB7XG4gIHJldHVybiByZXN1bHQudW5zYWZlbHlVbndyYXAoKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYHVuc2FmZWx5VW53cmFwYF0oI3Vuc2FmZWx5dW53cmFwKSAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZWx5R2V0ID0gdW5zYWZlbHlVbndyYXA7XG5cbi8qKiBBbGlhcyBmb3IgW2B1bnNhZmVseVVud3JhcGBdKCN1bnNhZmVseXVud3JhcCkgKi9cbmV4cG9ydCBjb25zdCB1bnNhZmVHZXQgPSB1bnNhZmVseVVud3JhcDtcblxuLyoqXG4gIEdldCB0aGUgZXJyb3IgdmFsdWUgb3V0IG9mIHRoZSBbYFJlc3VsdGBdKCNyZXN1bHQpLlxuXG4gIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgYW4gYEVycmAsIGJ1dCAqKnRocm93cyBpZiB0aGUgYFJlc3VsdGAgaXMgYE9rYCoqLlxuICBQcmVmZXIgdG8gdXNlIFtgdW53cmFwT3JFbHNlYF0oI3Vud3JhcG9yZWxzZSkuXG5cbiAgQHBhcmFtIHJlc3VsdFxuICBAdGhyb3dzIEVycm9yIElmIHRoZSBgUmVzdWx0YCBpbnN0YW5jZSBpcyBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVseVVud3JhcEVycjxULCBFPihyZXN1bHQ6IFJlc3VsdDxULCBFPik6IEUge1xuICByZXR1cm4gcmVzdWx0LnVuc2FmZWx5VW53cmFwRXJyKCk7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2B1bnNhZmVseVVud3JhcEVycmBdKCN1bnNhZmVseXVud3JhcGVycikgKi9cbmV4cG9ydCBjb25zdCB1bnNhZmVseUdldEVyciA9IHVuc2FmZWx5VW53cmFwRXJyO1xuXG4vKipcbiAgU2FmZWx5IGdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSBgT2tgIHZhcmlhbnQgb2YgYSBbYFJlc3VsdGBdKCNyZXN1bHQpLlxuXG4gIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBnZXQgYSB2YWx1ZSBvdXQgb2YgYSBgUmVzdWx0YCBtb3N0IG9mIHRoZSB0aW1lLlxuXG4gIGBgYHRzXG4gIGltcG9ydCB7IG9rLCBlcnIsIHVud3JhcE9yIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG5cbiAgY29uc3QgYW5PayA9IG9rPG51bWJlciwgc3RyaW5nPigxMik7XG4gIGNvbnNvbGUubG9nKHVud3JhcE9yKDAsIGFuT2spKTsgIC8vIDEyXG5cbiAgY29uc3QgYW5FcnIgPSBlcnI8bnVtYmVyLCBzdHJpbmc+KCdub29vb28nKTtcbiAgY29uc29sZS5sb2codW53cmFwT3IoMCwgYW5FcnIpKTsgIC8vIDBcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICAgICAgICBUaGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYE9rYC5cbiAgQHR5cGVwYXJhbSBFICAgICAgICBUaGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYEVycmAuXG4gIEBwYXJhbSBkZWZhdWx0VmFsdWUgVGhlIHZhbHVlIHRvIHVzZSBpZiBgcmVzdWx0YCBpcyBhbiBgRXJyYC5cbiAgQHBhcmFtIHJlc3VsdCAgICAgICBUaGUgYFJlc3VsdGAgaW5zdGFuY2UgdG8gdW53cmFwIGlmIGl0IGlzIGFuIGBPa2AuXG4gIEByZXR1cm5zICAgICAgICAgICAgVGhlIGNvbnRlbnQgb2YgYHJlc3VsdGAgaWYgaXQgaXMgYW4gYE9rYCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgICAgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxULCBFPihkZWZhdWx0VmFsdWU6IFQsIHJlc3VsdDogUmVzdWx0PFQsIEU+KTogVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxULCBFPihkZWZhdWx0VmFsdWU6IFQpOiAocmVzdWx0OiBSZXN1bHQ8VCwgRT4pID0+IFQ7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3I8VCwgRT4oXG4gIGRlZmF1bHRWYWx1ZTogVCxcbiAgcmVzdWx0PzogUmVzdWx0PFQsIEU+XG4pOiBUIHwgKChyZXN1bHQ6IFJlc3VsdDxULCBFPikgPT4gVCkge1xuICBjb25zdCBvcCA9IChyOiBSZXN1bHQ8VCwgRT4pID0+IChpc09rKHIpID8gci52YWx1ZSA6IGRlZmF1bHRWYWx1ZSk7XG4gIHJldHVybiBjdXJyeTEob3AsIHJlc3VsdCk7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2B1bndyYXBPcmBdKCN1bndyYXBvcikgKi9cbmV4cG9ydCBjb25zdCBnZXRPciA9IHVud3JhcE9yO1xuXG4vKipcbiAgU2FmZWx5IGdldCB0aGUgdmFsdWUgb3V0IG9mIGEgW2BSZXN1bHRgXSgjcmVzdWx0KSBieSByZXR1cm5pbmcgdGhlIHdyYXBwZWRcbiAgdmFsdWUgaWYgaXQgaXMgYE9rYCwgb3IgYnkgYXBwbHlpbmcgYG9yRWxzZUZuYCB0byB0aGUgdmFsdWUgaW4gdGhlIGBFcnJgLlxuXG4gIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gKmdlbmVyYXRlKiBhIHZhbHVlIChlLmcuIGJ5IHVzaW5nIGN1cnJlbnRcbiAgdmFsdWVzIGluIHRoZSBlbnZpcm9ubWVudCDigJMgd2hldGhlciBwcmVsb2FkZWQgb3IgYnkgbG9jYWwgY2xvc3VyZSkgaW5zdGVhZCBvZlxuICBoYXZpbmcgYSBzaW5nbGUgZGVmYXVsdCB2YWx1ZSBhdmFpbGFibGUgKGFzIGluIFtgdW53cmFwT3JgXSgjdW53cmFwb3IpKS5cblxuICBgYGB0c1xuICBpbXBvcnQgeyBvaywgZXJyLCB1bndyYXBPckVsc2UgfSBmcm9tICd0cnVlLW15dGgvcmVzdWx0JztcblxuICAvLyBZb3UgY2FuIGltYWdpbmUgdGhhdCBzb21lT3RoZXJWYWx1ZSBtaWdodCBiZSBkeW5hbWljLlxuICBjb25zdCBzb21lT3RoZXJWYWx1ZSA9IDI7XG4gIGNvbnN0IGhhbmRsZUVyciA9IChlcnJWYWx1ZTogc3RyaW5nKSA9PiBlcnJWYWx1ZS5sZW5ndGggKyBzb21lT3RoZXJWYWx1ZTtcblxuICBjb25zdCBhbk9rID0gb2s8bnVtYmVyLCBzdHJpbmc+KDQyKTtcbiAgY29uc29sZS5sb2codW53cmFwT3JFbHNlKGhhbmRsZUVyciwgYW5PaykpOyAgLy8gNDJcblxuICBjb25zdCBhbkVyciA9IGVycjxudW1iZXIsIHN0cmluZz4oJ29oIHRlaCBub2VzJyk7XG4gIGNvbnNvbGUubG9nKHVud3JhcE9yRWxzZShoYW5kbGVFcnIsIGFuRXJyKSk7ICAvLyAxM1xuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgVGhlIHZhbHVlIHdyYXBwZWQgaW4gdGhlIGBPa2AuXG4gIEB0eXBlcGFyYW0gRSAgICBUaGUgdmFsdWUgd3JhcHBlZCBpbiB0aGUgYEVycmAuXG4gIEBwYXJhbSBvckVsc2VGbiBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIHZhbHVlIHdyYXBwZWQgaW4gYHJlc3VsdGAgaWYgaXQgaXNcbiAgICAgICAgICAgICAgICAgIGFuIGBFcnJgLCB0byBnZW5lcmF0ZSB0aGUgZmluYWwgdmFsdWUuXG4gIEBwYXJhbSByZXN1bHQgICBUaGUgYHJlc3VsdGAgdG8gdW53cmFwIGlmIGl0IGlzIGFuIGBPa2AuXG4gIEByZXR1cm5zICAgICAgICBUaGUgdmFsdWUgd3JhcHBlZCBpbiBgcmVzdWx0YCBpZiBpdCBpcyBgT2tgIG9yIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuZWQgYnkgYG9yRWxzZUZuYCBhcHBsaWVkIHRvIHRoZSB2YWx1ZSBpbiBgRXJyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxULCBFPihvckVsc2VGbjogKGVycm9yOiBFKSA9PiBULCByZXN1bHQ6IFJlc3VsdDxULCBFPik6IFQ7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3JFbHNlPFQsIEU+KG9yRWxzZUZuOiAoZXJyb3I6IEUpID0+IFQpOiAocmVzdWx0OiBSZXN1bHQ8VCwgRT4pID0+IFQ7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3JFbHNlPFQsIEU+KFxuICBvckVsc2VGbjogKGVycm9yOiBFKSA9PiBULFxuICByZXN1bHQ/OiBSZXN1bHQ8VCwgRT5cbik6IFQgfCAoKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBUKSB7XG4gIGNvbnN0IG9wID0gKHI6IFJlc3VsdDxULCBFPikgPT4gKGlzT2socikgPyByLnZhbHVlIDogb3JFbHNlRm4oci5lcnJvcikpO1xuICByZXR1cm4gY3VycnkxKG9wLCByZXN1bHQpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgdW53cmFwT3JFbHNlYF0oI3Vud3JhcG9yZWxzZSkgKi9cbmV4cG9ydCBjb25zdCBnZXRPckVsc2UgPSB1bndyYXBPckVsc2U7XG5cbi8qKlxuICBDb252ZXJ0IGEgW2BSZXN1bHRgXSgjcmVzdWx0KSB0byBhIFtgTWF5YmVgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXliZSkuXG5cbiAgVGhlIGNvbnZlcnRlZCB0eXBlIHdpbGwgYmUgW2BKdXN0YF0gaWYgdGhlIGBSZXN1bHRgIGlzIFtgT2tgXSBvciBbYE5vdGhpbmdgXVxuICBpZiB0aGUgYFJlc3VsdGAgaXMgW2BFcnJgXTsgdGhlIHdyYXBwZWQgZXJyb3IgdmFsdWUgd2lsbCBiZSBkaXNjYXJkZWQuXG5cbiAgW2BKdXN0YF06IC4uL2NsYXNzZXMvX21heWJlXy5qdXN0Lmh0bWxcbiAgW2BOb3RoaW5nYF06IC4uL2NsYXNzZXMvX21heWJlXy5ub3RoaW5nLmh0bWxcbiAgW2BPa2BdOiAuLi9jbGFzc2VzL19yZXN1bHRfLm9rLmh0bWxcbiAgW2BFcnJgXTogLi4vY2xhc3Nlcy9fcmVzdWx0Xy5lcnIuaHRtbFxuXG4gIEBwYXJhbSByZXN1bHQgVGhlIGBSZXN1bHRgIHRvIGNvbnZlcnQgdG8gYSBgTWF5YmVgXG4gIEByZXR1cm5zICAgICAgYEp1c3RgIHRoZSB2YWx1ZSBpbiBgcmVzdWx0YCBpZiBpdCBpcyBgT2tgOyBvdGhlcndpc2UgYE5vdGhpbmdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b01heWJlPFQ+KHJlc3VsdDogUmVzdWx0PFQsIGFueT4pOiBNYXliZTxUPiB7XG4gIHJldHVybiBpc09rKHJlc3VsdCkgPyBqdXN0KHJlc3VsdC52YWx1ZSkgOiBub3RoaW5nKCk7XG59XG5cbi8qKlxuICBUcmFuc2Zvcm0gYSBbYE1heWJlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWF5YmUpIGludG8gYSBbYFJlc3VsdGBdKCNyZXN1bHQpLlxuXG4gIElmIHRoZSBgTWF5YmVgIGlzIGEgW2BKdXN0YF0sIGl0cyB2YWx1ZSB3aWxsIGJlIHdyYXBwZWQgaW4gdGhlIFtgT2tgXSB2YXJpYW50O1xuICBpZiBpdCBpcyBhIFtgTm90aGluZ2BdIHRoZSBgZXJyVmFsdWVgIHdpbGwgYmUgd3JhcHBlZCBpbiB0aGUgW2BFcnJgXSB2YXJpYW50LlxuXG4gIFtgSnVzdGBdOiAuLi9jbGFzc2VzL19tYXliZV8uanVzdC5odG1sXG4gIFtgTm90aGluZ2BdOiAuLi9jbGFzc2VzL19tYXliZV8ubm90aGluZy5odG1sXG4gIFtgT2tgXTogLi4vY2xhc3Nlcy9fcmVzdWx0Xy5vay5odG1sXG4gIFtgRXJyYF06IC4uL2NsYXNzZXMvX3Jlc3VsdF8uZXJyLmh0bWxcblxuICBAcGFyYW0gZXJyVmFsdWUgQSB2YWx1ZSB0byB3cmFwIGluIGFuIGBFcnJgIGlmIGBtYXliZWAgaXMgYSBgTm90aGluZ2AuXG4gIEBwYXJhbSBtYXliZSAgICBUaGUgYE1heWJlYCB0byBjb252ZXJ0IHRvIGEgYFJlc3VsdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF5YmU8VCwgRT4oZXJyVmFsdWU6IEUsIG1heWJlOiBNYXliZTxUPik6IFJlc3VsdDxULCBFPjtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF5YmU8VCwgRT4oZXJyVmFsdWU6IEUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBSZXN1bHQ8VCwgRT47XG5leHBvcnQgZnVuY3Rpb24gZnJvbU1heWJlPFQsIEU+KFxuICBlcnJWYWx1ZTogRSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogUmVzdWx0PFQsIEU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKGlzSnVzdChtKSA/IG9rPFQsIEU+KE1heWJlLnVuc2FmZWx5VW53cmFwKG0pKSA6IGVycjxULCBFPihlcnJWYWx1ZSkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBtYXliZSk7XG59XG5cbi8qKlxuICBDcmVhdGUgYSBgU3RyaW5nYCByZXByZXNlbnRhdGlvbiBvZiBhIGByZXN1bHRgIGluc3RhbmNlLlxuXG4gIEFuIGBPa2AgaW5zdGFuY2Ugd2lsbCBiZSBwcmludGVkIGFzIGBPayg8cmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlPilgLCBhbmRcbiAgYW4gYEVycmAgaW5zdGFuY2Ugd2lsbCBiZSBwcmludGVkIGFzIGBFcnIoPHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvcj4pYCxcbiAgd2hlcmUgdGhlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSBvciBlcnJvciBpcyBzaW1wbHkgdGhlIHZhbHVlIG9yIGVycm9yJ3NcbiAgb3duIGB0b1N0cmluZ2AgcmVwcmVzZW50YXRpb24uIEZvciBleGFtcGxlOlxuXG4gICAgICAgICAgICAgICAgY2FsbCAgICAgICAgICAgICAgICB8ICAgICAgICAgb3V0cHV0XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYHRvU3RyaW5nKG9rKDQyKSlgICAgICAgICAgICAgICAgIHwgYE9rKDQyKWBcbiAgYHRvU3RyaW5nKG9rKFsxLCAyLCAzXSkpYCAgICAgICAgIHwgYE9rKDEsMiwzKWBcbiAgYHRvU3RyaW5nKG9rKHsgYW46ICdvYmplY3QnIH0pKWAgIHwgYE9rKFtvYmplY3QgT2JqZWN0XSlgblxuICBgdG9TdHJpbmcoZXJyKDQyKSlgICAgICAgICAgICAgICAgfCBgRXJyKDQyKWBcbiAgYHRvU3RyaW5nKGVycihbMSwgMiwgM10pKWAgICAgICAgIHwgYEVycigxLDIsMylgXG4gIGB0b1N0cmluZyhlcnIoeyBhbjogJ29iamVjdCcgfSkpYCB8IGBFcnIoW29iamVjdCBPYmplY3RdKWBcblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWU7IGl0cyBvd24gYC50b1N0cmluZ2Agd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICB0byBwcmludCB0aGUgaW50ZXJpb3IgY29udGVudHMgb2YgdGhlIGBKdXN0YCB2YXJpYW50LlxuICBAcGFyYW0gbWF5YmUgVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuXG4gIEByZXR1cm5zICAgICBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBgTWF5YmVgLlxuICovXG5leHBvcnQgY29uc3QgdG9TdHJpbmcgPSA8VCwgRT4ocmVzdWx0OiBSZXN1bHQ8VCwgRT4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBib2R5ID0gKGlzT2socmVzdWx0KSA/IHJlc3VsdC52YWx1ZSA6IHJlc3VsdC5lcnJvcikudG9TdHJpbmcoKTtcbiAgcmV0dXJuIGAke3Jlc3VsdC52YXJpYW50LnRvU3RyaW5nKCl9KCR7Ym9keX0pYDtcbn07XG5cbi8qKiBBIGxpZ2h0d2VpZ2h0IG9iamVjdCBkZWZpbmluZyBob3cgdG8gaGFuZGxlIGVhY2ggdmFyaWFudCBvZiBhIE1heWJlLiAqL1xuZXhwb3J0IHR5cGUgTWF0Y2hlcjxULCBFLCBBPiA9IHtcbiAgT2s6ICh2YWx1ZTogVCkgPT4gQTtcbiAgRXJyOiAoZXJyb3I6IEUpID0+IEE7XG59O1xuXG4vKipcbiAgUGVyZm9ybXMgdGhlIHNhbWUgYmFzaWMgZnVuY3Rpb25hbGl0eSBhcyBgZ2V0T3JFbHNlYCwgYnV0IGluc3RlYWQgb2Ygc2ltcGx5XG4gIHVud3JhcHBpbmcgdGhlIHZhbHVlIGlmIGl0IGlzIGBPa2AgYW5kIGFwcGx5aW5nIGEgdmFsdWUgdG8gZ2VuZXJhdGUgdGhlIHNhbWVcbiAgZGVmYXVsdCB0eXBlIGlmIGl0IGlzIGBOb3RoaW5nYCwgbGV0cyB5b3Ugc3VwcGx5IGZ1bmN0aW9ucyB3aGljaCBtYXkgdHJhbnNmb3JtXG4gIHRoZSB3cmFwcGVkIHR5cGUgaWYgaXQgaXMgYE9rYCBvciBnZXQgYSBkZWZhdWx0IHZhbHVlIGZvciBgTm90aGluZ2AuXG5cbiAgVGhpcyBpcyBraW5kIG9mIGxpa2UgYSBwb29yIG1hbidzIHZlcnNpb24gb2YgcGF0dGVybiBtYXRjaGluZywgd2hpY2hcbiAgSmF2YVNjcmlwdCBjdXJyZW50bHkgbGFja3MuXG5cbiAgSW5zdGVhZCBvZiBjb2RlIGxpa2UgdGhpczpcblxuICBgYGB0c1xuICBpbXBvcnQgeyBSZXN1bHQsIGlzT2ssIG1hdGNoIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG5cbiAgY29uc3QgbG9nVmFsdWUgPSAobWlnaHRCZUFOdW1iZXI6IFJlc3VsdDxudW1iZXIsIHN0cmluZz4pID0+IHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGlzT2sobWlnaHRCZUFOdW1iZXIpXG4gICAgICAgID8gdW5zYWZlbHlVbndyYXAobWlnaHRCZUFOdW1iZXIpLnRvU3RyaW5nKClcbiAgICAgICAgOiBgVGhlcmUgd2FzIGFuIGVycm9yOiAke3Vuc2FmZWx5R2V0RXJyKG1pZ2h0QmVBTnVtYmVyKX1gXG4gICAgKTtcbiAgfTtcbiAgYGBgXG5cbiAgLi4ud2UgY2FuIHdyaXRlIGNvZGUgbGlrZSB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCB7IFJlc3VsdCwgbWF0Y2ggfSBmcm9tICd0cnVlLW15dGgvcmVzdWx0JztcblxuICBjb25zdCBsb2dWYWx1ZSA9IChtaWdodEJlQU51bWJlcjogUmVzdWx0PG51bWJlciwgc3RyaW5nPikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gbWF0Y2goXG4gICAgICB7XG4gICAgICAgIE9rOiBuID0+IG4udG9TdHJpbmcoKSxcbiAgICAgICAgRXJyOiBlID0+IGBUaGVyZSB3YXMgYW4gZXJyb3I6ICR7ZX1gLFxuICAgICAgfSxcbiAgICAgIG1pZ2h0QmVBTnVtYmVyXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gIH07XG4gIGBgYFxuXG4gIFRoaXMgaXMgc2xpZ2h0bHkgbG9uZ2VyIHRvIHdyaXRlLCBidXQgY2xlYXJlcjogdGhlIG1vcmUgY29tcGxleCB0aGUgcmVzdWx0aW5nXG4gIGV4cHJlc3Npb24sIHRoZSBoYWlyZXIgaXQgaXMgdG8gdW5kZXJzdGFuZCB0aGUgdGVybmFyeS4gVGh1cywgdGhpcyBpc1xuICBlc3BlY2lhbGx5IGNvbnZlbmllbnQgZm9yIHRpbWVzIHdoZW4gdGhlcmUgaXMgYSBjb21wbGV4IHJlc3VsdCwgZS5nLiB3aGVuXG4gIHJlbmRlcmluZyBwYXJ0IG9mIGEgUmVhY3QgY29tcG9uZW50IGlubGluZSBpbiBKU1gvVFNYLlxuXG4gIEBwYXJhbSBtYXRjaGVyIEEgbGlnaHR3ZWlnaHQgb2JqZWN0IGRlZmluaW5nIHdoYXQgdG8gZG8gaW4gdGhlIGNhc2Ugb2YgZWFjaFxuICAgICAgICAgICAgICAgICB2YXJpYW50LlxuICBAcGFyYW0gbWF5YmUgICBUaGUgYG1heWJlYCBpbnN0YW5jZSB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPFQsIEUsIEE+KG1hdGNoZXI6IE1hdGNoZXI8VCwgRSwgQT4sIHJlc3VsdDogUmVzdWx0PFQsIEU+KTogQTtcbmV4cG9ydCBmdW5jdGlvbiBtYXRjaDxULCBFLCBBPihtYXRjaGVyOiBNYXRjaGVyPFQsIEUsIEE+KTogKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBBO1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPFQsIEUsIEE+KFxuICBtYXRjaGVyOiBNYXRjaGVyPFQsIEUsIEE+LFxuICByZXN1bHQ/OiBSZXN1bHQ8VCwgRT5cbik6IEEgfCAoKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBBKSB7XG4gIGNvbnN0IG9wID0gKHI6IFJlc3VsdDxULCBFPikgPT4gbWFwT3JFbHNlKG1hdGNoZXIuRXJyLCBtYXRjaGVyLk9rLCByKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgcmVzdWx0KTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYG1hdGNoYF0oI21hdGNoKSAqL1xuZXhwb3J0IGNvbnN0IGNhdGEgPSBtYXRjaDtcblxuLyoqXG4gIEFsbG93cyBxdWljayB0cmlwbGUtZXF1YWwgZXF1YWxpdHkgY2hlY2sgYmV0d2VlbiB0aGUgdmFsdWVzIGluc2lkZSB0d28gYHJlc3VsdGBzXG4gIHdpdGhvdXQgaGF2aW5nIHRvIHVud3JhcCB0aGVtIGZpcnN0LlxuXG4gIGBgYHRzXG4gIGNvbnN0IGEgPSBSZXN1bHQub2YoMylcbiAgY29uc3QgYiA9IFJlc3VsdC5vZigzKVxuICBjb25zdCBjID0gUmVzdWx0Lm9mKG51bGwpXG4gIGNvbnN0IGQgPSBSZXN1bHQubm90aGluZygpXG5cbiAgUmVzdWx0LmVxdWFscyhhLCBiKSAvLyB0cnVlXG4gIFJlc3VsdC5lcXVhbHMoYSwgYykgLy8gZmFsc2VcbiAgUmVzdWx0LmVxdWFscyhjLCBkKSAvLyB0cnVlXG4gIGBgYFxuXG4gIEBwYXJhbSByZXN1bHRCIEEgYG1heWJlYCB0byBjb21wYXJlIHRvLlxuICBAcGFyYW0gcmVzdWx0QSBBIGBtYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VCwgRT4ocmVzdWx0QjogUmVzdWx0PFQsIEU+LCByZXN1bHRBOiBSZXN1bHQ8VCwgRT4pOiBib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsczxULCBFPihyZXN1bHRCOiBSZXN1bHQ8VCwgRT4pOiAocmVzdWx0QTogUmVzdWx0PFQsIEU+KSA9PiBib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsczxULCBFPihcbiAgcmVzdWx0QjogUmVzdWx0PFQsIEU+LFxuICByZXN1bHRBPzogUmVzdWx0PFQsIEU+XG4pOiBib29sZWFuIHwgKChhOiBSZXN1bHQ8VCwgRT4pID0+IGJvb2xlYW4pIHtcbiAgcmV0dXJuIHJlc3VsdEEgIT09IHVuZGVmaW5lZFxuICAgID8gcmVzdWx0QS5tYXRjaCh7XG4gICAgICAgIEVycjogKCkgPT4gaXNFcnIocmVzdWx0QiksXG4gICAgICAgIE9rOiBhID0+IGlzT2socmVzdWx0QikgJiYgcmVzdWx0Qi51bnNhZmVseVVud3JhcCgpID09PSBhLFxuICAgICAgfSlcbiAgICA6IChjdXJyaWVkUmVzdWx0QTogUmVzdWx0PFQsIEU+KSA9PlxuICAgICAgICBjdXJyaWVkUmVzdWx0QS5tYXRjaCh7XG4gICAgICAgICAgRXJyOiAoKSA9PiBpc0VycihyZXN1bHRCKSxcbiAgICAgICAgICBPazogYSA9PiBpc09rKHJlc3VsdEIpICYmIHJlc3VsdEIudW5zYWZlbHlVbndyYXAoKSA9PT0gYSxcbiAgICAgICAgfSk7XG59XG5cbi8qKlxuICBBbGxvd3MgeW91IHRvICphcHBseSogKHRodXMgYGFwYCkgYSB2YWx1ZSB0byBhIGZ1bmN0aW9uIHdpdGhvdXQgaGF2aW5nIHRvXG4gIHRha2UgZWl0aGVyIG91dCBvZiB0aGUgY29udGV4dCBvZiB0aGVpciBgUmVzdWx0YHMuIFRoaXMgZG9lcyBtZWFuIHRoYXQgdGhlXG4gIHRyYW5zZm9ybWluZyBmdW5jdGlvbiBpcyBpdHNlbGYgd2l0aGluIGEgYFJlc3VsdGAsIHdoaWNoIGNhbiBiZSBoYXJkIHRvIGdyb2tcbiAgYXQgZmlyc3QgYnV0IGxldHMgeW91IGRvIHNvbWUgdmVyeSBlbGVnYW50IHRoaW5ncy4gRm9yIGV4YW1wbGUsIGBhcGAgYWxsb3dzXG4gIHlvdSB0byBkbyB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBSZXN1bHQgZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG5cbiAgY29uc3Qgb25lID0gUmVzdWx0Lm9rPG51bWJlciwgc3RyaW5nPigxKTtcbiAgY29uc3QgZml2ZSA9IFJlc3VsdC5vazxudW1iZXIsIHN0cmluZz4oNSk7XG4gIGNvbnN0IHdob29wcyA9IFJlc3VsdC5lcnI8bnVtYmVyLCBzdHJpbmc+KCdvaCBubycpO1xuXG4gIGNvbnN0IGFkZCA9IChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiO1xuICBjb25zdCByZXN1bHRBZGQgPSBSZXN1bHQub2s8dHlwZW9mIGFkZCwgc3RyaW5nPihhZGQpO1xuXG4gIHJlc3VsdEFkZC5hcChvbmUpLmFwKGZpdmUpOyAvLyBPayg2KVxuICByZXN1bHRBZGQuYXAob25lKS5hcCh3aG9vcHMpOyAvLyBFcnIoJ29oIG5vJylcbiAgcmVzdWx0QWRkLmFwKHdob29wcykuYXAoZml2ZSkgLy8gRXJyKCdvaCBubycpXG4gIGBgYFxuXG4gIFdpdGhvdXQgYFJlc3VsdC5hcGAsIHlvdSdkIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2UgYSBuZXN0ZWQgYFJlc3VsdC5tYXRjaGA6XG5cbiAgYGBgdHNcbiAgaW1wb3J0IHsgb2ssIGVyciB9IGZyb20gJ3RydWUtbXl0aC9yZXN1bHQnO1xuXG4gIGNvbnN0IG9uZSA9IG9rPG51bWJlciwgc3RyaW5nPigxKTtcbiAgY29uc3QgZml2ZSA9IG9rPG51bWJlciwgc3RyaW5nPig1KTtcbiAgY29uc3Qgd2hvb3BzID0gZXJyPG51bWJlciwgc3RyaW5nPignb2ggbm8nKTtcblxuICBvbmUubWF0Y2goe1xuICAgIE9rOiBuID0+IGZpdmUubWF0Y2goe1xuICAgICAgT2s6IG8gPT4gb2s8bnVtYmVyLCBzdHJpbmc+KG4gKyBvKSxcbiAgICAgIEVycjogZSA9PiBlcnI8bnVtYmVyLCBzdHJpbmc+KGUpLFxuICAgIH0pLFxuICAgIEVycjogZSAgPT4gZXJyPG51bWJlciwgc3RyaW5nPihlKSxcbiAgfSk7IC8vIE9rKDYpXG5cbiAgb25lLm1hdGNoKHtcbiAgICBPazogbiA9PiB3aG9vcHMubWF0Y2goe1xuICAgICAgT2s6IG8gPT4gb2s8bnVtYmVyLCBzdHJpbmc+KG4gKyBvKSxcbiAgICAgIEVycjogZSA9PiBlcnI8bnVtYmVyLCBzdHJpbmc+KGUpLFxuICAgIH0pLFxuICAgIEVycjogZSAgPT4gZXJyPG51bWJlciwgc3RyaW5nPihlKSxcbiAgfSk7IC8vIEVycignb2ggbm8nKVxuXG4gIHdob29wcy5tYXRjaCh7XG4gICAgT2s6IG4gPT4gZml2ZS5tYXRjaCh7XG4gICAgICBPazogbyA9PiBvayhuICsgbyksXG4gICAgICBFcnI6IGUgPT4gZXJyKGUpLFxuICAgIH0pLFxuICAgIEVycjogZSAgPT4gZXJyKGUpLFxuICB9KTsgLy8gRXJyKCdvaCBubycpXG4gIGBgYFxuXG4gIEFuZCB0aGlzIGtpbmQgb2YgdGhpbmcgY29tZXMgdXAgcXVpdGUgb2Z0ZW4gb25jZSB5b3UncmUgdXNpbmcgYE1heWJlYCB0b1xuICBoYW5kbGUgb3B0aW9uYWxpdHkgdGhyb3VnaG91dCB5b3VyIGFwcGxpY2F0aW9uLlxuXG4gIEZvciBhbm90aGVyIGV4YW1wbGUsIGltYWdpbmUgeW91IG5lZWQgdG8gY29tcGFyZSB0aGUgZXF1YWxpdHkgb2YgdHdvXG4gIEltbXV0YWJsZUpTIGRhdGEgc3RydWN0dXJlcywgd2hlcmUgYSBgPT09YCBjb21wYXJpc29uIHdvbid0IHdvcmsuIFdpdGggYGFwYCxcbiAgdGhhdCdzIGFzIHNpbXBsZSBhcyB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCB7IG9rIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG4gIGltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbiAgaW1wb3J0IHsgY3VycnkgfSBmcm9tICdsb2Rhc2gnXG5cbiAgY29uc3QgaXMgPSBjdXJyeShJbW11dGFibGUuaXMpO1xuXG4gIGNvbnN0IHggPSBvayhJbW11dGFibGUuU2V0Lm9mKDEsIDIsIDMpKTtcbiAgY29uc3QgeSA9IG9rKEltbXV0YWJsZS5TZXQub2YoMiwgMywgNCkpO1xuXG4gIG9rKGlzKS5hcCh4KS5hcCh5KTsgLy8gT2soZmFsc2UpXG4gIGBgYFxuXG4gIFdpdGhvdXQgYGFwYCwgd2UncmUgYmFjayB0byB0aGF0IGduYXJseSBuZXN0ZWQgYG1hdGNoYDpcblxuICBgYGB0c1xuICAgKiBpbXBvcnQgUmVzdWx0LCB7IG9rLCBlcnIgfSBmcm9tICd0cnVlLW15dGgvcmVzdWx0JztcbiAgaW1wb3J0IEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnO1xuICBpbXBvcnQgeyBjdXJyeSB9IGZyb20gJ2xvZGFzaCdcblxuICBjb25zdCBpcyA9IGN1cnJ5KEltbXV0YWJsZS5pcyk7XG5cbiAgY29uc3QgeCA9IG9rKEltbXV0YWJsZS5TZXQub2YoMSwgMiwgMykpO1xuICBjb25zdCB5ID0gb2soSW1tdXRhYmxlLlNldC5vZigyLCAzLCA0KSk7XG5cbiAgeC5tYXRjaCh7XG4gICAgT2s6IGlYID0+IHkubWF0Y2goe1xuICAgICAgT2s6IGlZID0+IFJlc3VsdC5vZihJbW11dGFibGUuaXMoaVgsIGlZKSksXG4gICAgICBFcnI6IChlKSA9PiBvayhmYWxzZSksXG4gICAgfSlcbiAgICBFcnI6IChlKSA9PiBvayhmYWxzZSksXG4gIH0pOyAvLyBPayhmYWxzZSlcbiAgYGBgXG5cbiAgSW4gc3VtbWFyeTogYW55d2hlcmUgeW91IGhhdmUgdHdvIGBNYXliZWAgaW5zdGFuY2VzIGFuZCBuZWVkIHRvIHBlcmZvcm0gYW5cbiAgb3BlcmF0aW9uIHRoYXQgdXNlcyBib3RoIG9mIHRoZW0sIGBhcGAgaXMgeW91ciBmcmllbmQuXG5cbiAgVHdvIHRoaW5ncyB0byBub3RlLCBib3RoIHJlZ2FyZGluZyAqY3VycnlpbmcqOlxuXG4gIDEuICBBbGwgZnVuY3Rpb25zIHBhc3NlZCB0byBgYXBgIG11c3QgYmUgY3VycmllZC4gVGhhdCBpcywgdGhleSBtdXN0IGJlIG9mIHRoZVxuICAgICAgZm9ybSAoZm9yIGFkZCkgYChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiYCwgKm5vdCogdGhlIG1vcmUgdXN1YWxcbiAgICAgIGAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IGEgKyBiYCB5b3Ugc2VlIGluIEphdmFTY3JpcHQgbW9yZSBnZW5lcmFsbHkuXG5cbiAgICAgIEZvciBjb252ZW5pZW5jZSwgeW91IG1heSB3YW50IHRvIGxvb2sgYXQgTG9kYXNoJ3MgYF8uY3VycnlgIG9yIFJhbWRhJ3NcbiAgICAgIGBSLmN1cnJ5YCwgd2hpY2ggYWxsb3cgeW91IHRvIGNyZWF0ZSBjdXJyaWVkIHZlcnNpb25zIG9mIGZ1bmN0aW9uc1xuICAgICAgd2hlbmV2ZXIgeW91IHdhbnQ6XG5cbiAgICAgIGBgYFxuICAgICAgaW1wb3J0IFJlc3VsdCBmcm9tICd0cnVlLW15dGgvcmVzdWx0JztcbiAgICAgIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJztcblxuICAgICAgY29uc3Qgbm9ybWFsQWRkID0gKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBhICsgYjtcbiAgICAgIGNvbnN0IGN1cnJpZWRBZGQgPSBjdXJyeShub3JtYWxBZGQpOyAvLyAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYjtcblxuICAgICAgUmVzdWx0Lm9mKGN1cnJpZWRBZGQpLmFwKFJlc3VsdC5vZigxKSkuYXAoUmVzdWx0Lm9mKDUpKTsgLy8gT2soNilcbiAgICAgIGBgYFxuXG4gIDIuICBZb3Ugd2lsbCBuZWVkIHRvIGNhbGwgYGFwYCBhcyBtYW55IHRpbWVzIGFzIHRoZXJlIGFyZSBhcmd1bWVudHMgdG8gdGhlXG4gICAgICBmdW5jdGlvbiB5b3UncmUgZGVhbGluZyB3aXRoLiBTbyBpbiB0aGUgY2FzZSBvZiBgYWRkYCwgd2hpY2ggaGFzIHRoZVxuICAgICAgXCJhcml0eVwiIChmdW5jdGlvbiBhcmd1bWVudCBjb3VudCkgb2YgMiAoYGFgIGFuZCBgYmApLCB5b3UnbGwgbmVlZCB0byBjYWxsXG4gICAgICBgYXBgIHR3aWNlOiBvbmNlIGZvciBgYWAsIGFuZCBvbmNlIGZvciBgYmAuIFRvIHNlZSB3aHksIGxldCdzIGxvb2sgYXQgd2hhdFxuICAgICAgdGhlIHJlc3VsdCBpbiBlYWNoIHBoYXNlIGlzOlxuXG4gICAgICBgYGB0c1xuICAgICAgY29uc3QgYWRkID0gKGE6IG51bWJlcikgPT4gKGI6IG51bWJlcikgPT4gYSArIGI7XG5cbiAgICAgIGNvbnN0IG1heWJlQWRkID0gUmVzdWx0Lm9mKGFkZCk7IC8vIE9rKChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiKVxuICAgICAgY29uc3QgbWF5YmVBZGQxID0gbWF5YmVBZGQuYXAoUmVzdWx0Lm9mKDEpKTsgLy8gT2soKGI6IG51bWJlcikgPT4gMSArIGIpXG4gICAgICBjb25zdCBmaW5hbCA9IG1heWJlQWRkMS5hcChSZXN1bHQub2YoMykpOyAvLyBPayg0KVxuICAgICAgYGBgXG5cbiAgICAgIFNvIGZvciBgdG9TdHJpbmdgLCB3aGljaCBqdXN0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50LCB5b3Ugd291bGQgb25seSBuZWVkXG4gICAgICB0byBjYWxsIGBhcGAgb25jZS5cblxuICAgICAgYGBgdHNcbiAgICAgIGNvbnN0IHRvU3RyID0gKHY6IHsgdG9TdHJpbmcoKTogc3RyaW5nIH0pID0+IHYudG9TdHJpbmcoKTtcbiAgICAgIFJlc3VsdC5vZih0b1N0cikuYXAoMTIpOyAvLyBPayhcIjEyXCIpXG4gICAgICBgYGBcblxuICBPbmUgb3RoZXIgc2NlbmFyaW8gd2hpY2ggZG9lc24ndCBjb21lIHVwICpxdWl0ZSogYXMgb2Z0ZW4gYnV0IGlzIGNvbmNlaXZhYmxlXG4gIGlzIHdoZXJlIHlvdSBoYXZlIHNvbWV0aGluZyB0aGF0IG1heSBvciBtYXkgbm90IGFjdHVhbGx5IGNvbnN0cnVjdCBhIGZ1bmN0aW9uXG4gIGZvciBoYW5kbGluZyBhIHNwZWNpZmljIGBSZXN1bHRgIHNjZW5hcmlvLiBJbiB0aGF0IGNhc2UsIHlvdSBjYW4gd3JhcCB0aGVcbiAgcG9zc2libHktcHJlc2VudCBpbiBgYXBgIGFuZCB0aGVuIHdyYXAgdGhlIHZhbHVlcyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24gdG9cbiAgaW4gYFJlc3VsdGAgdGhlbXNlbHZlcy5cblxuICBCZWNhdXNlIGBSZXN1bHRgIG9mdGVuIHJlcXVpcmVzIHlvdSB0byB0eXBlIG91dCB0aGUgZnVsbCB0eXBlIHBhcmFtZXRlcml6YXRpb25cbiAgb24gYSByZWd1bGFyIGJhc2lzLCBpdCdzIGNvbnZlbmllbnQgdG8gdXNlIFR5cGVTY3JpcHQncyBgdHlwZW9mYCBvcGVyYXRvciB0b1xuICB3cml0ZSBvdXQgdGhlIHR5cGUgb2YgYSBjdXJyaWVkIGZ1bmN0aW9uLiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhZCBhIGZ1bmN0aW9uXG4gIHRoYXQgc2ltcGx5IG1lcmdlZCB0aHJlZSBzdHJpbmdzLCB5b3UgbWlnaHQgd3JpdGUgaXQgbGlrZSB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBSZXN1bHQgZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG4gIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJztcblxuICBjb25zdCBtZXJnZTNTdHJzID0gKGE6IHN0cmluZywgYjogc3RyaW5nLCBjOiBzdHJpbmcpID0+IHN0cmluZztcbiAgY29uc3QgY3VycmllZE1lcmdlID0gY3VycnkobWVyZ2UzU3Rycyk7XG5cbiAgY29uc3QgZm4gPSBSZXN1bHQub2s8dHlwZW9mIGN1cnJpZWRNZXJnZSwgc3RyaW5nPihjdXJyaWVkTWVyZ2UpO1xuICBgYGBcblxuICBUaGUgYWx0ZXJuYXRpdmUgaXMgd3JpdGluZyBvdXQgdGhlIGZ1bGwgc2lnbmF0dXJlIGxvbmctZm9ybTpcblxuICBgYGB0c1xuICBjb25zdCBmbiA9IFJlc3VsdC5vazwoYTogc3RyaW5nKSA9PiAoYjogc3RyaW5nKSA9PiAoYzogc3RyaW5nKSA9PiBzdHJpbmcsIHN0cmluZz4oY3VycmllZE1lcmdlKTtcbiAgYGBgXG5cbiAgKipBc2lkZToqKiBgYXBgIGlzIG5vdCBuYW1lZCBgYXBwbHlgIGJlY2F1c2Ugb2YgdGhlIG92ZXJsYXAgd2l0aCBKYXZhU2NyaXB0J3NcbiAgZXhpc3RpbmcgW2BhcHBseWBdIGZ1bmN0aW9uIOKAkyBhbmQgYWx0aG91Z2ggc3RyaWN0bHkgc3BlYWtpbmcsIHRoZXJlIGlzbid0IGFueVxuICBkaXJlY3Qgb3ZlcmxhcCAoYFJlc3VsdC5hcHBseWAgYW5kIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgIGRvbid0IGludGVyc2VjdFxuICBhdCBhbGwpIGl0J3MgdXNlZnVsIHRvIGhhdmUgYSBkaWZmZXJlbnQgbmFtZSB0byBhdm9pZCBpbXBseWluZyB0aGF0IHRoZXkncmVcbiAgdGhlIHNhbWUuXG5cbiAgW2BhcHBseWBdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9hcHBseVxuXG4gIEBwYXJhbSByZXN1bHRGbiByZXN1bHQgb2YgYSBmdW5jdGlvbiBmcm9tIFQgdG8gVVxuICBAcGFyYW0gcmVzdWx0IHJlc3VsdCBvZiBhIFQgdG8gYXBwbHkgdG8gYGZuYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVSwgRT4ocmVzdWx0Rm46IFJlc3VsdDwodDogVCkgPT4gVSwgRT4sIHJlc3VsdDogUmVzdWx0PFQsIEU+KTogUmVzdWx0PFUsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIGFwPFQsIFUsIEU+KFxuICByZXN1bHRGbjogUmVzdWx0PCh0OiBUKSA9PiBVLCBFPlxuKTogKHJlc3VsdDogUmVzdWx0PFQsIEU+KSA9PiBSZXN1bHQ8VSwgRT47XG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVSwgRT4oXG4gIHJlc3VsdEZuOiBSZXN1bHQ8KHZhbDogVCkgPT4gVSwgRT4sXG4gIHJlc3VsdD86IFJlc3VsdDxULCBFPlxuKTogUmVzdWx0PFUsIEU+IHwgKCh2YWw6IFJlc3VsdDxULCBFPikgPT4gUmVzdWx0PFUsIEU+KSB7XG4gIGNvbnN0IG9wID0gKHI6IFJlc3VsdDxULCBFPikgPT5cbiAgICByLm1hdGNoKHtcbiAgICAgIE9rOiB2YWwgPT4gcmVzdWx0Rm4ubWFwKGZuID0+IGZuKHZhbCkpLFxuICAgICAgRXJyOiBlID0+IFJlc3VsdC5lcnI8VSwgRT4oZSksXG4gICAgfSk7XG5cbiAgcmV0dXJuIGN1cnJ5MShvcCwgcmVzdWx0KTtcbn1cblxuLyoqXG4gIERldGVybWluZSB3aGV0aGVyIGFuIGl0ZW0gaXMgYW4gaW5zdGFuY2Ugb2YgYEp1c3RgIG9yIGBOb3RoaW5nYC5cblxuICBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5zdGFuY2U8VCA9IGFueSwgRSA9IGFueT4oaXRlbTogYW55KTogaXRlbSBpcyBSZXN1bHQ8VCwgRT4ge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIE9rIHx8IGl0ZW0gaW5zdGFuY2VvZiBFcnI7XG59XG5cbi8qKlxuICBBIHZhbHVlIHdoaWNoIG1heSAoYE9rYCkgb3IgbWF5IG5vdCAoYEVycmApIGJlIHByZXNlbnQuXG5cbiAgVGhlIGJlaGF2aW9yIG9mIHRoaXMgdHlwZSBpcyBjaGVja2VkIGJ5IFR5cGVTY3JpcHQgYXQgY29tcGlsZSB0aW1lLCBhbmQgYmVhcnNcbiAgbm8gcnVudGltZSBvdmVyaGVhZCBvdGhlciB0aGFuIHRoZSB2ZXJ5IHNtYWxsIGNvc3Qgb2YgdGhlIGNvbnRhaW5lciBvYmplY3QuXG4gKi9cbmV4cG9ydCB0eXBlIFJlc3VsdDxULCBFPiA9IE9rPFQsIEU+IHwgRXJyPFQsIEU+O1xuZXhwb3J0IGNvbnN0IFJlc3VsdCA9IHtcbiAgVmFyaWFudCxcbiAgT2ssXG4gIEVycixcbiAgaXNPayxcbiAgaXNFcnIsXG4gIG9rLFxuICBlcnIsXG4gIG1hcCxcbiAgbWFwT3IsXG4gIG1hcE9yRWxzZSxcbiAgbWFwRXJyLFxuICBhbmQsXG4gIGFuZFRoZW4sXG4gIGNoYWluLFxuICBmbGF0TWFwLFxuICBvcixcbiAgb3JFbHNlLFxuICB1bnNhZmVseVVud3JhcCxcbiAgdW5zYWZlbHlHZXQsXG4gIHVuc2FmZUdldCxcbiAgdW5zYWZlbHlVbndyYXBFcnIsXG4gIHVuc2FmZWx5R2V0RXJyLFxuICB1bndyYXBPcixcbiAgZ2V0T3IsXG4gIHVud3JhcE9yRWxzZSxcbiAgZ2V0T3JFbHNlLFxuICB0b01heWJlLFxuICBmcm9tTWF5YmUsXG4gIHRvU3RyaW5nLFxuICBtYXRjaCxcbiAgY2F0YSxcbiAgZXF1YWxzLFxuICBhcCxcbiAgaXNJbnN0YW5jZSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJlc3VsdDtcbiJdfQ==