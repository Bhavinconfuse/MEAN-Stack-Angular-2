/** [[include:doc/maybe.md]] */
/** (keep typedoc from getting confused by the imports) */
import { err, ok } from './result';
import { curry1, isVoid } from './utils';
/**
  Discriminant for the `Just` and `Nothing` variants.

  You can use the discriminant via the `variant` property of `Maybe` instances
  if you need to match explicitly on it.
 */
export var Variant;
(function (Variant) {
    Variant["Just"] = "Just";
    Variant["Nothing"] = "Nothing";
})(Variant || (Variant = {}));
/**
  A `Just` instance is the *present* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type wrapped in this `Just` variant of `Maybe`.
 */
export class Just {
    /**
      Create an instance of `Maybe.Just` with `new`.
  
      @note While you *may* create the `Just` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.just`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.just`]: ../modules/_maybe_.html#just
  
      ```ts
      // Avoid:
      const aString = new Maybe.Just('characters');
  
      // Prefer:
      const aString = Maybe.just('characters);
      ```
  
      @param value
      The value to wrap in a `Maybe.Just`.
  
      `null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Maybe<undefined>`.
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(value) {
        /** `Just` is always [`Variant.Just`](../enums/_maybe_.variant#just). */
        this.variant = Variant.Just;
        if (isVoid(value)) {
            throw new Error('Tried to construct `Just` with `null` or `undefined`');
        }
        this.value = value;
    }
    /**
      Unwrap the contained value. A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Maybe, { Just } from 'true-myth/maybe';
  
      function getLengths(maybeStrings: Array<Maybe<string>>): Array<number> {
        return maybeStrings
          .filter(Maybe.isJust)
          .map(Just.unwrap)
          .map(s => s.length);
      }
      ```
     */
    static unwrap(theJust) {
        return theJust.value;
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return true;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return false;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        return this.value;
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
}
/**
  A `Nothing` instance is the *absent* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type which would be wrapped in a `Just` variant of `Maybe`.
 */
export class Nothing {
    /**
      Create an instance of `Maybe.Nothing` with `new`.
  
      @note While you *may* create the `Nothing` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.nothing`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.nothing`]: ../modules/_maybe_.html#nothing
  
      ```ts
      // Avoid:
      const aNothing = new Maybe.Err();
  
      // Prefer:
      const aNothing = Maybe.nothing();
      ```
  
      `null` and `undefined` are allowed so that you may explicitly construct the
      `Err` type with a known `null` or `undefined` value. (This maybe helpful
      primarily when transitioning a codebase to the use of `Maybe`.)
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(_) {
        /** `Nothing` is always [`Variant.Nothing`](../enums/_maybe_.variant#nothing). */
        this.variant = Variant.Nothing;
        /* nothing to do */
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return false;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return true;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        throw new Error('Tried to `unsafelyUnwrap(Nothing)`');
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
}
/**
  Is this result a `Just` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `Just`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Just<T>`.
 */
export function isJust(maybe) {
    return maybe.variant === Variant.Just;
}
/**
  Is this result a `Nothing` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `nothing`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Nothing<T>`.
 */
export function isNothing(maybe) {
    return maybe.variant === Variant.Nothing;
}
/**
  Create an instance of `Maybe.Just`.

  `null` and `undefined` are allowed by the type signature so that the
  function may `throw` on those rather than constructing a type like
  `Maybe<undefined>`.

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe.Just`.
  @returns     An instance of `Maybe.Just<T>`.
  @throws      If you pass `null` or `undefined`.
 */
export function just(value) {
    return new Just(value);
}
/**
  Create an instance of `Maybe.Nothing`.

  If you want to create an instance with a specific type, e.g. for use in a
  function which expects a `Maybe<T>` where the `<T>` is known but you have no
  value to give it, you can use a type parameter:

  ```ts
  const notString = Maybe.nothing<string>();
  ```

  @typeparam T The type of the item contained in the `Maybe`.
  @returns     An instance of `Maybe.Nothing<T>`.
 */
export function nothing(_) {
    return new Nothing(_);
}
/**
  Create a `Maybe` from any value.

  To specify that the result should be interpreted as a specific type, you may
  invoke `Maybe.of` with an explicit type parameter:

  ```ts
  const foo = Maybe.of<string>(null);
  ```

  This is usually only important in two cases:

  1.  If you are intentionally constructing a `Nothing` from a known `null` or
      undefined value *which is untyped*.
  2.  If you are specifying that the type is more general than the value passed
      (since TypeScript can define types as literals).

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe`. If it is `undefined` or `null`,
               the result will be `Nothing`; otherwise it will be the type of
               the value passed.
 */
export function of(value) {
    return isVoid(value) ? nothing() : just(value);
}
/** Alias for [`of`](#of), primarily for compatibility with Folktale. */
export const fromNullable = of;
export function map(mapFn, maybe) {
    const op = (m) => (m.isJust() ? just(mapFn(m.value)) : nothing());
    return curry1(op, maybe);
}
export function mapOr(orU, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orU;
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    return mapFn === undefined
        ? partialOp
        : maybe === undefined ? partialOp(mapFn) : partialOp(mapFn, maybe);
}
export function mapOrElse(orElseFn, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orElseFn();
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    if (mapFn === undefined) {
        return partialOp;
    }
    else if (maybe === undefined) {
        return partialOp(mapFn);
    }
    else {
        return partialOp(mapFn, maybe);
    }
}
export function and(andMaybe, maybe) {
    const op = (m) => (m.isJust() ? andMaybe : nothing());
    return curry1(op, maybe);
}
export function andThen(thenFn, maybe) {
    const op = (m) => (m.isJust() ? thenFn(m.value) : nothing());
    return maybe !== undefined ? op(maybe) : op;
}
/** Alias for [`andThen`](#andthen). */
export const chain = andThen;
/** Alias for [`andThen`](#andthen). */
export const flatMap = andThen;
export function or(defaultMaybe, maybe) {
    const op = (m) => (m.isJust() ? m : defaultMaybe);
    return maybe !== undefined ? op(maybe) : op;
}
export function orElse(elseFn, maybe) {
    const op = (m) => (m.isJust() ? m : elseFn());
    return curry1(op, maybe);
}
/**
  Get the value out of the `Maybe`.

  Returns the content of a `Just`, but **throws if the `Maybe` is `Nothing`**.
  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).

  @typeparam T The type of the wrapped value.
  @param maybe The value to unwrap
  @returns     The unwrapped value if the `Maybe` instance is `Just`.
  @throws      If the `maybe` is `Nothing`.
 */
export function unsafelyUnwrap(maybe) {
    return maybe.unsafelyUnwrap();
}
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
export const unsafelyGet = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
export const unsafeGet = unsafelyUnwrap;
export function unwrapOr(defaultValue, maybe) {
    const op = (m) => (m.isJust() ? m.value : defaultValue);
    return curry1(op, maybe);
}
/** Alias for [`unwrapOr`](#unwrapor) */
export const getOr = unwrapOr;
export function unwrapOrElse(orElseFn, maybe) {
    const op = (m) => (m.isJust() ? m.value : orElseFn());
    return curry1(op, maybe);
}
/** Alias for [`unwrapOrElse`](#unwraporelse) */
export const getOrElse = unwrapOrElse;
export function toOkOrErr(error, maybe) {
    const op = (m) => (m.isJust() ? ok(m.value) : err(error));
    return maybe !== undefined ? op(maybe) : op;
}
export function toOkOrElseErr(elseFn, maybe) {
    const op = (m) => (m.isJust() ? ok(m.value) : err(elseFn()));
    return curry1(op, maybe);
}
/**
  Construct a `Maybe<T>` from a `Result<T, E>`.

  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an
  `Err`, throw away the wrapped `E` and transform to a `Nothing`.

  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @typeparam E  The type of the value wrapped in a `Result.Err`; thrown away in
                the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
 */
export function fromResult(result) {
    return result.isOk() ? just(result.value) : nothing();
}
/**
  Create a `String` representation of a `Maybe` instance.

  A `Just` instance will be printed as `Just(<representation of the value>)`,
  where the representation of the value is simply the value's own `toString`
  representation. For example:

  | call                                   | output                  |
  |----------------------------------------|-------------------------|
  | `toString(Maybe.of(42))`               | `Just(42)`              |
  | `toString(Maybe.of([1, 2, 3]))`        | `Just(1,2,3)`           |
  | `toString(Maybe.of({ an: 'object' }))` | `Just([object Object])` |
  | `toString(Maybe.nothing())`            | `Nothing`               |

  @typeparam T The type of the wrapped value; its own `.toString` will be used
               to print the interior contents of the `Just` variant.
  @param maybe The value to convert to a string.
  @returns     The string representation of the `Maybe`.
 */
export function toString(maybe) {
    const body = maybe.isJust() ? `(${maybe.value.toString()})` : '';
    return `${maybe.variant}${body}`;
}
export function match(matcher, maybe) {
    return maybe !== undefined
        ? mapOrElse(matcher.Nothing, matcher.Just, maybe)
        : (curriedMaybe) => mapOrElse(matcher.Nothing, matcher.Just, curriedMaybe);
}
/** Alias for [`match`](#match) */
export const cata = match;
export function equals(mb, ma) {
    return ma !== undefined
        ? ma.match({
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
            Nothing: () => isNothing(mb),
        })
        : (maybeA) => maybeA.match({
            Nothing: () => isNothing(mb),
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
        });
}
export function ap(maybeFn, maybe) {
    const op = (m) => m.match({
        Just: val => maybeFn.map(fn => fn(val)),
        Nothing: () => Maybe.nothing(),
    });
    return curry1(op, maybe);
}
/**
  Determine whether an item is an instance of `Just` or `Nothing`.

  @param item The item to check.
 */
export function isInstance(item) {
    return item instanceof Just || item instanceof Nothing;
}
export const Maybe = {
    Variant,
    Just,
    Nothing,
    isJust,
    isNothing,
    just,
    nothing,
    of,
    fromNullable,
    map,
    mapOr,
    mapOrElse,
    and,
    andThen,
    chain,
    flatMap,
    or,
    orElse,
    unsafelyUnwrap,
    unsafelyGet,
    unsafeGet,
    unwrapOr,
    getOr,
    unwrapOrElse,
    getOrElse,
    toOkOrErr,
    toOkOrElseErr,
    fromResult,
    toString,
    match,
    cata,
    equals,
    ap,
    isInstance,
};
export default Maybe;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF5YmUuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2NocmlzL2Rldi9vc3MvdHJ1ZS1teXRoLyIsInNvdXJjZXMiOlsibWF5YmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsK0JBQStCO0FBRS9CLDBEQUEwRDtBQUMxRCxPQUFlLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUV6Qzs7Ozs7R0FLRztBQUNILE1BQU0sQ0FBTixJQUFZLE9BR1g7QUFIRCxXQUFZLE9BQU87SUFDakIsd0JBQWEsQ0FBQTtJQUNiLDhCQUFtQixDQUFBO0FBQ3JCLENBQUMsRUFIVyxPQUFPLEtBQVAsT0FBTyxRQUdsQjtBQWlFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTTtJQTRCSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMkJHO0lBQ0gsWUFBWSxLQUFnQjtRQWxDNUIsd0VBQXdFO1FBQy9ELFlBQU8sR0FBaUIsT0FBTyxDQUFDLElBQUksQ0FBQztRQWtDNUMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzREFBc0QsQ0FBQyxDQUFDO1NBQ3pFO1FBRUQsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQTdERDs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNILE1BQU0sQ0FBQyxNQUFNLENBQUksT0FBZ0I7UUFDL0IsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUE0Q0QsMEVBQTBFO0lBQzFFLE1BQU07UUFDSixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxnRkFBZ0Y7SUFDaEYsU0FBUztRQUNQLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELG9FQUFvRTtJQUNwRSxHQUFHLENBQW9CLEtBQWtCO1FBQ3ZDLE9BQU8sR0FBRyxD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Y2x1ZGU6ZG9jL21heWJlLm1kXV0gKi9cblxuLyoqIChrZWVwIHR5cGVkb2MgZnJvbSBnZXR0aW5nIGNvbmZ1c2VkIGJ5IHRoZSBpbXBvcnRzKSAqL1xuaW1wb3J0IFJlc3VsdCwgeyBlcnIsIG9rIH0gZnJvbSAnLi9yZXN1bHQnO1xuaW1wb3J0IHsgY3VycnkxLCBpc1ZvaWQgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gIERpc2NyaW1pbmFudCBmb3IgdGhlIGBKdXN0YCBhbmQgYE5vdGhpbmdgIHZhcmlhbnRzLlxuXG4gIFlvdSBjYW4gdXNlIHRoZSBkaXNjcmltaW5hbnQgdmlhIHRoZSBgdmFyaWFudGAgcHJvcGVydHkgb2YgYE1heWJlYCBpbnN0YW5jZXNcbiAgaWYgeW91IG5lZWQgdG8gbWF0Y2ggZXhwbGljaXRseSBvbiBpdC5cbiAqL1xuZXhwb3J0IGVudW0gVmFyaWFudCB7XG4gIEp1c3QgPSAnSnVzdCcsXG4gIE5vdGhpbmcgPSAnTm90aGluZycsXG59XG5cbi8qKiBTaW1wbHkgZGVmaW5lcyB0aGUgY29tbW9uIHNoYXBlIGZvciBgSnVzdGAgYW5kIGBOb3RoaW5nYC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWF5YmVTaGFwZTxUPiB7XG4gIC8qKiBEaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBgSnVzdGAgYW5kIGBOb3RoaW5nYCBbdmFyaWFudHNdKC4uL2VudW1zL19tYXliZV8udmFyaWFudCkuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQ7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzSnVzdGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzanVzdCkgKi9cbiAgaXNKdXN0KHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBKdXN0PFQ+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc05vdGhpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc25vdGhpbmcpICovXG4gIGlzTm90aGluZyh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgTm90aGluZzxUPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogTWF5YmU8VD4sIG1hcEZuOiAodDogVCkgPT4gVSk6IE1heWJlPFU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yKSAqL1xuICBtYXBPcjxVPih0aGlzOiBNYXliZTxUPiwgb3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcmVsc2UpICovXG4gIG1hcE9yRWxzZTxVPih0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFU7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hdGNoYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWF0Y2gpICovXG4gIG1hdGNoPFU+KHRoaXM6IE1heWJlPFQ+LCBtYXRjaGVyOiBNYXRjaGVyPFQsIFU+KTogVTtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcikgKi9cbiAgb3IodGhpczogTWF5YmU8VD4sIG1PcjogTWF5YmU8VD4pOiBNYXliZTxUPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3JlbHNlKSAqL1xuICBvckVsc2UodGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBNYXliZTxUPik6IE1heWJlPFQ+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmQpICovXG4gIGFuZDxVPih0aGlzOiBNYXliZTxUPiwgbUFuZDogTWF5YmU8VT4pOiBNYXliZTxVPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYW5kVGhlbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZHRoZW4pICovXG4gIGFuZFRoZW48VT4odGhpczogTWF5YmU8VD4sIGFuZFRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmNoYWluYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjY2hhaW4pICovXG4gIGNoYWluPFU+KHRoaXM6IE1heWJlPFQ+LCBjaGFpbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZmxhdE1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2ZsYXRtYXApICovXG4gIGZsYXRNYXA8VT4odGhpczogTWF5YmU8VD4sIGZsYXRNYXBGbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVud3JhcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcCkgKi9cbiAgdW5zYWZlbHlVbndyYXAoKTogVCB8IG5ldmVyO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bndyYXBvcmVsc2UpICovXG4gIHVud3JhcE9yRWxzZSh0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBUKTogVDtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9Pa09yRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZXJyKSAqL1xuICB0b09rT3JFcnI8RT4odGhpczogTWF5YmU8VD4sIGVycm9yOiBFKTogUmVzdWx0PFQsIEU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFbHNlRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZWxzZWVycikgKi9cbiAgdG9Pa09yRWxzZUVycjxFPih0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBFKTogUmVzdWx0PFQsIEU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b1N0cmluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvc3RyaW5nKSAqL1xuICB0b1N0cmluZyh0aGlzOiBNYXliZTxUPik6IHN0cmluZztcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZXF1YWxzYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZXF1YWxzKSAqL1xuICBlcXVhbHModGhpczogTWF5YmU8VD4sIGNvbXBhcmlzb246IE1heWJlPFQ+KTogYm9vbGVhbjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhcCkgKi9cbiAgYXA8VT4odGhpczogTWF5YmU8KHZhbDogVCkgPT4gVT4sIHZhbDogTWF5YmU8VD4pOiBNYXliZTxVPjtcbn1cblxuLyoqXG4gIEEgYEp1c3RgIGluc3RhbmNlIGlzIHRoZSAqcHJlc2VudCogdmFyaWFudCBpbnN0YW5jZSBvZiB0aGVcbiAgW2BNYXliZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21heWJlKSB0eXBlLCByZXByZXNlbnRpbmcgdGhlIHByZXNlbmNlIG9mIGFcbiAgdmFsdWUgd2hpY2ggbWF5IGJlIGFic2VudC4gRm9yIGEgZnVsbCBkaXNjdXNzaW9uLCBzZWUgW3RoZSBtb2R1bGVcbiAgZG9jc10oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSB3cmFwcGVkIGluIHRoaXMgYEp1c3RgIHZhcmlhbnQgb2YgYE1heWJlYC5cbiAqL1xuZXhwb3J0IGNsYXNzIEp1c3Q8VD4gaW1wbGVtZW50cyBNYXliZVNoYXBlPFQ+IHtcbiAgLyoqXG4gICAgVW53cmFwIHRoZSBjb250YWluZWQgdmFsdWUuIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBmdW5jdGlvbmFsIGlkaW9tcy5cblxuICAgIEEgY29tbW9uIHNjZW5hcmlvIHdoZXJlIHlvdSBtaWdodCB3YW50IHRvIHVzZSB0aGlzIGlzIGluIGEgcGlwZWxpbmUgb2ZcbiAgICBmdW5jdGlvbnM6XG5cbiAgICBgYGB0c1xuICAgIGltcG9ydCBNYXliZSwgeyBKdXN0IH0gZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICAgIGZ1bmN0aW9uIGdldExlbmd0aHMobWF5YmVTdHJpbmdzOiBBcnJheTxNYXliZTxzdHJpbmc+Pik6IEFycmF5PG51bWJlcj4ge1xuICAgICAgcmV0dXJuIG1heWJlU3RyaW5nc1xuICAgICAgICAuZmlsdGVyKE1heWJlLmlzSnVzdClcbiAgICAgICAgLm1hcChKdXN0LnVud3JhcClcbiAgICAgICAgLm1hcChzID0+IHMubGVuZ3RoKTtcbiAgICB9XG4gICAgYGBgXG4gICAqL1xuICBzdGF0aWMgdW53cmFwPEo+KHRoZUp1c3Q6IEp1c3Q8Sj4pOiBKIHtcbiAgICByZXR1cm4gdGhlSnVzdC52YWx1ZTtcbiAgfVxuXG4gIC8qKiBgSnVzdGAgaXMgYWx3YXlzIFtgVmFyaWFudC5KdXN0YF0oLi4vZW51bXMvX21heWJlXy52YXJpYW50I2p1c3QpLiAqL1xuICByZWFkb25seSB2YXJpYW50OiBWYXJpYW50Lkp1c3QgPSBWYXJpYW50Lkp1c3Q7XG5cbiAgLyoqIFRoZSB3cmFwcGVkIHZhbHVlLiAqL1xuICByZWFkb25seSB2YWx1ZTogVDtcblxuICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYE1heWJlLkp1c3RgIHdpdGggYG5ld2AuXG5cbiAgICBAbm90ZSBXaGlsZSB5b3UgKm1heSogY3JlYXRlIHRoZSBgSnVzdGAgdHlwZSB2aWEgbm9ybWFsIEphdmFTY3JpcHRcbiAgICBjbGFzcyBjb25zdHJ1Y3Rpb24sIGl0IGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdGhlIGZ1bmN0aW9uYWwgc3R5bGUgZm9yXG4gICAgd2hpY2ggdGhlIGxpYnJhcnkgaXMgaW50ZW5kZWQuIEluc3RlYWQsIHVzZSBbYE1heWJlLm9mYF0gKGZvciB0aGUgZ2VuZXJhbFxuICAgIGNhc2UpIG9yIFtgTWF5YmUuanVzdGBdIGZvciB0aGlzIHNwZWNpZmljIGNhc2UuXG5cbiAgICBbYE1heWJlLm9mYF06IC4uL21vZHVsZXMvX21heWJlXy5odG1sI29mXG4gICAgW2BNYXliZS5qdXN0YF06IC4uL21vZHVsZXMvX21heWJlXy5odG1sI2p1c3RcblxuICAgIGBgYHRzXG4gICAgLy8gQXZvaWQ6XG4gICAgY29uc3QgYVN0cmluZyA9IG5ldyBNYXliZS5KdXN0KCdjaGFyYWN0ZXJzJyk7XG5cbiAgICAvLyBQcmVmZXI6XG4gICAgY29uc3QgYVN0cmluZyA9IE1heWJlLmp1c3QoJ2NoYXJhY3RlcnMpO1xuICAgIGBgYFxuXG4gICAgQHBhcmFtIHZhbHVlXG4gICAgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgTWF5YmUuSnVzdGAuXG5cbiAgICBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBhbGxvd2VkIGJ5IHRoZSB0eXBlIHNpZ25hdHVyZSBzbyB0aGF0IHRoZVxuICAgIGNvbnN0cnVjdG9yIG1heSBgdGhyb3dgIG9uIHRob3NlIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHR5cGUgbGlrZVxuICAgIGBNYXliZTx1bmRlZmluZWQ+YC5cblxuICAgIEB0aHJvd3MgICAgICBJZiB5b3UgcGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZT86IFQgfCBudWxsKSB7XG4gICAgaWYgKGlzVm9pZCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gY29uc3RydWN0IGBKdXN0YCB3aXRoIGBudWxsYCBvciBgdW5kZWZpbmVkYCcpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc0p1c3RgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc2p1c3QpICovXG4gIGlzSnVzdCh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgSnVzdDxUPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuaXNOb3RoaW5nYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjaXNub3RoaW5nKSAqL1xuICBpc05vdGhpbmcodGhpczogTWF5YmU8VD4pOiB0aGlzIGlzIE5vdGhpbmc8VD4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXApICovXG4gIG1hcDxVPih0aGlzOiBNYXliZTxUPiwgbWFwRm46ICh0OiBUKSA9PiBVKTogTWF5YmU8VT4ge1xuICAgIHJldHVybiBtYXAobWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcE9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3IpICovXG4gIG1hcE9yPFU+KHRoaXM6IE1heWJlPFQ+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPcihvclUsIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcmVsc2UpICovXG4gIG1hcE9yRWxzZTxVPih0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPckVsc2Uob3JFbHNlRm4sIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXRjaGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hdGNoKSAqL1xuICBtYXRjaDxVPih0aGlzOiBNYXliZTxUPiwgbWF0Y2hlcjogTWF0Y2hlcjxULCBVPik6IFUge1xuICAgIHJldHVybiBtYXRjaChtYXRjaGVyLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI29yKSAqL1xuICBvcih0aGlzOiBNYXliZTxUPiwgbU9yOiBNYXliZTxUPik6IE1heWJlPFQ+IHtcbiAgICByZXR1cm4gb3IobU9yLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcmVsc2UpICovXG4gIG9yRWxzZSh0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IE1heWJlPFQ+KTogTWF5YmU8VD4ge1xuICAgIHJldHVybiBvckVsc2Uob3JFbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZCkgKi9cbiAgYW5kPFU+KHRoaXM6IE1heWJlPFQ+LCBtQW5kOiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gYW5kKG1BbmQsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZFRoZW5gXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmR0aGVuKSAqL1xuICBhbmRUaGVuPFU+KHRoaXM6IE1heWJlPFQ+LCBhbmRUaGVuRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gYW5kVGhlbihhbmRUaGVuRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmNoYWluYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjY2hhaW4pICovXG4gIGNoYWluPFU+KHRoaXM6IE1heWJlPFQ+LCBjaGFpbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIHRoaXMuYW5kVGhlbihjaGFpbkZuKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5mbGF0TWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZmxhdG1hcCkgKi9cbiAgZmxhdE1hcDxVPih0aGlzOiBNYXliZTxUPiwgZmxhdE1hcEZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIHRoaXMuYW5kVGhlbihmbGF0TWFwRm4pO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVuc2FmZWx5VW53cmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW5zYWZlbHl1bndyYXApICovXG4gIHVuc2FmZWx5VW53cmFwKCk6IFQge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVud3JhcE9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwb3IpICovXG4gIHVud3JhcE9yKHRoaXM6IE1heWJlPFQ+LCBkZWZhdWx0VmFsdWU6IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3IoZGVmYXVsdFZhbHVlLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bndyYXBvcmVsc2UpICovXG4gIHVud3JhcE9yRWxzZSh0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBUKTogVCB7XG4gICAgcmV0dXJuIHVud3JhcE9yRWxzZShlbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVycmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvb2tvcmVycikgKi9cbiAgdG9Pa09yRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlcnJvcjogRSk6IFJlc3VsdDxULCBFPiB7XG4gICAgcmV0dXJuIHRvT2tPckVycihlcnJvciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9Pa09yRWxzZUVycmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvb2tvcmVsc2VlcnIpICovXG4gIHRvT2tPckVsc2VFcnI8RT4odGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gRSk6IFJlc3VsdDxULCBFPiB7XG4gICAgcmV0dXJuIHRvT2tPckVsc2VFcnIoZWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b1N0cmluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvc3RyaW5nKSAqL1xuICB0b1N0cmluZyh0aGlzOiBNYXliZTxUPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmVxdWFsc2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2VxdWFscykgKi9cbiAgZXF1YWxzKHRoaXM6IE1heWJlPFQ+LCBjb21wYXJpc29uOiBNYXliZTxUPik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlcXVhbHMoY29tcGFyaXNvbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhcCkgKi9cbiAgYXA8QSwgQj4odGhpczogTWF5YmU8KHZhbDogQSkgPT4gQj4sIHZhbDogTWF5YmU8QT4pOiBNYXliZTxCPiB7XG4gICAgcmV0dXJuIGFwKHRoaXMsIHZhbCk7XG4gIH1cbn1cblxuLyoqXG4gIEEgYE5vdGhpbmdgIGluc3RhbmNlIGlzIHRoZSAqYWJzZW50KiB2YXJpYW50IGluc3RhbmNlIG9mIHRoZVxuICBbYE1heWJlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWF5YmUpIHR5cGUsIHJlcHJlc2VudGluZyB0aGUgcHJlc2VuY2Ugb2YgYVxuICB2YWx1ZSB3aGljaCBtYXkgYmUgYWJzZW50LiBGb3IgYSBmdWxsIGRpc2N1c3Npb24sIHNlZSBbdGhlIG1vZHVsZVxuICBkb2NzXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCkuXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIHdoaWNoIHdvdWxkIGJlIHdyYXBwZWQgaW4gYSBgSnVzdGAgdmFyaWFudCBvZiBgTWF5YmVgLlxuICovXG5leHBvcnQgY2xhc3MgTm90aGluZzxUPiBpbXBsZW1lbnRzIE1heWJlU2hhcGU8VD4ge1xuICAvKiogYE5vdGhpbmdgIGlzIGFsd2F5cyBbYFZhcmlhbnQuTm90aGluZ2BdKC4uL2VudW1zL19tYXliZV8udmFyaWFudCNub3RoaW5nKS4gKi9cbiAgcmVhZG9ubHkgdmFyaWFudDogVmFyaWFudC5Ob3RoaW5nID0gVmFyaWFudC5Ob3RoaW5nO1xuXG4gIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgTWF5YmUuTm90aGluZ2Agd2l0aCBgbmV3YC5cblxuICAgIEBub3RlIFdoaWxlIHlvdSAqbWF5KiBjcmVhdGUgdGhlIGBOb3RoaW5nYCB0eXBlIHZpYSBub3JtYWwgSmF2YVNjcmlwdFxuICAgIGNsYXNzIGNvbnN0cnVjdGlvbiwgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB0aGUgZnVuY3Rpb25hbCBzdHlsZSBmb3JcbiAgICB3aGljaCB0aGUgbGlicmFyeSBpcyBpbnRlbmRlZC4gSW5zdGVhZCwgdXNlIFtgTWF5YmUub2ZgXSAoZm9yIHRoZSBnZW5lcmFsXG4gICAgY2FzZSkgb3IgW2BNYXliZS5ub3RoaW5nYF0gZm9yIHRoaXMgc3BlY2lmaWMgY2FzZS5cblxuICAgIFtgTWF5YmUub2ZgXTogLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb2ZcbiAgICBbYE1heWJlLm5vdGhpbmdgXTogLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbm90aGluZ1xuXG4gICAgYGBgdHNcbiAgICAvLyBBdm9pZDpcbiAgICBjb25zdCBhTm90aGluZyA9IG5ldyBNYXliZS5FcnIoKTtcblxuICAgIC8vIFByZWZlcjpcbiAgICBjb25zdCBhTm90aGluZyA9IE1heWJlLm5vdGhpbmcoKTtcbiAgICBgYGBcblxuICAgIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGFsbG93ZWQgc28gdGhhdCB5b3UgbWF5IGV4cGxpY2l0bHkgY29uc3RydWN0IHRoZVxuICAgIGBFcnJgIHR5cGUgd2l0aCBhIGtub3duIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZS4gKFRoaXMgbWF5YmUgaGVscGZ1bFxuICAgIHByaW1hcmlseSB3aGVuIHRyYW5zaXRpb25pbmcgYSBjb2RlYmFzZSB0byB0aGUgdXNlIG9mIGBNYXliZWAuKVxuXG4gICAgQHRocm93cyAgICAgIElmIHlvdSBwYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKF8/OiBudWxsKSB7XG4gICAgLyogbm90aGluZyB0byBkbyAqL1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzSnVzdGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzanVzdCkgKi9cbiAgaXNKdXN0KHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBKdXN0PFQ+IHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuaXNOb3RoaW5nYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjaXNub3RoaW5nKSAqL1xuICBpc05vdGhpbmcodGhpczogTWF5YmU8VD4pOiB0aGlzIGlzIE5vdGhpbmc8VD4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcCkgKi9cbiAgbWFwPFU+KHRoaXM6IE1heWJlPFQ+LCBtYXBGbjogKHQ6IFQpID0+IFUpOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIG1hcChtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwT3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcikgKi9cbiAgbWFwT3I8VT4odGhpczogTWF5YmU8VD4sIG9yVTogVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVSB7XG4gICAgcmV0dXJuIG1hcE9yKG9yVSwgbWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcE9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yZWxzZSkgKi9cbiAgbWFwT3JFbHNlPFU+KHRoaXM6IE1heWJlPFQ+LCBvckVsc2VGbjogKCkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVSB7XG4gICAgcmV0dXJuIG1hcE9yRWxzZShvckVsc2VGbiwgbWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hdGNoYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWF0Y2gpICovXG4gIG1hdGNoPFU+KHRoaXM6IE1heWJlPFQ+LCBtYXRjaGVyOiBNYXRjaGVyPFQsIFU+KTogVSB7XG4gICAgcmV0dXJuIG1hdGNoKG1hdGNoZXIsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3IpICovXG4gIG9yKHRoaXM6IE1heWJlPFQ+LCBtT3I6IE1heWJlPFQ+KTogTWF5YmU8VD4ge1xuICAgIHJldHVybiBvcihtT3IsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI29yZWxzZSkgKi9cbiAgb3JFbHNlKHRoaXM6IE1heWJlPFQ+LCBvckVsc2VGbjogKCkgPT4gTWF5YmU8VD4pOiBNYXliZTxUPiB7XG4gICAgcmV0dXJuIG9yRWxzZShvckVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYW5kYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYW5kKSAqL1xuICBhbmQ8VT4odGhpczogTWF5YmU8VD4sIG1BbmQ6IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiBhbmQobUFuZCwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYW5kVGhlbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZHRoZW4pICovXG4gIGFuZFRoZW48VT4odGhpczogTWF5YmU8VD4sIGFuZFRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiBhbmRUaGVuKGFuZFRoZW5GbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuY2hhaW5gXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNjaGFpbikgKi9cbiAgY2hhaW48VT4odGhpczogTWF5YmU8VD4sIGNoYWluRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gdGhpcy5hbmRUaGVuKGNoYWluRm4pO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmZsYXRNYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNmbGF0bWFwKSAqL1xuICBmbGF0TWFwPFU+KHRoaXM6IE1heWJlPFQ+LCBmbGF0TWFwRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gdGhpcy5hbmRUaGVuKGZsYXRNYXBGbik7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW5zYWZlbHlVbndyYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bnNhZmVseXVud3JhcCkgKi9cbiAgdW5zYWZlbHlVbndyYXAoKTogbmV2ZXIge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gYHVuc2FmZWx5VW53cmFwKE5vdGhpbmcpYCcpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVud3JhcE9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwb3IpICovXG4gIHVud3JhcE9yKHRoaXM6IE1heWJlPFQ+LCBkZWZhdWx0VmFsdWU6IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3IoZGVmYXVsdFZhbHVlLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bndyYXBvcmVsc2UpICovXG4gIHVud3JhcE9yRWxzZSh0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBUKTogVCB7XG4gICAgcmV0dXJuIHVud3JhcE9yRWxzZShlbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVycmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvb2tvcmVycikgKi9cbiAgdG9Pa09yRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlcnJvcjogRSk6IFJlc3VsdDxULCBFPiB7XG4gICAgcmV0dXJuIHRvT2tPckVycihlcnJvciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9Pa09yRWxzZUVycmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvb2tvcmVsc2VlcnIpICovXG4gIHRvT2tPckVsc2VFcnI8RT4odGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gRSk6IFJlc3VsdDxULCBFPiB7XG4gICAgcmV0dXJuIHRvT2tPckVsc2VFcnIoZWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b1N0cmluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvc3RyaW5nKSAqL1xuICB0b1N0cmluZyh0aGlzOiBNYXliZTxUPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmVxdWFsc2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2VxdWFscykgKi9cbiAgZXF1YWxzKHRoaXM6IE1heWJlPFQ+LCBjb21wYXJpc29uOiBNYXliZTxUPik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlcXVhbHMoY29tcGFyaXNvbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhcCkgKi9cbiAgYXA8QSwgQj4odGhpczogTWF5YmU8KHZhbDogQSkgPT4gQj4sIHZhbDogTWF5YmU8QT4pOiBNYXliZTxCPiB7XG4gICAgcmV0dXJuIGFwKHRoaXMsIHZhbCk7XG4gIH1cbn1cblxuLyoqXG4gIElzIHRoaXMgcmVzdWx0IGEgYEp1c3RgIGluc3RhbmNlP1xuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGNoZWNrLlxuICBAcmV0dXJucyAgICAgYHRydWVgIGlmIGBtYXliZWAgaXMgYEp1c3RgLCBgZmFsc2VgIG90aGVyd2lzZS4gSW4gVHlwZVNjcmlwdCxcbiAgICAgICAgICAgICAgIGFsc28gbmFycm93cyB0aGUgdHlwZSBmcm9tIGBNYXliZTxUPmAgdG8gYEp1c3Q8VD5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKdXN0PFQ+KG1heWJlOiBNYXliZTxUPik6IG1heWJlIGlzIEp1c3Q8VD4ge1xuICByZXR1cm4gbWF5YmUudmFyaWFudCA9PT0gVmFyaWFudC5KdXN0O1xufVxuXG4vKipcbiAgSXMgdGhpcyByZXN1bHQgYSBgTm90aGluZ2AgaW5zdGFuY2U/XG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gbWF5YmUgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gIEByZXR1cm5zICAgICBgdHJ1ZWAgaWYgYG1heWJlYCBpcyBgbm90aGluZ2AsIGBmYWxzZWAgb3RoZXJ3aXNlLiBJbiBUeXBlU2NyaXB0LFxuICAgICAgICAgICAgICAgYWxzbyBuYXJyb3dzIHRoZSB0eXBlIGZyb20gYE1heWJlPFQ+YCB0byBgTm90aGluZzxUPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vdGhpbmc8VD4obWF5YmU6IE1heWJlPFQ+KTogbWF5YmUgaXMgTm90aGluZzxUPiB7XG4gIHJldHVybiBtYXliZS52YXJpYW50ID09PSBWYXJpYW50Lk5vdGhpbmc7XG59XG5cbi8qKlxuICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYE1heWJlLkp1c3RgLlxuXG4gIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGFsbG93ZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIHNvIHRoYXQgdGhlXG4gIGZ1bmN0aW9uIG1heSBgdGhyb3dgIG9uIHRob3NlIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHR5cGUgbGlrZVxuICBgTWF5YmU8dW5kZWZpbmVkPmAuXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSBpdGVtIGNvbnRhaW5lZCBpbiB0aGUgYE1heWJlYC5cbiAgQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYE1heWJlLkp1c3RgLlxuICBAcmV0dXJucyAgICAgQW4gaW5zdGFuY2Ugb2YgYE1heWJlLkp1c3Q8VD5gLlxuICBAdGhyb3dzICAgICAgSWYgeW91IHBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24ganVzdDxUPih2YWx1ZT86IFQgfCBudWxsKTogTWF5YmU8VD4ge1xuICByZXR1cm4gbmV3IEp1c3Q8VD4odmFsdWUpO1xufVxuXG4vKipcbiAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBNYXliZS5Ob3RoaW5nYC5cblxuICBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmljIHR5cGUsIGUuZy4gZm9yIHVzZSBpbiBhXG4gIGZ1bmN0aW9uIHdoaWNoIGV4cGVjdHMgYSBgTWF5YmU8VD5gIHdoZXJlIHRoZSBgPFQ+YCBpcyBrbm93biBidXQgeW91IGhhdmUgbm9cbiAgdmFsdWUgdG8gZ2l2ZSBpdCwgeW91IGNhbiB1c2UgYSB0eXBlIHBhcmFtZXRlcjpcblxuICBgYGB0c1xuICBjb25zdCBub3RTdHJpbmcgPSBNYXliZS5ub3RoaW5nPHN0cmluZz4oKTtcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSBpdGVtIGNvbnRhaW5lZCBpbiB0aGUgYE1heWJlYC5cbiAgQHJldHVybnMgICAgIEFuIGluc3RhbmNlIG9mIGBNYXliZS5Ob3RoaW5nPFQ+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdGhpbmc8VD4oXz86IG51bGwpOiBNYXliZTxUPiB7XG4gIHJldHVybiBuZXcgTm90aGluZzxUPihfKTtcbn1cblxuLyoqXG4gIENyZWF0ZSBhIGBNYXliZWAgZnJvbSBhbnkgdmFsdWUuXG5cbiAgVG8gc3BlY2lmeSB0aGF0IHRoZSByZXN1bHQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgc3BlY2lmaWMgdHlwZSwgeW91IG1heVxuICBpbnZva2UgYE1heWJlLm9mYCB3aXRoIGFuIGV4cGxpY2l0IHR5cGUgcGFyYW1ldGVyOlxuXG4gIGBgYHRzXG4gIGNvbnN0IGZvbyA9IE1heWJlLm9mPHN0cmluZz4obnVsbCk7XG4gIGBgYFxuXG4gIFRoaXMgaXMgdXN1YWxseSBvbmx5IGltcG9ydGFudCBpbiB0d28gY2FzZXM6XG5cbiAgMS4gIElmIHlvdSBhcmUgaW50ZW50aW9uYWxseSBjb25zdHJ1Y3RpbmcgYSBgTm90aGluZ2AgZnJvbSBhIGtub3duIGBudWxsYCBvclxuICAgICAgdW5kZWZpbmVkIHZhbHVlICp3aGljaCBpcyB1bnR5cGVkKi5cbiAgMi4gIElmIHlvdSBhcmUgc3BlY2lmeWluZyB0aGF0IHRoZSB0eXBlIGlzIG1vcmUgZ2VuZXJhbCB0aGFuIHRoZSB2YWx1ZSBwYXNzZWRcbiAgICAgIChzaW5jZSBUeXBlU2NyaXB0IGNhbiBkZWZpbmUgdHlwZXMgYXMgbGl0ZXJhbHMpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgaXRlbSBjb250YWluZWQgaW4gdGhlIGBNYXliZWAuXG4gIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBNYXliZWAuIElmIGl0IGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCxcbiAgICAgICAgICAgICAgIHRoZSByZXN1bHQgd2lsbCBiZSBgTm90aGluZ2A7IG90aGVyd2lzZSBpdCB3aWxsIGJlIHRoZSB0eXBlIG9mXG4gICAgICAgICAgICAgICB0aGUgdmFsdWUgcGFzc2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2Y8VD4odmFsdWU/OiBUIHwgbnVsbCk6IE1heWJlPFQ+IHtcbiAgcmV0dXJuIGlzVm9pZCh2YWx1ZSkgPyBub3RoaW5nPFQ+KCkgOiBqdXN0KHZhbHVlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYG9mYF0oI29mKSwgcHJpbWFyaWx5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggRm9sa3RhbGUuICovXG5leHBvcnQgY29uc3QgZnJvbU51bGxhYmxlID0gb2Y7XG5cbi8qKlxuICBNYXAgb3ZlciBhIGBNYXliZWAgaW5zdGFuY2U6IGFwcGx5IHRoZSBmdW5jdGlvbiB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiB0aGVcbiAgaW5zdGFuY2UgaXMgYEp1c3RgLCBhbmQgcmV0dXJuIGBOb3RoaW5nYCBpZiB0aGUgaW5zdGFuY2UgaXMgYE5vdGhpbmdgLlxuXG4gIGBNYXliZS5tYXBgIHdvcmtzIGEgbG90IGxpa2UgYEFycmF5LnByb3RvdHlwZS5tYXBgOiBgTWF5YmVgIGFuZCBgQXJyYXlgIGFyZVxuICBib3RoICpjb250YWluZXJzKiBmb3Igb3RoZXIgdGhpbmdzLiBJZiB5b3UgaGF2ZSBubyBpdGVtcyBpbiBhbiBhcnJheSBvZlxuICBudW1iZXJzIG5hbWVkIGBmb29gIGFuZCBjYWxsIGBmb28ubWFwKHggPT4geCArIDEpYCwgeW91J2xsIHN0aWxsIGp1c3QgaGF2ZSBhblxuICBhcnJheSB3aXRoIG5vdGhpbmcgaW4gaXQuIEJ1dCBpZiB5b3UgaGF2ZSBhbnkgaXRlbXMgaW4gdGhlIGFycmF5IChgWzIsIDNdYCksXG4gIGFuZCB5b3UgY2FsbCBgZm9vLm1hcCh4ID0+IHggKyAxKWAgb24gaXQsIHlvdSdsbCBnZXQgYSBuZXcgYXJyYXkgd2l0aCBlYWNoIG9mXG4gIHRob3NlIGl0ZW1zIGluc2lkZSB0aGUgYXJyYXkgXCJjb250YWluZXJcIiB0cmFuc2Zvcm1lZCAoYFszLCA0XWApLlxuXG4gIFRoYXQncyBleGFjdGx5IHdoYXQncyBoYXBwZW5pbmcgd2l0aCBgTWF5YmUubWFwYC4gSWYgdGhlIGNvbnRhaW5lciBpcyAqZW1wdHkqXG4gIOKAk8KgdGhlIGBOb3RoaW5nYCB2YXJpYW50IOKAkyB5b3UganVzdCBnZXQgYmFjayBhbiBlbXB0eSBjb250YWluZXIuIElmIHRoZVxuICBjb250YWluZXIgaGFzIHNvbWV0aGluZyBpbiBpdCDigJPCoHRoZSBgSnVzdGAgdmFyaWFudCDigJPCoHlvdSBnZXQgYmFjayBhIGNvbnRhaW5lclxuICB3aXRoIHRoZSBpdGVtIGluc2lkZSB0cmFuc2Zvcm1lZC5cblxuICAoU28uLi4gd2h5IG5vdCBqdXN0IHVzZSBhbiBhcnJheT8gVGhlIGJpZ2dlc3QgcmVhc29uIGlzIHRoYXQgYW4gYXJyYXkgY2FuIGJlXG4gIGFueSBsZW5ndGguIFdpdGggYSBgTWF5YmVgLCB3ZSdyZSBjYXB0dXJpbmcgdGhlIGlkZWEgb2YgXCJzb21ldGhpbmcgb3JcbiAgbm90aGluZ1wiIHJhdGhlciB0aGFuIFwiMCB0byBuXCIgaXRlbXMuIEFuZCB0aGlzIGxldHMgdXMgaW1wbGVtZW50IGEgd2hvbGUgc2V0XG4gIG9mICpvdGhlciogaW50ZXJmYWNlcywgbGlrZSB0aG9zZSBpbiB0aGlzIG1vZHVsZS4pXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGNvbnN0IGxlbmd0aCA9IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoO1xuXG4gIGNvbnN0IGp1c3RBU3RyaW5nID0gTWF5YmUuanVzdCgnc3RyaW5nJyk7XG4gIGNvbnN0IGp1c3RUaGVTdHJpbmdMZW5ndGggPSBtYXAobGVuZ3RoLCBqdXN0QVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKGp1c3RUaGVTdHJpbmdMZW5ndGgudG9TdHJpbmcoKSk7IC8vIEp1c3QoNilcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IG5vdEFTdHJpbmdMZW5ndGggPSBtYXAobGVuZ3RoLCBub3RBU3RyaW5nKTtcbiAgY29uc29sZS5sb2cobm90QVN0cmluZ0xlbmd0aC50b1N0cmluZygpKTsgLy8gXCJOb3RoaW5nXCJcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAdHlwZXBhcmFtIFUgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUgb2YgdGhlIHJldHVybmVkIGBNYXliZWAuXG4gIEBwYXJhbSBtYXBGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdGhlIHZhbHVlIHRvIGlmIGBNYXliZWAgaXMgYEp1c3RgLlxuICBAcGFyYW0gbWF5YmUgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gbWFwIG92ZXIuXG4gIEByZXR1cm5zICAgICBBIG5ldyBgTWF5YmVgIHdpdGggdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgbWFwRm5gIHRvIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgaW4gYSBgSnVzdGAsIG9yIGBOb3RoaW5nYCBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcDxULCBVPihtYXBGbjogKHQ6IFQpID0+IFUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVT4obWFwRm46ICh0OiBUKSA9PiBVLCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVT4oXG4gIG1hcEZuOiAodDogVCkgPT4gVSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogTWF5YmU8VT4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8ganVzdChtYXBGbihtLnZhbHVlKSkgOiBub3RoaW5nPFU+KCkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBtYXliZSk7XG59XG5cbi8qKlxuICBNYXAgb3ZlciBhIGBNYXliZWAgaW5zdGFuY2UgYW5kIGdldCBvdXQgdGhlIHZhbHVlIGlmIGBtYXliZWAgaXMgYSBgSnVzdGAsIG9yXG4gIHJldHVybiBhIGRlZmF1bHQgdmFsdWUgaWYgYG1heWJlYCBpcyBhIGBOb3RoaW5nYC5cblxuICAjIyMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgY29uc3QgbGVuZ3RoID0gKHM6IHN0cmluZykgPT4gcy5sZW5ndGg7XG5cbiAgY29uc3QganVzdEFTdHJpbmcgPSBNYXliZS5qdXN0KCdzdHJpbmcnKTtcbiAgY29uc3QgdGhlU3RyaW5nTGVuZ3RoID0gbWFwT3IoMCwgbGVuZ3RoLCBqdXN0QVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKHRoZVN0cmluZ0xlbmd0aCk7IC8vIDZcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IG5vdEFTdHJpbmdMZW5ndGggPSBtYXBPcigwLCBsZW5ndGgsIG5vdEFTdHJpbmcpXG4gIGNvbnNvbGUubG9nKG5vdEFTdHJpbmdMZW5ndGgpOyAvLyAwXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBVIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlIG9mIHRoZSByZXR1cm5lZCBgTWF5YmVgLlxuICBAcGFyYW0gb3JVICAgVGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIGBtYXliZWAgaXMgYE5vdGhpbmdgXG4gIEBwYXJhbSBtYXBGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdGhlIHZhbHVlIHRvIGlmIGBNYXliZWAgaXMgYEp1c3RgXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBtYXAgb3Zlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9yPFQsIFU+KG9yVTogVSwgbWFwRm46ICh0OiBUKSA9PiBVLCBtYXliZTogTWF5YmU8VD4pOiBVO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9yPFQsIFU+KG9yVTogVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVPihvclU6IFUpOiAobWFwRm46ICh0OiBUKSA9PiBVKSA9PiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcE9yPFQsIFU+KFxuICBvclU6IFUsXG4gIG1hcEZuPzogKHQ6IFQpID0+IFUsXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IFUgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVSkgfCAoKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKG1heWJlOiBNYXliZTxUPikgPT4gVSkge1xuICBmdW5jdGlvbiBmdWxsT3AoZm46ICh0OiBUKSA9PiBVLCBtOiBNYXliZTxUPikge1xuICAgIHJldHVybiBtLmlzSnVzdCgpID8gZm4obS52YWx1ZSkgOiBvclU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVKTogKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSwgY3VycmllZE1heWJlOiBNYXliZTxUPik6IFU7XG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUsIGN1cnJpZWRNYXliZT86IE1heWJlPFQ+KTogVSB8ICgobWF5YmU6IE1heWJlPFQ+KSA9PiBVKSB7XG4gICAgcmV0dXJuIGN1cnJpZWRNYXliZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZ1bGxPcChmbiwgY3VycmllZE1heWJlKVxuICAgICAgOiAoZXh0cmFDdXJyaWVkTWF5YmU6IE1heWJlPFQ+KSA9PiBmdWxsT3AoZm4sIGV4dHJhQ3VycmllZE1heWJlKTtcbiAgfVxuXG4gIHJldHVybiBtYXBGbiA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJ0aWFsT3BcbiAgICA6IG1heWJlID09PSB1bmRlZmluZWQgPyBwYXJ0aWFsT3AobWFwRm4pIDogcGFydGlhbE9wKG1hcEZuLCBtYXliZSk7XG59XG5cbi8qKlxuICBNYXAgb3ZlciBhIGBNYXliZWAgaW5zdGFuY2UgYW5kIGdldCBvdXQgdGhlIHZhbHVlIGlmIGBtYXliZWAgaXMgYSBgSnVzdGAsXG4gIG9yIHVzZSBhIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCBhIGRlZmF1bHQgdmFsdWUgaWYgYG1heWJlYCBpcyBgTm90aGluZ2AuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGNvbnN0IGxlbmd0aCA9IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoO1xuICBjb25zdCBnZXREZWZhdWx0ID0gKCkgPT4gMDtcblxuICBjb25zdCBqdXN0QVN0cmluZyA9IE1heWJlLmp1c3QoJ3N0cmluZycpO1xuICBjb25zdCB0aGVTdHJpbmdMZW5ndGggPSBtYXBPckVsc2UoZ2V0RGVmYXVsdCwgbGVuZ3RoLCBqdXN0QVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKHRoZVN0cmluZ0xlbmd0aCk7IC8vIDZcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IG5vdEFTdHJpbmdMZW5ndGggPSBtYXBPckVsc2UoZ2V0RGVmYXVsdCwgbGVuZ3RoLCBub3RBU3RyaW5nKVxuICBjb25zb2xlLmxvZyhub3RBU3RyaW5nTGVuZ3RoKTsgLy8gMFxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIG9yRWxzZUZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYC5cbiAgQHBhcmFtIG1hcEZuICAgIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiBgbWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gbWFwIG92ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4ob3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSwgbWF5YmU6IE1heWJlPFQ+KTogVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4ob3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3JFbHNlPFQsIFU+KG9yRWxzZUZuOiAoKSA9PiBVKTogKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4oXG4gIG9yRWxzZUZuOiAoKSA9PiBVLFxuICBtYXBGbj86ICh0OiBUKSA9PiBVLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHwgKChtYXBGbjogKHQ6IFQpID0+IFUpID0+IChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgZnVuY3Rpb24gZnVsbE9wKGZuOiAodDogVCkgPT4gVSwgbTogTWF5YmU8VD4pIHtcbiAgICByZXR1cm4gbS5pc0p1c3QoKSA/IGZuKG0udmFsdWUpIDogb3JFbHNlRm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVO1xuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVLCBjdXJyaWVkTWF5YmU6IE1heWJlPFQ+KTogVTtcbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSwgY3VycmllZE1heWJlPzogTWF5YmU8VD4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgICByZXR1cm4gY3VycmllZE1heWJlICE9PSB1bmRlZmluZWRcbiAgICAgID8gZnVsbE9wKGZuLCBjdXJyaWVkTWF5YmUpXG4gICAgICA6IChleHRyYUN1cnJpZWRNYXliZTogTWF5YmU8VD4pID0+IGZ1bGxPcChmbiwgZXh0cmFDdXJyaWVkTWF5YmUpO1xuICB9XG5cbiAgaWYgKG1hcEZuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcGFydGlhbE9wO1xuICB9IGVsc2UgaWYgKG1heWJlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcGFydGlhbE9wKG1hcEZuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbE9wKG1hcEZuLCBtYXliZSk7XG4gIH1cbn1cblxuLyoqXG4gIFlvdSBjYW4gdGhpbmsgb2YgdGhpcyBsaWtlIGEgc2hvcnQtY2lyY3VpdGluZyBsb2dpY2FsIFwiYW5kXCIgb3BlcmF0aW9uIG9uIGFcbiAgYE1heWJlYCB0eXBlLiBJZiBgbWF5YmVgIGlzIGBKdXN0YCwgdGhlbiB0aGUgcmVzdWx0IGlzIHRoZSBgYW5kTWF5YmVgLiBJZlxuICBgbWF5YmVgIGlzIGBOb3RoaW5nYCwgdGhlIHJlc3VsdCBpcyBgTm90aGluZ2AuXG5cbiAgVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhbm90aGVyIGBNYXliZWAgdmFsdWUgeW91IHdhbnQgdG8gcHJvdmlkZSBpZiBhbmRcbiAgKm9ubHkgaWYqIHlvdSBoYXZlIGEgYEp1c3RgIOKAkyB0aGF0IGlzLCB3aGVuIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHlvdVxuICBgTm90aGluZ2AsIHdoYXRldmVyIGVsc2UgeW91J3JlIGhhbmRpbmcgYSBgTWF5YmVgIHRvICphbHNvKiBnZXRzIGEgYE5vdGhpbmdgLlxuXG4gIE5vdGljZSB0aGF0LCB1bmxpa2UgaW4gW2BtYXBgXSgjbWFwKSBvciBpdHMgdmFyaWFudHMsIHRoZSBvcmlnaW5hbCBgbWF5YmVgIGlzXG4gIG5vdCBpbnZvbHZlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIG5ldyBgTWF5YmVgLlxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBqdXN0QSA9IE1heWJlLmp1c3QoJ0EnKTtcbiAgY29uc3QganVzdEIgPSBNYXliZS5qdXN0KCdCJyk7XG4gIGNvbnN0IG5vdGhpbmc6IE1heWJlPG51bWJlcj4gPSBub3RoaW5nKCk7XG5cbiAgY29uc29sZS5sb2coTWF5YmUuYW5kKGp1c3RCLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBKdXN0KEIpXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChqdXN0Qiwgbm90aGluZykudG9TdHJpbmcoKSk7ICAvLyBOb3RoaW5nXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChub3RoaW5nLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBOb3RoaW5nXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChub3RoaW5nLCBub3RoaW5nKS50b1N0cmluZygpKTsgIC8vIE5vdGhpbmdcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICAgIFRoZSB0eXBlIG9mIHRoZSBpbml0aWFsIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIGFuZE1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIHJldHVybiBpZiBgbWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gIEByZXR1cm4gICAgICAgICBgTm90aGluZ2AgaWYgdGhlIG9yaWdpbmFsIGBtYXliZWAgaXMgYE5vdGhpbmdgLCBvciBgYW5kTWF5YmVgXG4gICAgICAgICAgICAgICAgICBpZiB0aGUgb3JpZ2luYWwgYG1heWJlYCBpcyBgSnVzdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmQ8VCwgVT4oYW5kTWF5YmU6IE1heWJlPFU+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmQ8VCwgVT4oYW5kTWF5YmU6IE1heWJlPFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYW5kPFQsIFU+KFxuICBhbmRNYXliZTogTWF5YmU8VT4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IGFuZE1heWJlIDogbm90aGluZzxVPigpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgQXBwbHkgYSBmdW5jdGlvbiB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiBgSnVzdGAgYW5kIHJldHVybiBhIG5ldyBgSnVzdGBcbiAgY29udGFpbmluZyB0aGUgcmVzdWx0aW5nIHZhbHVlOyBvciByZXR1cm4gYE5vdGhpbmdgIGlmIGBOb3RoaW5nYC5cblxuICBUaGlzIGRpZmZlcnMgZnJvbSBgbWFwYCBpbiB0aGF0IGB0aGVuRm5gIHJldHVybnMgYW5vdGhlciBgTWF5YmVgLiBZb3UgY2FuIHVzZVxuICBgYW5kVGhlbmAgdG8gY29tYmluZSB0d28gZnVuY3Rpb25zIHdoaWNoICpib3RoKiBjcmVhdGUgYSBgTWF5YmVgIGZyb20gYW5cbiAgdW53cmFwcGVkIHR5cGUuXG5cbiAgWW91IG1heSBmaW5kIHRoZSBgLnRoZW5gIG1ldGhvZCBvbiBhbiBFUzYgYFByb21pc2VgIGhlbHBmdWwgZm9yIGI6XG4gIGlmIHlvdSBoYXZlIGEgYFByb21pc2VgLCB5b3UgY2FuIHBhc3MgaXRzIGB0aGVuYCBtZXRob2QgYSBjYWxsYmFjayB3aGljaFxuICByZXR1cm5zIGFub3RoZXIgYFByb21pc2VgLCBhbmQgdGhlIHJlc3VsdCB3aWxsIG5vdCBiZSBhICpuZXN0ZWQqIHByb21pc2UsIGJ1dFxuICBhIHNpbmdsZSBgUHJvbWlzZWAuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgYFByb21pc2UjdGhlbmAgdW53cmFwcyAqYWxsKlxuICBsYXllcnMgdG8gb25seSBldmVyIHJldHVybiBhIHNpbmdsZSBgUHJvbWlzZWAgdmFsdWUsIHdoZXJlYXMgYE1heWJlLmFuZFRoZW5gXG4gIHdpbGwgbm90IHVud3JhcCBuZXN0ZWQgYE1heWJlYHMuXG5cbiAgVGhpcyBpcyBhbHNvIGNvbW1vbmx5IGtub3duIGFzIChhbmQgdGhlcmVmb3JlIGFsaWFzZWQgYXMpIFtgZmxhdE1hcGBdIG9yXG4gIFtgY2hhaW5gXS4gSXQgaXMgc29tZXRpbWVzIGFsc28ga25vd24gYXMgYGJpbmRgLCBidXQgKm5vdCogYWxpYXNlZCBhcyBzdWNoXG4gIGJlY2F1c2UgW2BiaW5kYCBhbHJlYWR5IG1lYW5zIHNvbWV0aGluZyBpbiBKYXZhU2NyaXB0XVtiaW5kXS5cblxuICBbYGZsYXRNYXBgXTogI2ZsYXRtYXBcbiAgW2BjaGFpbmBdOiAjY2hhaW5cbiAgW2JpbmRdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXG5cbiAgIyMjIyBFeGFtcGxlXG5cbiAgKFRoaXMgaXMgYSBzb21ld2hhdCBjb250cml2ZWQgZXhhbXBsZSwgYnV0IGl0IHNlcnZlcyB0byBzaG93IHRoZSB3YXkgdGhlXG4gIGZ1bmN0aW9uIGJlaGF2ZXMuKVxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIC8vIHN0cmluZyAtPiBNYXliZTxudW1iZXI+XG4gIGNvbnN0IHRvTWF5YmVMZW5ndGggPSAoczogc3RyaW5nKTogTWF5YmU8bnVtYmVyPiA9PiBNYXliZS5vZihzLmxlbmd0aCk7XG5cbiAgLy8gTWF5YmU8c3RyaW5nPlxuICBjb25zdCBhTWF5YmVTdHJpbmcgPSBNYXliZS5vZignSGVsbG8sIHRoZXJlIScpO1xuXG4gIC8vIE1heWJlPG51bWJlcj5cbiAgY29uc3QgcmVzdWx0aW5nTGVuZ3RoID0gTWF5YmUuYW5kVGhlbih0b01heWJlTGVuZ3RoLCBhTWF5YmVTdHJpbmcpO1xuICBjb25zb2xlLmxvZyhNYXliZS50b1N0cmluZyhyZXN1bHRpbmdMZW5ndGgpKTsgLy8gMTNcbiAgYGBgXG5cbiAgTm90ZSB0aGF0IHRoZSByZXN1bHQgaXMgbm90IGAoSnVzdCgxMykpYCwgYnV0IGAxM2AhXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBpbiB0aGUgcmVzdWx0aW5nIGBNYXliZWAuXG4gIEBwYXJhbSB0aGVuRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB3cmFwcGVkIGBUYCBpZiBgbWF5YmVgIGlzIGBKdXN0YC5cbiAgQHBhcmFtIG1heWJlICBUaGUgYE1heWJlYCB0byBldmFsdWF0ZSBhbmQgcG9zc2libHkgYXBwbHkgYSBmdW5jdGlvbiB0byB0aGVcbiAgICAgICAgICAgICAgICBjb250ZW50cyBvZi5cbiAgQHJldHVybnMgICAgICBUaGUgcmVzdWx0IG9mIHRoZSBgdGhlbkZuYCAoYSBuZXcgYE1heWJlYCkgaWYgYG1heWJlYCBpcyBhXG4gICAgICAgICAgICAgICAgYEp1c3RgLCBvdGhlcndpc2UgYE5vdGhpbmdgIGlmIGBtYXliZWAgaXMgYSBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmRUaGVuPFQsIFU+KHRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmRUaGVuPFQsIFU+KHRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYW5kVGhlbjxULCBVPihcbiAgdGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IHRoZW5GbihtLnZhbHVlKSA6IG5vdGhpbmc8VT4oKSk7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkID8gb3AobWF5YmUpIDogb3A7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2BhbmRUaGVuYF0oI2FuZHRoZW4pLiAqL1xuZXhwb3J0IGNvbnN0IGNoYWluID0gYW5kVGhlbjtcblxuLyoqIEFsaWFzIGZvciBbYGFuZFRoZW5gXSgjYW5kdGhlbikuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcCA9IGFuZFRoZW47XG5cbi8qKlxuICBQcm92aWRlIGEgZmFsbGJhY2sgZm9yIGEgZ2l2ZW4gYE1heWJlYC4gQmVoYXZlcyBsaWtlIGEgbG9naWNhbCBgb3JgOiBpZiB0aGVcbiAgYG1heWJlYCB2YWx1ZSBpcyBhIGBKdXN0YCwgcmV0dXJucyB0aGF0IGBtYXliZWA7IG90aGVyd2lzZSwgcmV0dXJucyB0aGVcbiAgYGRlZmF1bHRNYXliZWAgdmFsdWUuXG5cbiAgVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBzb21ldGhpbmcgd2hpY2ggdGFrZXMgYVxuICBgTWF5YmVgIGFsd2F5cyBlbmRzIHVwIGdldHRpbmcgYSBgSnVzdGAgdmFyaWFudCwgYnkgc3VwcGx5aW5nIGEgZGVmYXVsdCB2YWx1ZVxuICBmb3IgdGhlIGNhc2UgdGhhdCB5b3UgY3VycmVudGx5IGhhdmUgYSBub3RoaW5nLlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLXV0aWxzL21heWJlJztcblxuICBjb25zdCBqdXN0QSA9IE1heWJlLmp1c3QoXCJhXCIpO1xuICBjb25zdCBqdXN0QiA9IE1heWJlLmp1c3QoXCJiXCIpO1xuICBjb25zdCBhTm90aGluZzogTWF5YmU8c3RyaW5nPiA9IG5vdGhpbmcoKTtcblxuICBjb25zb2xlLmxvZyhNYXliZS5vcihqdXN0QiwganVzdEEpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChBKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihhTm90aGluZywganVzdEEpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChBKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihqdXN0QiwgYU5vdGhpbmcpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChCKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihhTm90aGluZywgYU5vdGhpbmcpLnRvU3RyaW5nKCkpOyAgLy8gTm90aGluZ1xuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gZGVmYXVsdE1heWJlIFRoZSBgTWF5YmVgIHRvIHVzZSBpZiBgbWF5YmVgIGlzIGEgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWF5YmUgICAgICAgIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGV2YWx1YXRlLlxuICBAcmV0dXJucyAgICAgICAgICAgIGBtYXliZWAgaWYgaXQgaXMgYSBgSnVzdGAsIG90aGVyd2lzZSBgZGVmYXVsdE1heWJlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yPFQ+KGRlZmF1bHRNYXliZTogTWF5YmU8VD4sIG1heWJlOiBNYXliZTxUPik6IE1heWJlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG9yPFQ+KGRlZmF1bHRNYXliZTogTWF5YmU8VD4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBvcjxUPihcbiAgZGVmYXVsdE1heWJlOiBNYXliZTxUPixcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogTWF5YmU8VD4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VD4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gbSA6IGRlZmF1bHRNYXliZSk7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkID8gb3AobWF5YmUpIDogb3A7XG59XG5cbi8qKlxuICBMaWtlIGBvcmAsIGJ1dCB1c2luZyBhIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCB0aGUgYWx0ZXJuYXRpdmUgYE1heWJlYC5cblxuICBTb21ldGltZXMgeW91IG5lZWQgdG8gcGVyZm9ybSBhbiBvcGVyYXRpb24gdXNpbmcgb3RoZXIgZGF0YSBpbiB0aGVcbiAgZW52aXJvbm1lbnQgdG8gY29uc3RydWN0IHRoZSBmYWxsYmFjayB2YWx1ZS4gSW4gdGhlc2Ugc2l0dWF0aW9ucywgeW91IGNhblxuICBwYXNzIGEgZnVuY3Rpb24gKHdoaWNoIG1heSBiZSBhIGNsb3N1cmUpIGFzIHRoZSBgZWxzZUZuYCB0byBnZW5lcmF0ZSB0aGVcbiAgZmFsbGJhY2sgYE1heWJlPFQ+YC5cblxuICBVc2VmdWwgZm9yIHRyYW5zZm9ybWluZyBlbXB0eSBzY2VuYXJpb3MgYmFzZWQgb24gdmFsdWVzIGluIGNvbnRleHQuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIGVsc2VGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgaWYgYG1heWJlYCBpcyBgTm90aGluZ2BcbiAgQHBhcmFtIG1heWJlICBUaGUgYG1heWJlYCB0byB1c2UgaWYgaXQgaXMgYEp1c3RgLlxuICBAcmV0dXJucyAgICAgIFRoZSBgbWF5YmVgIGlmIGl0IGlzIGBKdXN0YCwgb3IgdGhlIGBNYXliZWAgcmV0dXJuZWQgYnlcbiAgICAgICAgICAgICAgICBgZWxzZUZuYCBpZiB0aGUgYG1heWJlYCBpcyBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VD4oZWxzZUZuOiAoKSA9PiBNYXliZTxUPiwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VD47XG5leHBvcnQgZnVuY3Rpb24gb3JFbHNlPFQ+KGVsc2VGbjogKCkgPT4gTWF5YmU8VD4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VD4oXG4gIGVsc2VGbjogKCkgPT4gTWF5YmU8VD4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFQ+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFQ+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IG0gOiBlbHNlRm4oKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqXG4gIEdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSBgTWF5YmVgLlxuXG4gIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgYSBgSnVzdGAsIGJ1dCAqKnRocm93cyBpZiB0aGUgYE1heWJlYCBpcyBgTm90aGluZ2AqKi5cbiAgUHJlZmVyIHRvIHVzZSBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSBvciBbYHVud3JhcE9yRWxzZWBdKCN1bndyYXBvcmVsc2UpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG1heWJlIFRoZSB2YWx1ZSB0byB1bndyYXBcbiAgQHJldHVybnMgICAgIFRoZSB1bndyYXBwZWQgdmFsdWUgaWYgdGhlIGBNYXliZWAgaW5zdGFuY2UgaXMgYEp1c3RgLlxuICBAdGhyb3dzICAgICAgSWYgdGhlIGBtYXliZWAgaXMgYE5vdGhpbmdgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlbHlVbndyYXA8VD4obWF5YmU6IE1heWJlPFQ+KTogVCB7XG4gIHJldHVybiBtYXliZS51bnNhZmVseVVud3JhcCgpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgdW5zYWZlbHlVbndyYXBgXSgjdW5zYWZlbHl1bndyYXApICovXG5leHBvcnQgY29uc3QgdW5zYWZlbHlHZXQgPSB1bnNhZmVseVVud3JhcDtcblxuLyoqIEFsaWFzIGZvciBbYHVuc2FmZWx5VW53cmFwYF0oI3Vuc2FmZWx5dW53cmFwKSAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZUdldCA9IHVuc2FmZWx5VW53cmFwO1xuXG4vKipcbiAgU2FmZWx5IGdldCB0aGUgdmFsdWUgb3V0IG9mIGEgYE1heWJlYC5cblxuICBSZXR1cm5zIHRoZSBjb250ZW50IG9mIGEgYEp1c3RgIG9yIGBkZWZhdWx0VmFsdWVgIGlmIGBOb3RoaW5nYC4gVGhpcyBpcyB0aGVcbiAgcmVjb21tZW5kZWQgd2F5IHRvIGdldCBhIHZhbHVlIG91dCBvZiBhIGBNYXliZWAgbW9zdCBvZiB0aGUgdGltZS5cblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IGlzQVN0cmluZyA9IE1heWJlLmp1c3QoJ2xvb2sgbWEhIHNvbWUgY2hhcmFjdGVycyEnKTtcblxuICBjb25zb2xlLmxvZyhNYXliZS51bndyYXBPcignPGVtcHR5PicsIG5vdEFTdHJpbmcpKTsgIC8vIFwiPGVtcHR5PlwiXG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yKCc8ZW1wdHk+JywgaXNBU3RyaW5nKSk7ICAvLyBcImxvb2sgbWEhIHNvbWUgY2hhcmFjdGVycyFcIlxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYG1heWJlYCBpcyBhIGBOb3RoaW5nYC5cbiAgQHBhcmFtIG1heWJlICAgICAgICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byB1bndyYXAgaWYgaXQgaXMgYSBgSnVzdGAuXG4gIEByZXR1cm5zICAgICAgICAgICAgVGhlIGNvbnRlbnQgb2YgYG1heWJlYCBpZiBpdCBpcyBhIGBKdXN0YCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgICAgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxUPihkZWZhdWx0VmFsdWU6IFQsIG1heWJlOiBNYXliZTxUPik6IFQ7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3I8VD4oZGVmYXVsdFZhbHVlOiBUKTogKG1heWJlOiBNYXliZTxUPikgPT4gVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxUPihkZWZhdWx0VmFsdWU6IFQsIG1heWJlPzogTWF5YmU8VD4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gbS52YWx1ZSA6IGRlZmF1bHRWYWx1ZSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSAqL1xuZXhwb3J0IGNvbnN0IGdldE9yID0gdW53cmFwT3I7XG5cbi8qKlxuICBTYWZlbHkgZ2V0IHRoZSB2YWx1ZSBvdXQgb2YgYSBbYE1heWJlYF0oI21heWJlKSBieSByZXR1cm5pbmcgdGhlIHdyYXBwZWRcbiAgdmFsdWUgaWYgaXQgaXMgYEp1c3RgLCBvciBieSBhcHBseWluZyBgb3JFbHNlRm5gIGlmIGl0IGlzIGBOb3RoaW5nYC5cblxuICBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvICpnZW5lcmF0ZSogYSB2YWx1ZSAoZS5nLiBieSB1c2luZyBjdXJyZW50XG4gIHZhbHVlcyBpbiB0aGUgZW52aXJvbm1lbnQg4oCTIHdoZXRoZXIgcHJlbG9hZGVkIG9yIGJ5IGxvY2FsIGNsb3N1cmUpIGluc3RlYWQgb2ZcbiAgaGF2aW5nIGEgc2luZ2xlIGRlZmF1bHQgdmFsdWUgYXZhaWxhYmxlIChhcyBpbiBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSkuXG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgLy8gWW91IGNhbiBpbWFnaW5lIHRoYXQgc29tZU90aGVyVmFsdWUgbWlnaHQgYmUgZHluYW1pYy5cbiAgY29uc3Qgc29tZU90aGVyVmFsdWUgPSA5OTtcbiAgY29uc3QgaGFuZGxlTm90aGluZyA9ICgpID0+IHNvbWVPdGhlclZhbHVlO1xuXG4gIGNvbnN0IGFKdXN0ID0gTWF5YmUuanVzdCg0Mik7XG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yRWxzZShoYW5kbGVOb3RoaW5nLCBhSnVzdCkpOyAgLy8gNDJcblxuICBjb25zdCBhTm90aGluZyA9IG5vdGhpbmc8bnVtYmVyPigpO1xuICBjb25zb2xlLmxvZyhNYXliZS51bndyYXBPckVsc2UoaGFuZGxlTm90aGluZywgYU5vdGhpbmcpKTsgLy8gOTlcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG9yRWxzZUZuIEEgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIHZhbGlkIHZhbHVlIGlmIGBtYXliZWAgaXMgYVxuICAgICAgICAgICAgICAgICAgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gdW53cmFwIGlmIGl0IGlzIGEgYEp1c3RgXG4gIEByZXR1cm5zICAgICAgICBFaXRoZXIgdGhlIGNvbnRlbnQgb2YgYG1heWJlYCBvciB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbVxuICAgICAgICAgICAgICAgICAgYG9yRWxzZUZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxUPihvckVsc2VGbjogKCkgPT4gVCwgbWF5YmU6IE1heWJlPFQ+KTogVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPckVsc2U8VD4ob3JFbHNlRm46ICgpID0+IFQpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBUO1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxUPihvckVsc2VGbjogKCkgPT4gVCwgbWF5YmU/OiBNYXliZTxUPik6IFQgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVCkge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBtLnZhbHVlIDogb3JFbHNlRm4oKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYHVud3JhcE9yRWxzZWBdKCN1bndyYXBvcmVsc2UpICovXG5leHBvcnQgY29uc3QgZ2V0T3JFbHNlID0gdW53cmFwT3JFbHNlO1xuXG4vKipcbiAgVHJhbnNmb3JtIHRoZSBbYE1heWJlYF0oI21heWJlKSBpbnRvIGFcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSwgdXNpbmcgdGhlIHdyYXBwZWQgdmFsdWUgYXMgdGhlXG4gIGBPa2AgdmFsdWUgaWYgYEp1c3RgOyBvdGhlcndpc2UgdXNpbmcgdGhlIHN1cHBsaWVkIGBlcnJvcmAgdmFsdWUgZm9yIGBFcnJgLlxuXG4gIEB0eXBlcGFyYW0gVCAgVGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gRSAgVGhlIGVycm9yIHR5cGUgdG8gaW4gdGhlIGBSZXN1bHRgLlxuICBAcGFyYW0gZXJyb3IgVGhlIGVycm9yIHZhbHVlIHRvIHVzZSBpZiB0aGUgYE1heWJlYCBpcyBgTm90aGluZ2AuXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjb252ZXJ0LlxuICBAcmV0dXJucyAgICAgQSBgUmVzdWx0YCBjb250YWluaW5nIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGBtYXliZWAgaW4gYW4gYE9rYCxcbiAgICAgICAgICAgICAgIG9yIGBlcnJvcmAgaW4gYW4gYEVycmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFcnI8VCwgRT4oZXJyb3I6IEUsIG1heWJlOiBNYXliZTxUPik6IFJlc3VsdDxULCBFPjtcbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFcnI8VCwgRT4oZXJyb3I6IEUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBSZXN1bHQ8VCwgRT47XG5leHBvcnQgZnVuY3Rpb24gdG9Pa09yRXJyPFQsIEU+KFxuICBlcnJvcjogRSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogUmVzdWx0PFQsIEU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBvazxULCBFPihtLnZhbHVlKSA6IGVycjxULCBFPihlcnJvcikpO1xuICByZXR1cm4gbWF5YmUgIT09IHVuZGVmaW5lZCA/IG9wKG1heWJlKSA6IG9wO1xufVxuXG4vKipcbiAgVHJhbnNmb3JtIHRoZSBbYE1heWJlYF0oI21heWJlKSBpbnRvIGFcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSwgdXNpbmcgdGhlIHdyYXBwZWQgdmFsdWUgYXMgdGhlXG4gIGBPa2AgdmFsdWUgaWYgYEp1c3RgOyBvdGhlcndpc2UgdXNpbmcgYGVsc2VGbmAgdG8gZ2VuZXJhdGUgYEVycmAuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBFICBUaGUgZXJyb3IgdHlwZSB0byBpbiB0aGUgYFJlc3VsdGAuXG4gIEBwYXJhbSBlbHNlRm4gVGhlIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyBhbiBlcnJvciBvZiB0eXBlIGBFYC5cbiAgQHBhcmFtIG1heWJlICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjb252ZXJ0LlxuICBAcmV0dXJucyAgICAgQSBgUmVzdWx0YCBjb250YWluaW5nIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGBtYXliZWAgaW4gYW4gYE9rYCxcbiAgICAgICAgICAgICAgIG9yIHRoZSB2YWx1ZSBnZW5lcmF0ZWQgYnkgYGVsc2VGbmAgaW4gYW4gYEVycmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFbHNlRXJyPFQsIEU+KGVsc2VGbjogKCkgPT4gRSwgbWF5YmU6IE1heWJlPFQ+KTogUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVsc2VFcnI8VCwgRT4oZWxzZUZuOiAoKSA9PiBFKTogKG1heWJlOiBNYXliZTxUPikgPT4gUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVsc2VFcnI8VCwgRT4oXG4gIGVsc2VGbjogKCkgPT4gRSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogUmVzdWx0PFQsIEU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBvazxULCBFPihtLnZhbHVlKSA6IGVycjxULCBFPihlbHNlRm4oKSkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBtYXliZSk7XG59XG5cbi8qKlxuICBDb25zdHJ1Y3QgYSBgTWF5YmU8VD5gIGZyb20gYSBgUmVzdWx0PFQsIEU+YC5cblxuICBJZiB0aGUgYFJlc3VsdGAgaXMgYW4gYE9rYCwgd3JhcCBpdHMgdmFsdWUgaW4gYEp1c3RgLiBJZiB0aGUgYFJlc3VsdGAgaXMgYW5cbiAgYEVycmAsIHRocm93IGF3YXkgdGhlIHdyYXBwZWQgYEVgIGFuZCB0cmFuc2Zvcm0gdG8gYSBgTm90aGluZ2AuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiBhIGBSZXN1bHQuT2tgIGFuZCBpbiB0aGUgYEp1c3RgXG4gICAgICAgICAgICAgICAgb2YgdGhlIHJlc3VsdGluZyBgTWF5YmVgLlxuICBAdHlwZXBhcmFtIEUgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGEgYFJlc3VsdC5FcnJgOyB0aHJvd24gYXdheSBpblxuICAgICAgICAgICAgICAgIHRoZSByZXN1bHRpbmcgYE1heWJlYC5cbiAgQHBhcmFtIHJlc3VsdCBUaGUgYFJlc3VsdGAgdG8gY29uc3RydWN0IGEgYE1heWJlYCBmcm9tLlxuICBAcmV0dXJucyAgICAgIGBKdXN0YCBpZiBgcmVzdWx0YCB3YXMgYE9rYCBvciBgTm90aGluZ2AgaWYgaXQgd2FzIGBFcnJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJlc3VsdDxUPihyZXN1bHQ6IFJlc3VsdDxULCBhbnk+KTogTWF5YmU8VD4ge1xuICByZXR1cm4gcmVzdWx0LmlzT2soKSA/IGp1c3QocmVzdWx0LnZhbHVlKSA6IG5vdGhpbmc8VD4oKTtcbn1cblxuLyoqXG4gIENyZWF0ZSBhIGBTdHJpbmdgIHJlcHJlc2VudGF0aW9uIG9mIGEgYE1heWJlYCBpbnN0YW5jZS5cblxuICBBIGBKdXN0YCBpbnN0YW5jZSB3aWxsIGJlIHByaW50ZWQgYXMgYEp1c3QoPHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZT4pYCxcbiAgd2hlcmUgdGhlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSBpcyBzaW1wbHkgdGhlIHZhbHVlJ3Mgb3duIGB0b1N0cmluZ2BcbiAgcmVwcmVzZW50YXRpb24uIEZvciBleGFtcGxlOlxuXG4gIHwgY2FsbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBvdXRwdXQgICAgICAgICAgICAgICAgICB8XG4gIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKDQyKSlgICAgICAgICAgICAgICAgfCBgSnVzdCg0MilgICAgICAgICAgICAgICB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKFsxLCAyLCAzXSkpYCAgICAgICAgfCBgSnVzdCgxLDIsMylgICAgICAgICAgICB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKHsgYW46ICdvYmplY3QnIH0pKWAgfCBgSnVzdChbb2JqZWN0IE9iamVjdF0pYCB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm5vdGhpbmcoKSlgICAgICAgICAgICAgfCBgTm90aGluZ2AgICAgICAgICAgICAgICB8XG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlOyBpdHMgb3duIGAudG9TdHJpbmdgIHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgICAgdG8gcHJpbnQgdGhlIGludGVyaW9yIGNvbnRlbnRzIG9mIHRoZSBgSnVzdGAgdmFyaWFudC5cbiAgQHBhcmFtIG1heWJlIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICBAcmV0dXJucyAgICAgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYE1heWJlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nPFQ+KG1heWJlOiBNYXliZTxUPik6IHN0cmluZyB7XG4gIGNvbnN0IGJvZHkgPSBtYXliZS5pc0p1c3QoKSA/IGAoJHttYXliZS52YWx1ZS50b1N0cmluZygpfSlgIDogJyc7XG4gIHJldHVybiBgJHttYXliZS52YXJpYW50fSR7Ym9keX1gO1xufVxuXG4vKiogQSBsaWdodHdlaWdodCBvYmplY3QgZGVmaW5pbmcgaG93IHRvIGhhbmRsZSBlYWNoIHZhcmlhbnQgb2YgYSBNYXliZS4gKi9cbmV4cG9ydCB0eXBlIE1hdGNoZXI8VCwgQT4gPSB7XG4gIEp1c3Q6ICh2YWx1ZTogVCkgPT4gQTtcbiAgTm90aGluZzogKCkgPT4gQTtcbn07XG5cbi8qKlxuICBQZXJmb3JtcyB0aGUgc2FtZSBiYXNpYyBmdW5jdGlvbmFsaXR5IGFzIGBnZXRPckVsc2VgLCBidXQgaW5zdGVhZCBvZiBzaW1wbHlcbiAgdW53cmFwcGluZyB0aGUgdmFsdWUgaWYgaXQgaXMgYEp1c3RgIGFuZCBhcHBseWluZyBhIHZhbHVlIHRvIGdlbmVyYXRlIHRoZSBzYW1lXG4gIGRlZmF1bHQgdHlwZSBpZiBpdCBpcyBgTm90aGluZ2AsIGxldHMgeW91IHN1cHBseSBmdW5jdGlvbnMgd2hpY2ggbWF5IHRyYW5zZm9ybVxuICB0aGUgd3JhcHBlZCB0eXBlIGlmIGl0IGlzIGBKdXN0YCBvciBnZXQgYSBkZWZhdWx0IHZhbHVlIGZvciBgTm90aGluZ2AuXG5cbiAgVGhpcyBpcyBraW5kIG9mIGxpa2UgYSBwb29yIG1hbidzIHZlcnNpb24gb2YgcGF0dGVybiBtYXRjaGluZywgd2hpY2hcbiAgSmF2YVNjcmlwdCBjdXJyZW50bHkgbGFja3MuXG5cbiAgSW5zdGVhZCBvZiBjb2RlIGxpa2UgdGhpczpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBsb2dWYWx1ZSA9IChtaWdodEJlQU51bWJlcjogTWF5YmU8bnVtYmVyPikgPT4ge1xuICAgIGNvbnN0IHZhbHVlVG9Mb2cgPSBNYXliZS5taWdodEJlQU51bWJlci5pc0p1c3QoKVxuICAgICAgPyBNYXliZS51bnNhZmVseVVud3JhcChtaWdodEJlQU51bWJlcikudG9TdHJpbmcoKVxuICAgICAgOiAnTm90aGluZyB0byBsb2cuJztcblxuICAgIGNvbnNvbGUubG9nKHZhbHVlVG9Mb2cpO1xuICB9O1xuICBgYGBcblxuICAuLi53ZSBjYW4gd3JpdGUgY29kZSBsaWtlIHRoaXM6XG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgY29uc3QgbG9nVmFsdWUgPSAobWlnaHRCZUFOdW1iZXI6IE1heWJlPG51bWJlcj4pID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IE1heWJlLm1hdGNoKFxuICAgICAge1xuICAgICAgICBKdXN0OiBuID0+IG4udG9TdHJpbmcoKSxcbiAgICAgICAgTm90aGluZzogKCkgPT4gJ05vdGhpbmcgdG8gbG9nLicsXG4gICAgICB9LFxuICAgICAgbWlnaHRCZUFOdW1iZXJcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2codmFsdWUpO1xuICB9O1xuICBgYGBcblxuICBUaGlzIGlzIHNsaWdodGx5IGxvbmdlciB0byB3cml0ZSwgYnV0IGNsZWFyZXI6IHRoZSBtb3JlIGNvbXBsZXggdGhlIHJlc3VsdGluZ1xuICBleHByZXNzaW9uLCB0aGUgaGFpcmVyIGl0IGlzIHRvIHVuZGVyc3RhbmQgdGhlIHRlcm5hcnkuIFRodXMsIHRoaXMgaXNcbiAgZXNwZWNpYWxseSBjb252ZW5pZW50IGZvciB0aW1lcyB3aGVuIHRoZXJlIGlzIGEgY29tcGxleCByZXN1bHQsIGUuZy4gd2hlblxuICByZW5kZXJpbmcgcGFydCBvZiBhIFJlYWN0IGNvbXBvbmVudCBpbmxpbmUgaW4gSlNYL1RTWC5cblxuICBAcGFyYW0gbWF0Y2hlciBBIGxpZ2h0d2VpZ2h0IG9iamVjdCBkZWZpbmluZyB3aGF0IHRvIGRvIGluIHRoZSBjYXNlIG9mIGVhY2hcbiAgICAgICAgICAgICAgICAgdmFyaWFudC5cbiAgQHBhcmFtIG1heWJlICAgVGhlIGBtYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaDxULCBBPihtYXRjaGVyOiBNYXRjaGVyPFQsIEE+LCBtYXliZTogTWF5YmU8VD4pOiBBO1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPFQsIEE+KG1hdGNoZXI6IE1hdGNoZXI8VCwgQT4pOiAobTogTWF5YmU8VD4pID0+IEE7XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2g8VCwgQT4obWF0Y2hlcjogTWF0Y2hlcjxULCBBPiwgbWF5YmU/OiBNYXliZTxUPik6IEEgfCAoKG06IE1heWJlPFQ+KSA9PiBBKSB7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkXG4gICAgPyBtYXBPckVsc2UobWF0Y2hlci5Ob3RoaW5nLCBtYXRjaGVyLkp1c3QsIG1heWJlKVxuICAgIDogKGN1cnJpZWRNYXliZTogTWF5YmU8VD4pID0+IG1hcE9yRWxzZShtYXRjaGVyLk5vdGhpbmcsIG1hdGNoZXIuSnVzdCwgY3VycmllZE1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYG1hdGNoYF0oI21hdGNoKSAqL1xuZXhwb3J0IGNvbnN0IGNhdGEgPSBtYXRjaDtcblxuLyoqXG4gIEFsbG93cyBxdWljayB0cmlwbGUtZXF1YWwgZXF1YWxpdHkgY2hlY2sgYmV0d2VlbiB0aGUgdmFsdWVzIGluc2lkZSB0d28gYG1heWJlYHNcbiAgd2l0aG91dCBoYXZpbmcgdG8gdW53cmFwIHRoZW0gZmlyc3QuXG5cbiAgYGBgdHNcbiAgY29uc3QgYSA9IE1heWJlLm9mKDMpO1xuICBjb25zdCBiID0gTWF5YmUub2YoMyk7XG4gIGNvbnN0IGMgPSBNYXliZS5vZihudWxsKTtcbiAgY29uc3QgZCA9IE1heWJlLm5vdGhpbmcoKTtcblxuICBNYXliZS5lcXVhbHMoYSwgYik7IC8vIHRydWVcbiAgTWF5YmUuZXF1YWxzKGEsIGMpOyAvLyBmYWxzZVxuICBNYXliZS5lcXVhbHMoYywgZCk7IC8vIHRydWVcbiAgYGBgXG5cbiAgQHBhcmFtIG1iIEEgYG1heWJlYCB0byBjb21wYXJlIHRvLlxuICBAcGFyYW0gbWEgQSBgbWF5YmVgIGluc3RhbmNlIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzPFQ+KG1iOiBNYXliZTxUPiwgbWE6IE1heWJlPFQ+KTogYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VD4obWI6IE1heWJlPFQ+KTogKG1hOiBNYXliZTxUPikgPT4gYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VD4obWI6IE1heWJlPFQ+LCBtYT86IE1heWJlPFQ+KTogYm9vbGVhbiB8ICgoYTogTWF5YmU8VD4pID0+IGJvb2xlYW4pIHtcbiAgcmV0dXJuIG1hICE9PSB1bmRlZmluZWRcbiAgICA/IG1hLm1hdGNoKHtcbiAgICAgICAgSnVzdDogYVZhbCA9PiBtYi5pc0p1c3QoKSAmJiBtYi51bnNhZmVseVVud3JhcCgpID09PSBhVmFsLFxuICAgICAgICBOb3RoaW5nOiAoKSA9PiBpc05vdGhpbmcobWIpLFxuICAgICAgfSlcbiAgICA6IChtYXliZUE6IE1heWJlPFQ+KSA9PlxuICAgICAgICBtYXliZUEubWF0Y2goe1xuICAgICAgICAgIE5vdGhpbmc6ICgpID0+IGlzTm90aGluZyhtYiksXG4gICAgICAgICAgSnVzdDogYVZhbCA9PiBtYi5pc0p1c3QoKSAmJiBtYi51bnNhZmVseVVud3JhcCgpID09PSBhVmFsLFxuICAgICAgICB9KTtcbn1cblxuLyoqXG4gIEFsbG93cyB5b3UgdG8gKmFwcGx5KiAodGh1cyBgYXBgKSBhIHZhbHVlIHRvIGEgZnVuY3Rpb24gd2l0aG91dCBoYXZpbmcgdG9cbiAgdGFrZSBlaXRoZXIgb3V0IG9mIHRoZSBjb250ZXh0IG9mIHRoZWlyIGBNYXliZWBzLiBUaGlzIGRvZXMgbWVhbiB0aGF0IHRoZVxuICB0cmFuc2Zvcm1pbmcgZnVuY3Rpb24gaXMgaXRzZWxmIHdpdGhpbiBhIGBNYXliZWAsIHdoaWNoIGNhbiBiZSBoYXJkIHRvIGdyb2tcbiAgYXQgZmlyc3QgYnV0IGxldHMgeW91IGRvIHNvbWUgdmVyeSBlbGVnYW50IHRoaW5ncy4gRm9yIGV4YW1wbGUsIGBhcGAgYWxsb3dzXG4gIHlvdSB0byB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCB7IGp1c3QsIG5vdGhpbmcgfSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGNvbnN0IG9uZSA9IGp1c3QoMSk7XG4gIGNvbnN0IGZpdmUgPSBqdXN0KDUpO1xuICBjb25zdCBub25lID0gbm90aGluZygpO1xuXG4gIGNvbnN0IGFkZCA9IChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiO1xuICBjb25zdCBtYXliZUFkZCA9IGp1c3QoYWRkKTtcblxuICBtYXliZUFkZC5hcChvbmUpLmFwKGZpdmUpOyAvLyBKdXN0KDYpXG4gIG1heWJlQWRkLmFwKG9uZSkuYXAobm9uZSk7IC8vIE5vdGhpbmdcbiAgbWF5YmVBZGQuYXAobm9uZSkuYXAoZml2ZSkgLy8gTm90aGluZ1xuICBgYGBcblxuICBXaXRob3V0IGBNYXliZS5hcGAsIHlvdSdkIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2UgYSBuZXN0ZWQgYE1heWJlLm1hdGNoYDpcblxuICBgYGB0c1xuICBpbXBvcnQgeyBqdXN0LCBub3RoaW5nIH0gZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBvbmUgPSBqdXN0KDEpO1xuICBjb25zdCBmaXZlID0ganVzdCg1KTtcbiAgY29uc3Qgbm9uZSA9IG5vdGhpbmcoKTtcblxuICBvbmUubWF0Y2goe1xuICAgIEp1c3Q6IG4gPT4gZml2ZS5tYXRjaCh7XG4gICAgICBKdXN0OiBvID0+IGp1c3QobiArIG8pLFxuICAgICAgTm90aGluZzogKCkgPT4gbm90aGluZygpLFxuICAgIH0pLFxuICAgIE5vdGhpbmc6ICgpICA9PiBub3RoaW5nKCksXG4gIH0pOyAvLyBKdXN0KDYpXG5cbiAgb25lLm1hdGNoKHtcbiAgICBKdXN0OiBuID0+IG5vbmUubWF0Y2goe1xuICAgICAgSnVzdDogbyA9PiBqdXN0KG4gKyBvKSxcbiAgICAgIE5vdGhpbmc6ICgpID0+IG5vdGhpbmcoKSxcbiAgICB9KSxcbiAgICBOb3RoaW5nOiAoKSAgPT4gbm90aGluZygpLFxuICB9KTsgLy8gTm90aGluZ1xuXG4gIG5vbmUubWF0Y2goe1xuICAgIEp1c3Q6IG4gPT4gZml2ZS5tYXRjaCh7XG4gICAgICBKdXN0OiBvID0+IGp1c3QobiArIG8pLFxuICAgICAgTm90aGluZzogKCkgPT4gbm90aGluZygpLFxuICAgIH0pLFxuICAgIE5vdGhpbmc6ICgpICA9PiBub3RoaW5nKCksXG4gIH0pOyAvLyBOb3RoaW5nXG4gIGBgYFxuXG4gIEFuZCB0aGlzIGtpbmQgb2YgdGhpbmcgY29tZXMgdXAgcXVpdGUgb2Z0ZW4gb25jZSB5b3UncmUgdXNpbmcgYE1heWJlYCB0b1xuICBoYW5kbGUgb3B0aW9uYWxpdHkgdGhyb3VnaG91dCB5b3VyIGFwcGxpY2F0aW9uLlxuXG4gIEZvciBhbm90aGVyIGV4YW1wbGUsIGltYWdpbmUgeW91IG5lZWQgdG8gY29tcGFyZSB0aGUgZXF1YWxpdHkgb2YgdHdvXG4gIEltbXV0YWJsZUpTIGRhdGEgc3RydWN0dXJlcywgd2hlcmUgYSBgPT09YCBjb21wYXJpc29uIHdvbid0IHdvcmsuIFdpdGggYGFwYCxcbiAgdGhhdCdzIGFzIHNpbXBsZSBhcyB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuICBpbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XG4gIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJ1xuXG4gIGNvbnN0IGlzID0gY3VycnkoSW1tdXRhYmxlLmlzKTtcblxuICBjb25zdCB4ID0gTWF5YmUub2YoSW1tdXRhYmxlLlNldC5vZigxLCAyLCAzKSk7XG4gIGNvbnN0IHkgPSBNYXliZS5vZihJbW11dGFibGUuU2V0Lm9mKDIsIDMsIDQpKTtcblxuICBNYXliZS5vZihpcykuYXAoeCkuYXAoeSk7IC8vIEp1c3QoZmFsc2UpXG4gIGBgYFxuXG4gIFdpdGhvdXQgYGFwYCwgd2UncmUgYmFjayB0byB0aGF0IGduYXJseSBuZXN0ZWQgYG1hdGNoYDpcblxuICBgYGB0c1xuICAgKiBpbXBvcnQgTWF5YmUsIHsganVzdCwgbm90aGluZyB9IGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG4gIGltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbiAgaW1wb3J0IHsgY3VycnkgfSBmcm9tICdsb2Rhc2gnXG5cbiAgY29uc3QgaXMgPSBjdXJyeShJbW11dGFibGUuaXMpO1xuXG4gIGNvbnN0IHggPSBNYXliZS5vZihJbW11dGFibGUuU2V0Lm9mKDEsIDIsIDMpKTtcbiAgY29uc3QgeSA9IE1heWJlLm9mKEltbXV0YWJsZS5TZXQub2YoMiwgMywgNCkpO1xuXG4gIHgubWF0Y2goe1xuICAgIEp1c3Q6IGlYID0+IHkubWF0Y2goe1xuICAgICAgSnVzdDogaVkgPT4gTWF5YmUuanVzdChJbW11dGFibGUuaXMoaVgsIGlZKSksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nKCksXG4gICAgfSlcbiAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nKCksXG4gIH0pOyAvLyBKdXN0KGZhbHNlKVxuICBgYGBcblxuICBJbiBzdW1tYXJ5OiBhbnl3aGVyZSB5b3UgaGF2ZSB0d28gYE1heWJlYCBpbnN0YW5jZXMgYW5kIG5lZWQgdG8gcGVyZm9ybSBhblxuICBvcGVyYXRpb24gdGhhdCB1c2VzIGJvdGggb2YgdGhlbSwgYGFwYCBpcyB5b3VyIGZyaWVuZC5cblxuICBUd28gdGhpbmdzIHRvIG5vdGUsIGJvdGggcmVnYXJkaW5nICpjdXJyeWluZyo6XG5cbiAgMS4gIEFsbCBmdW5jdGlvbnMgcGFzc2VkIHRvIGBhcGAgbXVzdCBiZSBjdXJyaWVkLiBUaGF0IGlzLCB0aGV5IG11c3QgYmUgb2YgdGhlXG4gICAgICBmb3JtIChmb3IgYWRkKSBgKGE6IG51bWJlcikgPT4gKGI6IG51bWJlcikgPT4gYSArIGJgLCAqbm90KiB0aGUgbW9yZSB1c3VhbFxuICAgICAgYChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGJgIHlvdSBzZWUgaW4gSmF2YVNjcmlwdCBtb3JlIGdlbmVyYWxseS5cblxuICAgICAgRm9yIGNvbnZlbmllbmNlLCB5b3UgbWF5IHdhbnQgdG8gbG9vayBhdCBMb2Rhc2gncyBgXy5jdXJyeWAgb3IgUmFtZGEnc1xuICAgICAgYFIuY3VycnlgLCB3aGljaCBhbGxvdyB5b3UgdG8gY3JlYXRlIGN1cnJpZWQgdmVyc2lvbnMgb2YgZnVuY3Rpb25zXG4gICAgICB3aGVuZXZlciB5b3Ugd2FudDpcblxuICAgICAgYGBgXG4gICAgICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcbiAgICAgIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJztcblxuICAgICAgY29uc3Qgbm9ybWFsQWRkID0gKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBhICsgYjtcbiAgICAgIGNvbnN0IGN1cnJpZWRBZGQgPSBjdXJyeShub3JtYWxBZGQpOyAvLyAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYjtcblxuICAgICAgTWF5YmUub2YoY3VycmllZEFkZCkuYXAoTWF5YmUub2YoMSkpLmFwKE1heWJlLm9mKDUpKTsgLy8gSnVzdCg2KVxuICAgICAgYGBgXG5cbiAgMi4gIFlvdSB3aWxsIG5lZWQgdG8gY2FsbCBgYXBgIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIGFyZ3VtZW50cyB0byB0aGVcbiAgICAgIGZ1bmN0aW9uIHlvdSdyZSBkZWFsaW5nIHdpdGguIFNvIGluIHRoZSBjYXNlIG9mIGBhZGRgLCB3aGljaCBoYXMgdGhlXG4gICAgICBcImFyaXR5XCIgKGZ1bmN0aW9uIGFyZ3VtZW50IGNvdW50KSBvZiAyIChgYWAgYW5kIGBiYCksIHlvdSdsbCBuZWVkIHRvIGNhbGxcbiAgICAgIGBhcGAgdHdpY2U6IG9uY2UgZm9yIGBhYCwgYW5kIG9uY2UgZm9yIGBiYC4gVG8gc2VlIHdoeSwgbGV0J3MgbG9vayBhdCB3aGF0XG4gICAgICB0aGUgcmVzdWx0IGluIGVhY2ggcGhhc2UgaXM6XG5cbiAgICAgIGBgYHRzXG4gICAgICBjb25zdCBhZGQgPSAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYjtcblxuICAgICAgY29uc3QgbWF5YmVBZGQgPSBNYXliZS5vZihhZGQpOyAvLyBKdXN0KChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiKVxuICAgICAgY29uc3QgbWF5YmVBZGQxID0gbWF5YmVBZGQuYXAoTWF5YmUub2YoMSkpOyAvLyBKdXN0KChiOiBudW1iZXIpID0+IDEgKyBiKVxuICAgICAgY29uc3QgZmluYWwgPSBtYXliZUFkZDEuYXAoTWF5YmUub2YoMykpOyAvLyBKdXN0KDQpXG4gICAgICBgYGBcblxuICAgICAgU28gZm9yIGB0b1N0cmluZ2AsIHdoaWNoIGp1c3QgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQsIHlvdSB3b3VsZCBvbmx5IG5lZWRcbiAgICAgIHRvIGNhbGwgYGFwYCBvbmNlLlxuXG4gICAgICBgYGB0c1xuICAgICAgY29uc3QgdG9TdHIgPSAodjogeyB0b1N0cmluZygpOiBzdHJpbmcgfSkgPT4gdi50b1N0cmluZygpO1xuICAgICAgTWF5YmUub2YodG9TdHIpLmFwKDEyKTsgLy8gSnVzdChcIjEyXCIpXG4gICAgICBgYGBcblxuICBPbmUgb3RoZXIgc2NlbmFyaW8gd2hpY2ggZG9lc24ndCBjb21lIHVwICpxdWl0ZSogYXMgb2Z0ZW4gYnV0IGlzIGNvbmNlaXZhYmxlXG4gIGlzIHdoZXJlIHlvdSBoYXZlIHNvbWV0aGluZyB0aGF0IG1heSBvciBtYXkgbm90IGFjdHVhbGx5IGNvbnN0cnVjdCBhIGZ1bmN0aW9uXG4gIGZvciBoYW5kbGluZyBhIHNwZWNpZmljIGBNYXliZWAgc2NlbmFyaW8uIEluIHRoYXQgY2FzZSwgeW91IGNhbiB3cmFwIHRoZVxuICBwb3NzaWJseS1wcmVzZW50IGluIGBhcGAgYW5kIHRoZW4gd3JhcCB0aGUgdmFsdWVzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbiB0b1xuICBpbiBgTWF5YmVgIHRoZW1zZWx2ZXMuXG5cbiAgKipBc2lkZToqKiBgYXBgIGlzIG5vdCBuYW1lZCBgYXBwbHlgIGJlY2F1c2Ugb2YgdGhlIG92ZXJsYXAgd2l0aCBKYXZhU2NyaXB0J3NcbiAgZXhpc3RpbmcgW2BhcHBseWBdIGZ1bmN0aW9uIOKAkyBhbmQgYWx0aG91Z2ggc3RyaWN0bHkgc3BlYWtpbmcsIHRoZXJlIGlzbid0IGFueVxuICBkaXJlY3Qgb3ZlcmxhcCAoYE1heWJlLmFwcGx5YCBhbmQgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAgZG9uJ3QgaW50ZXJzZWN0XG4gIGF0IGFsbCkgaXQncyB1c2VmdWwgdG8gaGF2ZSBhIGRpZmZlcmVudCBuYW1lIHRvIGF2b2lkIGltcGx5aW5nIHRoYXQgdGhleSdyZVxuICB0aGUgc2FtZS5cblxuICBbYGFwcGx5YF06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2FwcGx5XG5cbiAgQHBhcmFtIG1heWJlRm4gbWF5YmUgYSBmdW5jdGlvbiBmcm9tIFQgdG8gVVxuICBAcGFyYW0gbWF5YmUgbWF5YmUgYSBUIHRvIGFwcGx5IHRvIGBmbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwPFQsIFU+KG1heWJlRm46IE1heWJlPCh0OiBUKSA9PiBVPiwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVT4obWF5YmVGbjogTWF5YmU8KHQ6IFQpID0+IFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVT4oXG4gIG1heWJlRm46IE1heWJlPCh2YWw6IFQpID0+IFU+LFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBNYXliZTxVPiB8ICgodmFsOiBNYXliZTxUPikgPT4gTWF5YmU8VT4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+XG4gICAgbS5tYXRjaCh7XG4gICAgICBKdXN0OiB2YWwgPT4gbWF5YmVGbi5tYXAoZm4gPT4gZm4odmFsKSksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nPFU+KCksXG4gICAgfSk7XG5cbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgRGV0ZXJtaW5lIHdoZXRoZXIgYW4gaXRlbSBpcyBhbiBpbnN0YW5jZSBvZiBgSnVzdGAgb3IgYE5vdGhpbmdgLlxuXG4gIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZTxUID0gYW55PihpdGVtOiBhbnkpOiBpdGVtIGlzIE1heWJlPFQ+IHtcbiAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBKdXN0IHx8IGl0ZW0gaW5zdGFuY2VvZiBOb3RoaW5nO1xufVxuXG4vKiogQSB2YWx1ZSB3aGljaCBtYXkgKGBKdXN0PFQ+YCkgb3IgbWF5IG5vdCAoYE5vdGhpbmdgKSBiZSBwcmVzZW50LiAqL1xuZXhwb3J0IHR5cGUgTWF5YmU8VD4gPSBKdXN0PFQ+IHwgTm90aGluZzxUPjtcbmV4cG9ydCBjb25zdCBNYXliZSA9IHtcbiAgVmFyaWFudCxcbiAgSnVzdCxcbiAgTm90aGluZyxcbiAgaXNKdXN0LFxuICBpc05vdGhpbmcsXG4gIGp1c3QsXG4gIG5vdGhpbmcsXG4gIG9mLFxuICBmcm9tTnVsbGFibGUsXG4gIG1hcCxcbiAgbWFwT3IsXG4gIG1hcE9yRWxzZSxcbiAgYW5kLFxuICBhbmRUaGVuLFxuICBjaGFpbixcbiAgZmxhdE1hcCxcbiAgb3IsXG4gIG9yRWxzZSxcbiAgdW5zYWZlbHlVbndyYXAsXG4gIHVuc2FmZWx5R2V0LFxuICB1bnNhZmVHZXQsXG4gIHVud3JhcE9yLFxuICBnZXRPcixcbiAgdW53cmFwT3JFbHNlLFxuICBnZXRPckVsc2UsXG4gIHRvT2tPckVycixcbiAgdG9Pa09yRWxzZUVycixcbiAgZnJvbVJlc3VsdCxcbiAgdG9TdHJpbmcsXG4gIG1hdGNoLFxuICBjYXRhLFxuICBlcXVhbHMsXG4gIGFwLFxuICBpc0luc3RhbmNlLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTWF5YmU7XG4iXX0=