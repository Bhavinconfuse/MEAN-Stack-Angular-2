/**
 * Flowtype definitions for maybe
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import Result from './result';

export type Variant = 'Just' | 'Nothing';

/**
 * A `Just` instance is the present variant instance of the
 * [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
value which may be absent. For a full discussion, see [the module
docs](../modules/_maybe_.html).
 * @typeparam  T The type wrapped in this `Just` variant of `Maybe`.
*/
declare export class Just<T> {
  /**
     * `Just` is always [`Variant.Just`](../enums/_maybe_.variant#just). 
     */
  variant: Variant;

  /**
     * Create an instance of `Maybe.Just` with `new`.
     * 
    *Note:* While you may create the `Just` type via normal JavaScript
    class construction, it is not recommended for the functional style for
    which the library is intended. Instead, use [`Maybe.of`] (for the general
    case) or [`Maybe.just`] for this specific case.

    [`Maybe.of`]: ../modules/_maybe_.html#of
    [`Maybe.just`]: ../modules/_maybe_.html#just

    ```ts
    // Avoid:
    const aString = new Maybe.Just('characters');

    // Prefer:
    const aString = Maybe.just('characters);
    ```
     * @param value The value to wrap in a `Maybe.Just`.
    `null` and `undefined` are allowed by the type signature so that the
    constructor may `throw` on those rather than constructing a type like
    `Maybe<undefined>`.
     * @throws  If you pass `null` or `undefined`.
    */
  constructor(value: T | null | void): this;

  /**
     * Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) 
     */
  isJust(): boolean;

  /**
     * Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) 
     */
  isNothing(): boolean;

  /**
     * Method variant for [`Maybe.map`](../modules/_maybe_.html#map) 
     */
  map<U>(mapFn: (t: T) => U): Maybe<U>;

  /**
     * Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) 
     */
  mapOr<U>(orU: U, mapFn: (t: T) => U): U;

  /**
     * Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) 
     */
  mapOrElse<U>(orElseFn: () => U, mapFn: (t: T) => U): U;

  /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
  match<U>(matcher: Matcher<T, U>): U;

  /**
     * Method variant for [`Maybe.or`](../modules/_maybe_.html#or) 
     */
  or(mOr: Maybe<T>): Maybe<T>;

  /**
     * Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) 
     */
  orElse(orElseFn: () => Maybe<T>): Maybe<T>;

  /**
     * Method variant for [`Maybe.and`](../modules/_maybe_.html#and) 
     */
  and<U>(mAnd: Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) 
     */
  andThen<U>(andThenFn: (t: T) => Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) 
     */
  chain<U>(chainFn: (t: T) => Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) 
     */
  flatMap<U>(flatMapFn: (t: T) => Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) 
     */
  unsafelyUnwrap(): T;

  /**
     * Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) 
     */
  unwrapOr(defaultValue: T): T;

  /**
     * Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) 
     */
  unwrapOrElse(elseFn: () => T): T;

  /**
     * Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) 
     */
  toOkOrErr<E>(error: E): Result.Result<T, E>;

  /**
     * Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) 
     */
  toOkOrElseErr<E>(elseFn: () => E): Result.Result<T, E>;

  /**
     * Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) 
     */
  toString(): string;
}
/**
 * A `Nothing` instance is the absent variant instance of the
 * [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
value which may be absent. For a full discussion, see [the module
docs](../modules/_maybe_.html).
 * @typeparam  T The type which would be wrapped in a `Just` variant of `Maybe`.
*/
declare export class Nothing<T> {
  /**
     * `Nothing` is always [`Variant.Nothing`](../enums/_maybe_.variant#nothing). 
     */
  variant: Variant;

  /**
     * Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) 
     */
  isJust(): boolean;

  /**
     * Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) 
     */
  isNothing(): boolean;

  /**
     * Method variant for [`Maybe.map`](../modules/_maybe_.html#map) 
     */
  map<U>(mapFn: (t: T) => U): Maybe<U>;

  /**
     * Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) 
     */
  mapOr<U>(orU: U, mapFn: (t: T) => U): U;

  /**
     * Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) 
     */
  mapOrElse<U>(orElseFn: () => U, mapFn: (t: T) => U): U;

  /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
  match<U>(matcher: Matcher<T, U>): U;

  /**
     * Method variant for [`Maybe.or`](../modules/_maybe_.html#or) 
     */
  or(mOr: Maybe<T>): Maybe<T>;

  /**
     * Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) 
     */
  orElse(orElseFn: () => Maybe<T>): Maybe<T>;

  /**
     * Method variant for [`Maybe.and`](../modules/_maybe_.html#and) 
     */
  and<U>(mAnd: Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) 
     */
  andThen<U>(andThenFn: (t: T) => Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) 
     */
  chain<U>(chainFn: (t: T) => Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) 
     */
  flatMap<U>(flatMapFn: (t: T) => Maybe<U>): Maybe<U>;

  /**
     * Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) 
     */
  unsafelyUnwrap(): T;

  /**
     * Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) 
     */
  unwrapOr(defaultValue: T): T;

  /**
     * Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) 
     */
  unwrapOrElse(elseFn: () => T): T;

  /**
     * Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) 
     */
  toOkOrErr<E>(error: E): Result.Result<T, E>;

  /**
     * Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) 
     */
  toOkOrElseErr<E>(elseFn: () => E): Result.Result<T, E>;

  /**
     * Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) 
     */
  toString(): string;
}
export type Maybe<T> = Just<T> | Nothing<T>;
export type Matcher<T, A> = {
  Just: (value: T) => A,
  Nothing: () => A,
};
declare export var isJust: <T>(maybe: Maybe<T>) => boolean;
declare export var isNothing: <T>(maybe: Maybe<T>) => boolean;
declare export var just: <T>(value: T | null | void) => Maybe<T>;
declare export var nothing: <T>() => Maybe<T>;
declare export var of: <T>(value: T | null | void) => Maybe<T>;
declare export var fromNullable: <T>(value: T | null | void) => Maybe<T>;
declare export var map: <T, U>(mapFn: (t: T) => U, maybe: Maybe<T>) => Maybe<U>;
declare export var mapOr: <T, U>(orU: U, mapFn: (t: T) => U, maybe: Maybe<T>) => U;
declare export var mapOrElse: <T, U>(orElseFn: () => U, mapFn: (t: T) => U, maybe: Maybe<T>) => U;
declare export var match: <T, A>(matcher: Matcher<T, A>, maybe: Maybe<T>) => A;
declare export var cata: <T, A>(matcher: Matcher<T, A>, maybe: Maybe<T>) => A;
declare export var and: <T, U>(andMaybe: Maybe<U>, maybe: Maybe<T>) => Maybe<U>;
declare export var andThen: <T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>) => Maybe<U>;
declare export var chain: <T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>) => Maybe<U>;
declare export var flatMap: <T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>) => Maybe<U>;
declare export var or: <T>(defaultMaybe: Maybe<T>, maybe: Maybe<T>) => Maybe<T>;
declare export var orElse: <T>(elseFn: () => Maybe<T>, maybe: Maybe<T>) => Maybe<T>;
declare export var unsafelyUnwrap: <T>(maybe: Maybe<T>) => T;
declare export var unsafelyGet: <T>(maybe: Maybe<T>) => T;
declare export var unsafeGet: <T>(maybe: Maybe<T>) => T;
declare export var unwrapOr: <T>(defaultValue: T, maybe: Maybe<T>) => T;
declare export var getOr: <T>(defaultValue: T, maybe: Maybe<T>) => T;
declare export var unwrapOrElse: <T>(orElseFn: () => T, maybe: Maybe<T>) => T;
declare export var getOrElse: <T>(orElseFn: () => T, maybe: Maybe<T>) => T;
declare export var toOkOrErr: <T, E>(error: E, maybe: Maybe<T>) => Result.Result<T, E>;
declare export var toOkOrElseErr: <T, E>(elseFn: () => E, maybe: Maybe<T>) => Result.Result<T, E>;
declare export var fromResult: <T, E>(result: Result.Result<T, E>) => Maybe<T>;
declare export var toString: <T>(maybe: Maybe<T>) => string;
declare export var equals: <T>(mb: Maybe<T>, ma: Maybe<T>) => boolean;
declare export var ap: <T, U>(maybeFn: Maybe<(t: T) => U>, maybe: Maybe<T>) => Maybe<U>;
declare export default {
  Variant: Variant,
  Just: typeof Just,
  Nothing: typeof Nothing,
  isJust: <T>(maybe: Maybe<T>) => boolean,
  isNothing: <T>(maybe: Maybe<T>) => boolean,
  just: <T>(value?: T | null | void) => Maybe<T>,
  nothing: <T>(_?: null | void) => Maybe<T>,
  of: <T>(value?: T | null | void) => Maybe<T>,
  fromNullable: <T>(value?: T | null | void) => Maybe<T>,
  map: <T, U>(mapFn: (t: T) => U, maybe: Maybe<T>) => Maybe<U>,
  mapOr: <T, U>(orU: U, mapFn: (t: T) => U, maybe: Maybe<T>) => U,
  mapOrElse: <T, U>(orElseFn: () => U, mapFn: (t: T) => U, maybe: Maybe<T>) => U,
  and: <T, U>(andMaybe: Maybe<U>, maybe: Maybe<T>) => Maybe<U>,
  andThen: <T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>) => Maybe<U>,
  chain: <T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>) => Maybe<U>,
  flatMap: <T, U>(thenFn: (t: T) => Maybe<U>, maybe: Maybe<T>) => Maybe<U>,
  or: <T>(defaultMaybe: Maybe<T>, maybe: Maybe<T>) => Maybe<T>,
  orElse: <T>(elseFn: () => Maybe<T>, maybe: Maybe<T>) => Maybe<T>,
  unsafelyUnwrap: <T>(maybe: Maybe<T>) => T,
  unsafelyGet: <T>(maybe: Maybe<T>) => T,
  unsafeGet: <T>(maybe: Maybe<T>) => T,
  unwrapOr: <T>(defaultValue: T, maybe: Maybe<T>) => T,
  getOr: <T>(defaultValue: T, maybe: Maybe<T>) => T,
  unwrapOrElse: <T>(orElseFn: () => T, maybe: Maybe<T>) => T,
  getOrElse: <T>(orElseFn: () => T, maybe: Maybe<T>) => T,
  toOkOrErr: <T, E>(error: E, maybe: Maybe<T>) => Result<T, E>,
  toOkOrElseErr: <T, E>(elseFn: () => E, maybe: Maybe<T>) => Result<T, E>,
  fromResult: <T, E>(result: Result<T, E>) => Maybe<T>,
  toString: <T>(maybe: Maybe<T>) => string,
  match: <T, A>(matcher: Matcher<T, A>, maybe: Maybe<T>) => A,
  cata: <T, A>(matcher: Matcher<T, A>, maybe: Maybe<T>) => A,
  equals: <T>(mb: Maybe<T>, ma: Maybe<T>) => boolean,
  ap: <T, U>(maybeFn: Maybe<(t: T) => U>, maybe: Maybe<T>) => Maybe<U>,
}
