/**
 * Flowtype definitions for result
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import * as Maybe from './maybe';
import Unit from './unit';

type Variant = 'Ok' | 'Err';

/**
 * An `Ok` instance is the successful variant instance of the
 * [`Result`](../modules/_result_.html#result) type, representing a successful
outcome from an operation which may fail. For a full discussion, see [the
module docs](../modules/_result_.html).
* @typeparam  T The type wrapped in this `Ok` variant of `Result`.
* @typeparam  E The type which would be wrapped in an `Err` variant of `Result`.
*/
declare export class Ok<T, E> {
  /**
     * `Ok` is always [`Variant.Ok`](../enums/_result_.variant#ok). 
     */
  variant: Variant;

  /**
     * Create an instance of `Result.Ok` with `new`.
     * 
    <!---->*Note:* While you may create the `Result` type via normal
    JavaScript class construction, it is not recommended for the functional
    style for which the library is intended. Instead, use [`Result.ok`].

    [`Result.ok`]: ../modules/_result_.html#ok

    ```ts
    // Avoid:
    const aString = new Result.Ok('characters');

    // Prefer:
    const aString = Result.ok('characters);
    ```
    * @param value The value to wrap in a `Result.Ok`.
    `null` and `undefined` are allowed by the type signature so that the
    constructor may `throw` on those rather than constructing a type like
    `Result<undefined>`.
    * @throws  If you pass `null` or `undefined`.
    */
  constructor(value: T | null | void): this;

  /**
     * Method variant for [`Result.isOk`](../modules/_result_.html#isok) 
     */
  isOk(): boolean;

  /**
     * Method variant for [`Result.isErr`](../modules/_result_.html#iserr) 
     */
  isErr(): boolean;

  /**
     * Method variant for [`Result.map`](../modules/_result_.html#map) 
     */
  map<U>(mapFn: (t: T) => U): Result<U, E>;

  /**
     * Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) 
     */
  mapOr<U>(orU: U, mapFn: (t: T) => U): U;

  /**
     * Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) 
     */
  mapOrElse<U>(orElseFn: (err: E) => U, mapFn: (t: T) => U): U;

  /** Method variant for [`Result.match`](../modules/_result_.html#match) */
  match<U>(matcher: Matcher<T, E, U>): U;

  /**
     * Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) 
     */
  mapErr<F>(mapErrFn: (e: E) => F): Result<T, F>;

  /**
     * Method variant for [`Result.or`](../modules/_result_.html#or) 
     */
  or<F>(orResult: Result<T, F>): Result<T, F>;

  /**
     * Method variant for [`Result.orElse`](../modules/_result_.html#orelse) 
     */
  orElse<F>(orElseFn: (err: E) => Result<T, F>): Result<T, F>;

  /**
     * Method variant for [`Result.and`](../modules/_result_.html#and) 
     */
  and<U>(mAnd: Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.andThen`](../modules/_result_.html#andthen) 
     */
  andThen<U>(andThenFn: (t: T) => Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.chain`](../modules/_result_.html#chain) 
     */
  chain<U>(chainFn: (t: T) => Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) 
     */
  flatMap<U>(flatMapFn: (t: T) => Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.unwrap`](../modules/_result_.html#unwrap) 
     */
  unsafelyUnwrap(): T;

  /**
     * Method variant for [`Result.unwrapErr`](../modules/_result_.html#unwraperr) 
     */
  unsafelyUnwrapErr(): 'NO PRINT IMPLEMENTED: NeverKeyword';

  /**
     * Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) 
     */
  unwrapOr(defaultValue: T): T;

  /**
     * Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwrapOrElse) 
     */
  unwrapOrElse(elseFn: (error: E) => T): T;

  /**
     * Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) 
     */
  toMaybe(): Maybe<T>;

  /**
     * Method variant for [`Result.toString`](../modules/_result_.html#tostring) 
     */
  toString(): string;
}
/**
 * An `Err` instance is the failure variant instance of the
 * [`Result`](../modules/_result_.html#result) type, representing a failure
outcome from an operation which may fail. For a full discussion, see [the
module docs](../modules/_result_.html).
* @typeparam  T The type which would be wrapped in an `Ok` variant of `Result`.
* @typeparam  E The type wrapped in this `Err` variant of `Result`.
*/
declare export class Err<T, E> {
  /**
     * `Err` is always [`Variant.Err`](../enums/_result_.variant#err). 
     */
  variant: Variant;

  /**
     * Create an instance of `Result.Err` with `new`.
     * 
    <!---->*Note:* While you may create the `Result` type via normal
    JavaScript class construction, it is not recommended for the functional
    style for which the library is intended. Instead, use [`Result.err`].

    [`Result.err`]: ../modules/_result_.html#err

    ```ts
    // Avoid:
    const anErr = new Result.Err('alas, failure');

    // Prefer:
    const anErr = Result.err('alas, failure');
    ```
    * @param error The value to wrap in a `Result.Err`.
    `null` and `undefined` are allowed by the type signature so that the
    constructor may `throw` on those rather than constructing a type like
    `Result<undefined>`.
    * @throws  If you pass `null` or `undefined`.
    */
  constructor(error: E | null | void): this;

  /**
     * Method variant for [`Result.isOk`](../modules/_result_.html#isok) 
     */
  isOk(): boolean;

  /**
     * Method variant for [`Result.isErr`](../modules/_result_.html#iserr) 
     */
  isErr(): boolean;

  /**
     * Method variant for [`Result.map`](../modules/_result_.html#map) 
     */
  map<U>(mapFn: (t: T) => U): Result<U, E>;

  /**
     * Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) 
     */
  mapOr<U>(orU: U, mapFn: (t: T) => U): U;

  /**
     * Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) 
     */
  mapOrElse<U>(orElseFn: (err: E) => U, mapFn: (t: T) => U): U;

  /** Method variant for [`Result.match`](../modules/_result_.html#match) */
  match<U>(matcher: Matcher<T, E, U>): U;

  /**
     * Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) 
     */
  mapErr<F>(mapErrFn: (e: E) => F): Result<T, F>;

  /**
     * Method variant for [`Result.or`](../modules/_result_.html#or) 
     */
  or<F>(orResult: Result<T, F>): Result<T, F>;

  /**
     * Method variant for [`Result.orElse`](../modules/_result_.html#orelse) 
     */
  orElse<F>(orElseFn: (err: E) => Result<T, F>): Result<T, F>;

  /**
     * Method variant for [`Result.and`](../modules/_result_.html#and) 
     */
  and<U>(mAnd: Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.andThen`](../modules/_result_.html#andthen) 
     */
  andThen<U>(andThenFn: (t: T) => Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.chain`](../modules/_result_.html#chain) 
     */
  chain<U>(chainFn: (t: T) => Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) 
     */
  flatMap<U>(flatMapFn: (t: T) => Result<U, E>): Result<U, E>;

  /**
     * Method variant for [`Result.unsafelyUnwrap`](../modules/_result_.html#unsafelyunwrap) 
     */
  unsafelyUnwrap(): 'NO PRINT IMPLEMENTED: NeverKeyword';

  /**
     * Method variant for [`Result.unsafelyUnwrapErr`](../modules/_result_.html#unsafelyunwraperr) 
     */
  unsafelyUnwrapErr(): E;

  /**
     * Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) 
     */
  unwrapOr(defaultValue: T): T;

  /**
     * Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwraporelse) 
     */
  unwrapOrElse(elseFn: (error: E) => T): T;

  /**
     * Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) 
     */
  toMaybe(): Maybe<T>;

  /**
     * Method variant for [`Result.toString`](../modules/_result_.html#tostring) 
     */
  toString(): string;
}
export type Matcher<T, E, A> = {
  Ok: (value: T) => A,
  Err: (error: E) => A,
};

export type Result<T, E> = Ok<T, E> | Err<T, E>;

declare export var isOk: <T, E>(result: Result<T, E>) => boolean;
declare export var isErr: <T, E>(result: Result<T, E>) => boolean;
declare export function ok<Unit, E>(): Result<Unit, E>;
declare export function ok<T, E>(value: T | null): Result<T, E>;
declare export function err<Unit, E>(): Result<Unit, E>;
declare export function err<T, E>(error: E | null): Result<T, E>;
declare export var map: <T, U, E>(mapFn: (t: T) => U, result: Result<T, E>) => Result<U, E>;
declare export var mapOr: <T, U, E>(orU: U, mapFn: (t: T) => U, result: Result<T, E>) => U;
declare export var mapOrElse: <T, U, E>(
  orElseFn: (err: E) => U,
  mapFn: (t: T) => U,
  result: Result<T, E>
) => U;
declare export var match: <T, E, A>(matcher: Matcher<T, E, A>, result: Result<T, E>) => A;
declare export var cata: <T, E, A>(matcher: Matcher<T, E, A>, result: Result<T, E>) => A;
declare export var mapErr: <T, E, F>(mapErrFn: (e: E) => F, result: Result<T, E>) => Result<T, F>;
declare export var and: <T, U, E>(andResult: Result<U, E>, result: Result<T, E>) => Result<U, E>;
declare export var andThen: <T, U, E>(
  thenFn: (t: T) => Result<U, E>,
  result: Result<T, E>
) => Result<U, E>;
declare export var chain: <T, U, E>(
  thenFn: (t: T) => Result<U, E>,
  result: Result<T, E>
) => Result<U, E>;
declare export var flatMap: <T, U, E>(
  thenFn: (t: T) => Result<U, E>,
  result: Result<T, E>
) => Result<U, E>;
declare export var or: <T, E, F>(defaultResult: Result<T, F>, result: Result<T, E>) => Result<T, F>;
declare export var orElse: <T, E, F>(
  elseFn: (err: E) => Result<T, F>,
  result: Result<T, E>
) => Result<T, F>;
declare export var unsafelyUnwrap: <T, E>(result: Result<T, E>) => T;
declare export var unsafelyGet: <T, E>(result: Result<T, E>) => T;
declare export var unsafeGet: <T, E>(result: Result<T, E>) => T;
declare export var unsafelyUnwrapErr: <T, E>(result: Result<T, E>) => E;
declare export var unsafelyGetErr: <T, E>(result: Result<T, E>) => E;
declare export var unwrapOr: <T, E>(defaultValue: T, result: Result<T, E>) => T;
declare export var getOr: <T, E>(defaultValue: T, result: Result<T, E>) => T;
declare export var unwrapOrElse: <T, E>(orElseFn: (error: E) => T, result: Result<T, E>) => T;
declare export var getOrElse: <T, E>(orElseFn: (error: E) => T, result: Result<T, E>) => T;
declare export var toMaybe: <T, E>(result: Result<T, E>) => Maybe<T>;
declare export var fromMaybe: <T, E>(errValue: E, maybe: Maybe<T>) => Result<T, E>;
declare export var toString: <T, E>(result: Result<T, E>) => string;
declare export var equals: <T, E>(resultB: Result<T, E>, resultA: Result<T, E>) => boolean;
declare export var ap: <T, U, E>(resultFn: Result<(t: T) => U, E>, result: Result<T, E>): Result<U, E>;
declare export default {
  Variant: Variant,
  Ok: typeof Ok,
  Err: typeof Err,
  isOk: <T, E>(result: Result<T, E>) => boolean,
  isErr: <T, E>(result: Result<T, E>) => boolean,
  ok: <T, E>(value?: T | null | void) => Result<T, E>,
  err: <T, E>(error?: E | null | void) => Result<T, E>,
  map: <T, U, E>(mapFn: (t: T) => U, result: Result<T, E>) => Result<U, E>,
  mapOr: <T, U, E>(orU: U, mapFn: (t: T) => U, result: Result<T, E>) => U,
  mapOrElse: <T, U, E>(orElseFn: (err: E) => U, mapFn: (t: T) => U, result: Result<T, E>) => U,
  mapErr: <T, E, F>(mapErrFn: (e: E) => F, result: Result<T, E>) => Result<T, F>,
  and: <T, U, E>(andResult: Result<U, E>, result: Result<T, E>) => Result<U, E>,
  andThen: <T, U, E>(thenFn: (t: T) => Result<U, E>, result: Result<T, E>) => Result<U, E>,
  chain: <T, U, E>(thenFn: (t: T) => Result<U, E>, result: Result<T, E>) => Result<U, E>,
  flatMap: <T, U, E>(thenFn: (t: T) => Result<U, E>, result: Result<T, E>) => Result<U, E>,
  or: <T, E, F>(defaultResult: Result<T, F>, result: Result<T, E>) => Result<T, F>,
  orElse: <T, E, F>(elseFn: (err: E) => Result<T, F>, result: Result<T, E>) => Result<T, F>,
  unsafelyUnwrap: <T, E>(result: Result<T, E>) => T,
  unsafelyGet: <T, E>(result: Result<T, E>) => T,
  unsafeGet: <T, E>(result: Result<T, E>) => T,
  unsafelyUnwrapErr: <T, E>(result: Result<T, E>) => E,
  unsafelyGetErr: <T, E>(result: Result<T, E>) => E,
  unwrapOr: <T, E>(defaultValue: T, result: Result<T, E>) => T,
  getOr: <T, E>(defaultValue: T, result: Result<T, E>) => T,
  unwrapOrElse: <T, E>(orElseFn: (error: E) => T, result: Result<T, E>) => T,
  getOrElse: <T, E>(orElseFn: (error: E) => T, result: Result<T, E>) => T,
  toMaybe: <T, E>(result: Result<T, E>) => Maybe<T>,
  fromMaybe: <T, E>(errValue: E, maybe: Maybe<T>) => Result<T, E>,
  toString: <T, E>(result: Result<T, E>) => string,
  match: <T, E, A>(matcher: Matcher<T, E, A>, result: Result<T, E>) => A,
  cata: <T, E, A>(matcher: Matcher<T, E, A>, result: Result<T, E>) => A,
  equals: <T, E>(resultB: Result<T, E>, resultA: Result<T, E>) => boolean,
  ap: <T, U, E>(resultFn: Result<(t: T) => U, E>, result: Result<T, E>) => Result<U, E>,
}
